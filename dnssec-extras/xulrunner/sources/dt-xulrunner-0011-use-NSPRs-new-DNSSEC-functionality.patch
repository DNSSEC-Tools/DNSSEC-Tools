From fd0139fc8c912a2db4deadd3080fa6f695e7a95c Mon Sep 17 00:00:00 2001
From: Robert Story <rstory@localhost>
Date: Tue, 16 Oct 2012 23:33:24 -0400
Subject: [PATCH 11/16] XULRUNNER use NSPRs new DNSSEC functionality

---
 configure.in                     |    6 ++-
 netwerk/base/public/nsNetError.h |   12 +++++
 netwerk/dns/nsDNSService2.cpp    |   25 +++++++++++
 netwerk/dns/nsDNSService2.h      |    4 ++
 netwerk/dns/nsHostResolver.cpp   |   84 ++++++++++++++++++++++++++++++++++++--
 netwerk/dns/nsHostResolver.h     |   30 ++++++++++++-
 6 files changed, 153 insertions(+), 8 deletions(-)

diff --git a/configure.in b/configure.in
index 1ae81f1..edcc8b5 100644
--- a/configure.in
+++ b/configure.in
@@ -8260,9 +8260,11 @@ AC_ARG_WITH(system-openssl,
    [with_system_openssl=no])
 
 VAL_LIBS=""
+VAL_CFLAGS=""
 OPENSSL_LIBS=""
 if test "x$with_system_val" != xno; then
-  CFLAGS="$CFLAGS -I${with_system_val}/include"
+  VAL_CFLAGS="-I${with_system_val}/include"
+  CFLAGS="$CFLAGS $VAL_CFLAGS"
   if test -n "$_WIN32_MSVC"; then
     VAL_LIBS="${with_system_val}/lib/libval-threads.a ${with_system_val}/lib/libsres.a ${with_system_val}/lib/libcrypto.a ${with_system_val}/lib/libpthread.dll.a ${with_system_val}/lib/libgcc.a user32.lib gdi32.lib Ws2_32.lib"
     AC_DEFINE(MOZ_DNSSEC)
@@ -8297,7 +8299,9 @@ if test "x$with_system_val" != xno; then
 fi
 LIBS="$LIBS $VAL_LIBS"
 NSPR_LIBS="$NSPR_LIBS $VAL_LIBS"
+NSPR_CFLAGS="$NSPR_CFLAGS $VAL_CFLAGS"
 AC_SUBST(VAL_LIBS)
+AC_SUBST(VAL_CFLAGS)
 AC_SUBST(MOZ_DNSSEC)
 
 dnl ========================================================
diff --git a/netwerk/base/public/nsNetError.h b/netwerk/base/public/nsNetError.h
index 00ae4ae..60dd67a 100644
--- a/netwerk/base/public/nsNetError.h
+++ b/netwerk/base/public/nsNetError.h
@@ -275,6 +275,18 @@
     NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_NETWORK, 33)
 
 /**
+ * A DNS lookup failed DNSSEC validation.
+ */
+#define NS_ERROR_DNSSEC_VALIDATION_ERROR \
+    NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_NETWORK, 35)
+
+/**
+ * A DNS lookup was proven to not exist.
+ */
+#define NS_ERROR_DNSSEC_DNE_ERROR \
+    NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_NETWORK, 36)
+
+/**
  * The lookup of a proxy hostname failed.
  *
  * If a channel is configured to speak to a proxy server, then it will
diff --git a/netwerk/dns/nsDNSService2.cpp b/netwerk/dns/nsDNSService2.cpp
index 150728c..e70820f 100644
--- a/netwerk/dns/nsDNSService2.cpp
+++ b/netwerk/dns/nsDNSService2.cpp
@@ -347,6 +347,12 @@ nsDNSSyncRequest::EqualsAsyncListener(nsIDNSListener *aListener)
 
 //-----------------------------------------------------------------------------
 
+#ifdef MOZ_DNSSEC
+
+val_context_t *nsDNSService::mValContext = nullptr;
+
+#endif
+
 nsDNSService::nsDNSService()
     : mLock("nsDNSServer.mLock")
     , mFirstTime(true)
@@ -423,6 +429,11 @@ nsDNSService::Init()
         }
     }
 
+#ifdef MOZ_DNSSEC
+    if (nullptr == mValContext)
+        val_create_context((char*)"mozilla-browser", &mValContext);
+#endif
+
     // we have to null out mIDN since we might be getting re-initialized
     // as a result of a pref change.
     nsCOMPtr<nsIIDNService> idn;
@@ -440,6 +451,9 @@ nsDNSService::Init()
     nsresult rv = nsHostResolver::Create(maxCacheEntries,
                                          maxCacheLifetime,
                                          lifetimeGracePeriod,
+#ifdef MOZ_DNSSEC
+                                         mValContext,
+#endif
                                          getter_AddRefs(res));
     if (NS_SUCCEEDED(rv)) {
         // now, set all of our member variables while holding the lock
@@ -471,14 +485,25 @@ nsDNSService::Init()
 NS_IMETHODIMP
 nsDNSService::Shutdown()
 {
+#ifdef MOZ_DNSSEC
+    val_context *ctx = nsnull;
+#endif
     nsRefPtr<nsHostResolver> res;
     {
         MutexAutoLock lock(mLock);
         res = mResolver;
         mResolver = nsnull;
+#ifdef MOZ_DNSSEC
+        ctx = mValContext;
+        mValContext = nsnull;
+#endif
     }
     if (res)
         res->Shutdown();
+#ifdef MOZ_DNSSEC
+    if (nsnull != ctx)
+        val_free_context(ctx);
+#endif
     return NS_OK;
 }
 
diff --git a/netwerk/dns/nsDNSService2.h b/netwerk/dns/nsDNSService2.h
index e08f616..df6acdb 100644
--- a/netwerk/dns/nsDNSService2.h
+++ b/netwerk/dns/nsDNSService2.h
@@ -34,6 +34,10 @@ private:
     // mLock protects access to mResolver and mIPv4OnlyDomains
     mozilla::Mutex            mLock;
 
+#ifdef MOZ_DNSSEC
+    static val_context_t     *mValContext;
+#endif
+
     // mIPv4OnlyDomains is a comma-separated list of domains for which only
     // IPv4 DNS lookups are performed. This allows the user to disable IPv6 on
     // a per-domain basis and work around broken DNS servers. See bug 68796.
diff --git a/netwerk/dns/nsHostResolver.cpp b/netwerk/dns/nsHostResolver.cpp
index 45caeff..bbd8725 100644
--- a/netwerk/dns/nsHostResolver.cpp
+++ b/netwerk/dns/nsHostResolver.cpp
@@ -24,6 +24,7 @@
 #include "nsAutoPtr.h"
 #include "pratom.h"
 #include "prthread.h"
+#include "prnetdb.h"
 #include "prerror.h"
 #include "prtime.h"
 #include "prlong.h"
@@ -146,7 +147,11 @@ private:
 // this macro filters out any flags that are not used when constructing the
 // host key.  the significant flags are those that would affect the resulting
 // host record (i.e., the flags that are passed down to PR_GetAddrInfoByName).
+#ifdef MOZ_DNSSEC
+#define RES_KEY_FLAGS(_f) ((_f) & (nsHostResolver::RES_CANON_NAME|nsHostResolver::RES_EXTENDED_ERRS))
+#else
 #define RES_KEY_FLAGS(_f) ((_f) & nsHostResolver::RES_CANON_NAME)
+#endif
 
 nsHostRecord::nsHostRecord(const nsHostKey *key)
     : addr_info_lock("nsHostRecord.addr_info_lock")
@@ -162,6 +167,10 @@ nsHostRecord::nsHostRecord(const nsHostKey *key)
     memcpy((char *) host, key->host, strlen(key->host) + 1);
     flags = key->flags;
     af = key->af;
+#ifdef MOZ_DNSSEC
+    saved_status = NS_OK;
+    security_status_flags = 0;
+#endif
 
     expiration = NowInMinutes();
 
@@ -337,10 +346,17 @@ HostDB_RemoveEntry(PLDHashTable *table,
 
 nsHostResolver::nsHostResolver(PRUint32 maxCacheEntries,
                                PRUint32 maxCacheLifetime,
-                               PRUint32 lifetimeGracePeriod)
+                               PRUint32 lifetimeGracePeriod
+#ifdef MOZ_DNSSEC
+                               , val_context_t *valContext
+#endif
+    )
     : mMaxCacheEntries(maxCacheEntries)
     , mMaxCacheLifetime(maxCacheLifetime)
     , mGracePeriod(lifetimeGracePeriod)
+#ifdef MOZ_DNSSEC
+    , mValContext(valContext)
+#endif
     , mLock("nsHostResolver.mLock")
     , mIdleThreadCV(mLock, "nsHostResolver.mIdleThreadCV")
     , mNumIdleThreads(0)
@@ -504,6 +520,10 @@ nsHostResolver::ResolveHost(const char            *host,
     if (!net_IsValidHostName(nsDependentCString(host)))
         return NS_ERROR_UNKNOWN_HOST;
 
+#ifdef MOZ_DNSSEC
+    flags = flags | RES_EXTENDED_ERRS;
+#endif
+
     // if result is set inside the lock, then we need to issue the
     // callback before returning.
     nsRefPtr<nsHostRecord> result;
@@ -565,7 +585,17 @@ nsHostResolver::ResolveHost(const char            *host,
                     Telemetry::Accumulate(Telemetry::DNS_LOOKUP_METHOD2,
                                           METHOD_NEGATIVE_HIT);
                     status = NS_ERROR_UNKNOWN_HOST;
+                    if (!he->rec->resolving)
+                        // return the cached failure to the caller, but try
+                        // and refresh the record in the background
+                        IssueLookup(he->rec);
                 }
+#ifdef MOZ_DNSSEC
+                else {
+                    // use the cached status value
+                    status = he->rec->saved_status;
+                }
+#endif
             }
             // if the host name is an IP address literal and has been parsed,
             // go ahead and use it.
@@ -856,6 +886,9 @@ nsHostResolver::OnLookupComplete(nsHostRecord *rec, nsresult status, PRAddrInfo
             rec->expiration += 1;                 /* one minute for negative cache */
             rec->negative = true;
         }
+#ifdef MOZ_DNSSEC
+        rec->saved_status = status;
+#endif
         rec->resolving = false;
         
         if (rec->usingAnyThread) {
@@ -946,6 +979,25 @@ nsHostResolver::CancelAsyncRequest(const char            *host,
         }
     }
 }
+//  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
+#ifdef MOZ_DNSSEC
+static nsresult
+_ns_translate_dnssec_error(PRErrorCode err)
+{
+    switch(err) {
+        case PR_DNSSEC_VALIDATION_ERROR:
+            return NS_ERROR_DNSSEC_VALIDATION_ERROR;
+            break;
+
+        case PR_DNSSEC_DNE_ERROR:
+            return NS_ERROR_DNSSEC_DNE_ERROR;
+            break;
+    }
+
+    return NS_ERROR_UNKNOWN_HOST;
+}
+
+#endif // MOZ_DNSSEC
 
 //----------------------------------------------------------------------------
 
@@ -972,11 +1024,24 @@ nsHostResolver::ThreadFunc(void *arg)
 
         TimeStamp startTime = TimeStamp::Now();
 
-        ai = PR_GetAddrInfoByName(rec->host, rec->af, flags);
+#ifdef MOZ_DNSSEC
+        if (rec->flags & RES_EXTENDED_ERRS) {
+            ai = PR_GetAddrInfoByNameExtended(rec->host, rec->af, flags,
+                                              &(rec->security_status_flags));
 #if defined(RES_RETRY_ON_FAILURE)
-        if (!ai && rs.Reset())
+            if (!ai && rs.Reset())
+                ai = PR_GetAddrInfoByNameExtended(rec->host, rec->af, flags,
+                                              &(rec->security_status_flags));
+#endif
+        } else
+#endif
+        {
             ai = PR_GetAddrInfoByName(rec->host, rec->af, flags);
+#if defined(RES_RETRY_ON_FAILURE)
+            if (!ai && rs.Reset())
+                ai = PR_GetAddrInfoByName(rec->host, rec->af, flags);
 #endif
+        }
 
         TimeDuration elapsed = TimeStamp::Now() - startTime;
         PRUint32 millis = static_cast<PRUint32>(elapsed.ToMilliseconds());
@@ -992,7 +1057,11 @@ nsHostResolver::ThreadFunc(void *arg)
                                   millis);
         }
         else {
+#ifdef MOZ_DNSSEC
+            status = _ns_translate_dnssec_error(PR_GetError());
+#else
             status = NS_ERROR_UNKNOWN_HOST;
+#endif
             Telemetry::Accumulate(Telemetry::DNS_FAILED_LOOKUP_TIME, millis);
         }
         
@@ -1009,6 +1078,9 @@ nsresult
 nsHostResolver::Create(PRUint32         maxCacheEntries,
                        PRUint32         maxCacheLifetime,
                        PRUint32         lifetimeGracePeriod,
+#ifdef MOZ_DNSSEC
+                       val_context_t *valContext,
+#endif
                        nsHostResolver **result)
 {
 #if defined(PR_LOGGING)
@@ -1018,7 +1090,11 @@ nsHostResolver::Create(PRUint32         maxCacheEntries,
 
     nsHostResolver *res = new nsHostResolver(maxCacheEntries,
                                              maxCacheLifetime,
-                                             lifetimeGracePeriod);
+                                             lifetimeGracePeriod
+#ifdef MOZ_DNSSEC
+                                             , valContext
+#endif
+        );
     if (!res)
         return NS_ERROR_OUT_OF_MEMORY;
     NS_ADDREF(res);
diff --git a/netwerk/dns/nsHostResolver.h b/netwerk/dns/nsHostResolver.h
index 08adfe9..3173e08 100644
--- a/netwerk/dns/nsHostResolver.h
+++ b/netwerk/dns/nsHostResolver.h
@@ -11,6 +11,7 @@
 #include "prclist.h"
 #include "prnetdb.h"
 #include "pldhash.h"
+#include "prerror.h"
 #include "mozilla/CondVar.h"
 #include "mozilla/Mutex.h"
 #include "nsISupportsImpl.h"
@@ -76,8 +77,16 @@ public:
                                 of that negative entry forces an asynchronous refresh. */
 
     PRUint32     expiration; /* measured in minutes since epoch */
+#ifdef MOZ_DNSSEC
+    PRUint16     security_status_flags; /* DNSSEC information (bitmask) */
+    nsresult     saved_status;
+#endif
 
-    bool HasResult() const { return addr_info || addr || negative; }
+    bool HasResult() const { return addr_info || addr ||
+#ifdef MOZ_DNSSEC
+            security_status_flags ||
+#endif
+            negative; }
 
     // hold addr_info_lock when calling the blacklist functions
     bool Blacklisted(PRNetAddr *query);
@@ -87,6 +96,8 @@ public:
 private:
     friend class nsHostResolver;
 
+    PRIntervalTime start;
+
     PRCList callbacks; /* list of callbacks */
 
     bool    resolving; /* true if this record is being resolved, which means
@@ -168,6 +179,9 @@ public:
     static nsresult Create(PRUint32         maxCacheEntries,  // zero disables cache
                            PRUint32         maxCacheLifetime, // minutes
                            PRUint32         lifetimeGracePeriod, // minutes
+#ifdef MOZ_DNSSEC
+                           val_context_t    *valContext,
+#endif
                            nsHostResolver **resolver);
     
     /**
@@ -224,12 +238,19 @@ public:
         RES_CANON_NAME   = 1 << 1,
         RES_PRIORITY_MEDIUM   = 1 << 2,
         RES_PRIORITY_LOW  = 1 << 3,
-        RES_SPECULATE     = 1 << 4   
+        RES_SPECULATE     = 1 << 4
+#ifdef MOZ_DNSSEC
+        , RES_EXTENDED_ERRS = 1 << 7
+#endif
     };
 
 private:
     nsHostResolver(PRUint32 maxCacheEntries = 50, PRUint32 maxCacheLifetime = 1,
-                   PRUint32 lifetimeGracePeriod = 0);
+                   PRUint32 lifetimeGracePeriod = 0
+#ifdef MOZ_DNSSEC
+                   , val_context_t *valContext = nullptr
+#endif
+        );
    ~nsHostResolver();
 
     nsresult Init();
@@ -257,6 +278,9 @@ private:
     PRUint32      mMaxCacheEntries;
     PRUint32      mMaxCacheLifetime;
     PRUint32      mGracePeriod;
+#ifdef MOZ_DNSSEC
+    val_context_t *mValContext;
+#endif
     Mutex         mLock;
     CondVar       mIdleThreadCV;
     PRUint32      mNumIdleThreads;
-- 
1.7.7.6

