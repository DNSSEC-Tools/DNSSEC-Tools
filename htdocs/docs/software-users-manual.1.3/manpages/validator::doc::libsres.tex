\clearpage

\subsubsection{libsres}

{\bf NAME}

\func{query\_send()}, \func{response\_rcv()}, \func{get()} - 
send queries and receive responses from a DNS name server

\func{clone\_ns()}, \func{clone\_ns\_list()}, \func{free\_name\_server()},
\func{free\_name\_servers()} - manage name server lists

\func{print\_response()} - display answers returned from the name server

{\bf SYNOPSIS}

\begin{verbatim}
    #include <resolver.h>

    int query_send(const char          *name,
                   const u_int16_t     type,
                   const u_int16_t     class,
                   struct name_server  *nslist,
                   int                 edns0_size,
                   int                 *trans_id);
  
    int response_recv(int                 *trans_id,
                      struct name_server  **respondent,
                      u_int8_t            **response,
                      u_int32_t           *response_length);

    int get(const char          *name_n,
            const u_int16_t     type_h,
            const u_int16_t     class_h,
            struct name_server  *nslist,
            int                 edns0_size,
            struct name_server  **respondent,
            u_int8_t            **response,
            u_int32_t           *response_length);

    int clone_ns(struct name_server **cloned_ns,
                 struct name_server *ns);

    int clone_ns_list(struct name_server **ns_list,
                      struct name_server *orig_ns_list);

    void free_name_server(struct name_server **ns);

    void free_name_servers(struct name_server **ns);

    void print_response(u_int8_t *response, int response_length);
\end{verbatim}

{\bf DESCRIPTION}

The \func{query\_send()} function sends a query to the name servers specified
in \var{nslist}.  The query is comprised of the $<${\it name, class, type}$>$
tuple and \var{trans\_id} provides a handle to this transaction within the
\lib{libsres} library.  The buffer size advertised in the EDNS0 option can be
set using the \var{ends0\_size} argument.

The \func{response\_recv()} function returns the answers, if available, from the
name server that responds for the query identified by \var{trans\_id}.
The response is available in \var{response} and the responding name server is
returned in \var{respondent}.  The length of the response in bytes is returned
in \var{response\_length}.

The \func{get()} function provides a wrapper around the \func{query\_send()} and
\func{response\_recv()} functions.  After sending a request, it blocks until
a response is received from some name server or until the request times out.
The \lib{libsres} library does not automatically follow referrals; responses
containing referrals are treated as valid responses.

The memory pointed to by \var{*respondent} is internally allocated by the
\var{libsres} library and must be freed by the invoker using
\func{free\_name\_server()}.  An entire list of name servers can be freed using
\func{free\_name\_servers()}.  A copy of the name server can be created using
\func{clone\_ns()} and a copy of a name server list can be made using
\func{clone\_ns\_list()}.

\func{print\_response()} provides a convenient way to display answers returned
in \var{response} by the name server.

The \struct{name\_server} structure is defined in \path{resolver.h} as follows:

\begin{verbatim}
    struct name_server
    {
        u_int8_t ns_name_n[NS_MAXCDNAME];
        void *ns_tsig;
        u_int32_t ns_security_options;
        u_int32_t ns_status;
        u_long  ns_options;
        int ns_retry;
        int ns_retrans;
        struct name_server *ns_next;
        int ns_number_of_addresses;
        struct sockaddr_storage **ns_address;
    }
;\end{verbatim}

\begin{description}

\item {\it ns\_name\_n}\verb" "

The name of the zone for which this name server is authoritative.  

\item {\it ns\_tsig}\verb" "

The {\it tsig} key that should be used to protect messages sent to this name
server.  This field is currently unused and must be set to NULL.

\item {\it ns\_security\_options}\verb" "

The security options for the zone.  This field is currently unused and must be
set to \const{ZONE\_USE\_NOTHING}.

\item {\it ns\_status}\verb" "

The status of the zone.  This field indicates how the zone information was
obtained.  The invoker must set this value to \const{SR\_ZI\_STATUS\_UNSET}.
Zone information obtained through referrals have a value of
\const{SR\_ZI\_STATUS\_LEARNED} for this field.

\item {\it ns\_options}\verb" "

Specifies additional resolver flags.  Currently defined flags are
\const{RES\_RECURSE}, which sets the "Recursion Desired" flag;
\const{RES\_USE\_DNSSEC}, which sets the "DNSSEC OK" bit in the EDNS0 header;
and \const{RES\_DEBUG}, which enables debugging.

\item {\it ns\_retry}\verb" "

Specifies the maximum number of attempts that must be made to obtain a name
from an unresponsive name server before giving up.

\item {\it ns\_retrans}\verb" "

Specifies the retransmission interval in seconds for queries sent to
unresponsive name servers.

\item {\it ns\_next}\verb" "

The address of the next name server in the list.

\item {\it ns\_number\_of\_addresses}\verb" "

The number of elements in the array \var{ns\_addresses}.  This field is
currently unused.

\item {\it ns\_addresses}\verb" "

The IP address of the name server.  

\end{description}

{\bf OTHER SYMBOLS EXPORTED}

The \lib{libsres} library also exports the following BIND functions,
documentation for which can be found in the BIND sources and documentation
manuals:

\begin{verbatim}
    res_nametoclass
    res_nametotype
    ns_name_ntop
    ns_name_pton
    ns_name_unpack
    ns_parse_ttl
    p_class
    p_section
    p_type
\end{verbatim}

The \func{p\_type()} function exported from \lib{libsres} has been augmented
such that it recognizes the various DNSSEC type codes such DNSKEY, RRSIG,
NSEC, NSEC3 and DLV.

{\bf RETURN VALUES}

\begin{description}

\item \const{SR\_UNSET}\verb" "

No error.

\item \const{SR\_CALL\_ERROR}\verb" "

An invalid parameter was passed to \func{get()}, \func{query\_send()}, or
\func{response\_recv()}.

\item \const{SR\_INTERNAL\_ERROR}\verb" "

The resolver encountered some internal error.

\item \const{SR\_TSIG\_ERROR}\verb" "

The resolver encountered some TSIG-related error.  This is currently
not implemented.

\item \const{SR\_NO\_ANSWER}\verb" "

No answers were received from any name server.

\item \const{SR\_NO\_ANSWER\_YET}\verb" "

No answer currently available; the query is still active.

\item \const{SR\_HEADER\_ERROR}\verb" "

The length and count of records in the header were incorrect.

\item \const{SR\_NXDOMAIN}\verb" "

The queried name did not exist.

\item \const{SR\_FORMERR}\verb" "

The name server was not able to parse the query message.

\item \const{SR\_SERVFAIL}\verb" "

The name server was not reachable.

\item \const{SR\_NOTIMPL}\verb" "

A particular functionality is not yet implemented.

\item \const{SR\_REFUSED}\verb" "

The name server refused to answer this query.

\item \const{SR\_DNS\_GENERIC\_FAILURE}\verb" "

Other failure returned by the name server and reflected in the
returned message \const{RCODE}.

\item \const{SR\_EDNS\_VERSION\_ERROR}\verb" "

The EDNS version was not recognized.

\item \const{SR\_NAME\_EXPANSION\_FAILURE}\verb" "

A failure was encountered while trying to expand a compressed domain name.

\end{description}

{\bf CURRENT STATUS}

There is currently no support for IPv6.

There is limited support for specifying resolver policy; members of the
\struct{name\_server} structure are still subject to change.

{\bf SEE ALSO}

libval(3)

