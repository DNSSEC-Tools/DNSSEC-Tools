<HTML><HEAD><TITLE>Manpage of LIBSRES</TITLE>
</HEAD><BODY>
<H1>LIBSRES</H1>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

<I>query_send()</I>, <I>response_rcv()</I>, <I>get()</I> - 
send queries and receive responses from a DNS name server.
<P>

<I>clone_ns()</I>, <I>clone_ns_list()</I>, <I>free_name_server()</I>,
<I>free_name_servers()</I> - manage name server lists
<P>

<I>print_response()</I> - display answers returned from the name server
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>


<PRE>
  #include &lt;<A HREF="file:/usr/include/resolver.h">resolver.h</A>&gt;

</PRE>


<P>



<PRE>
  int query_send(const char    *name,
            const u_int16_t     type,
            const u_int16_t     class,
            struct name_server  *nslist,
            int                 edns0_size,
            int                 *trans_id);

</PRE>


<P>



<PRE>
  int response_recv(int         *trans_id,
            struct name_server  **respondent,
            u_int8_t            **response,
            u_int32_t           *response_length);

</PRE>


<P>



<PRE>
  int get(const char          *name_n,
          const u_int16_t     type_h,
          const u_int16_t     class_h,
          struct name_server  *nslist,
          int                 edns0_size,
          struct name_server  **respondent,
          u_int8_t            **response,
          u_int32_t           *response_length);

</PRE>


<P>



<PRE>
  int clone_ns(struct name_server **cloned_ns, struct name_server *ns);

</PRE>


<P>



<PRE>
  int clone_ns_list(struct name_server **ns_list,
                    struct name_server *orig_ns_list);

</PRE>


<P>



<PRE>
  void free_name_server(struct name_server **ns);

</PRE>


<P>



<PRE>
  void free_name_servers(struct name_server **ns);

</PRE>


<P>



<PRE>
  void print_response(u_int8_t *response, int response_length);

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAD"></A>
The <I>query_send()</I> function sends a query to the name servers specified in
<I>nslist</I>.  The query is comprised of the &lt;<I>name, class, type</I>&gt; tuple and
<I>trans_id</I> provides a handle to this transaction within the <I>libsres</I> library. 
The buffer size advertised in the <FONT SIZE="-1">EDNS0</FONT> option can be set using the <I>ends0_size</I>
argument.
<P>

The <I>response_recv()</I> function returns the answers, if available, from the
name server that responds for the query identified by <I>trans_id</I>.
The response is available in <I>response</I> and the responding name server is
returned in <I>respondent</I>.  The length of the response in bytes is returned
in <I>response_length</I>.
<P>

The <I>get()</I> function provides a wrapper around the <I>query_send()</I> and
<I>response_recv()</I> functions.  After sending a request, it blocks until
a response is received from some name server or until the request times out.
The <I>libsres</I> library does not automatically follow referrals; responses
containing referrals are treated as valid responses.
<P>

The memory pointed to by <I>*respondent</I> is internally allocated by the
<I>libsres</I> library and must be freed by the invoker using
<I>free_name_server()</I>.  An entire list of name servers can be freed using
<I>free_name_servers()</I>.  A copy of the name server can be created using
<I>clone_ns()</I> and a copy of a name server list can be made using
<I>clone_ns_list()</I>.
<P>

<I>print_response()</I> provides a convenient way to display answers returned
in <I>response</I> by the name server.
<P>

The <I>name_server</I> structure is defined in <B>resolver.h</B> as follows:
<P>



<PRE>
    struct name_server
    {
        u_int8_t ns_name_n[NS_MAXCDNAME];
        void *ns_tsig;
        u_int32_t ns_security_options;
        u_int32_t ns_status;
        u_long  ns_options;
        int ns_retry;
        int ns_retrans;
        struct name_server *ns_next;
        int ns_number_of_addresses;
        struct sockaddr_storage **ns_address;
    };

</PRE>


<DL COMPACT>
<DT><I>ns_name_n</I><DD>
<A NAME="ixAAE"></A>
The name of the zone for which this name server is authoritative.  
<DT><I>ns_tsig</I><DD>
<A NAME="ixAAF"></A>
The <I>tsig</I> key that should be used to protect messages sent to this name
server.  This field is currently unused and must be set to <FONT SIZE="-1">NULL</FONT>.
<DT><I>ns_security_options</I><DD>
<A NAME="ixAAG"></A>
The security options for the zone.  This field is currently unused and must be
set to <B></B><FONT SIZE="-1"><B>ZONE_USE_NOTHING</B></FONT><B></B>.
<DT><I>ns_status</I><DD>
<A NAME="ixAAH"></A>
The status of the zone.  This field indicates how the zone information was
obtained.  The invoker must set this value to <B></B><FONT SIZE="-1"><B>SR_ZI_STATUS_UNSET</B></FONT><B></B>. Zone
information obtained through referrals have a value of
<B></B><FONT SIZE="-1"><B>SR_ZI_STATUS_LEARNED</B></FONT><B></B> for this field.
<DT><I>ns_options</I><DD>
<A NAME="ixAAI"></A>
Specifies additional resolver flags.  Currently defined flags are
<B></B><FONT SIZE="-1"><B>RES_RECURSE</B></FONT><B></B>, which sets the ``Recursion Desired'' flag; <B></B><FONT SIZE="-1"><B>RES_USE_DNSSEC</B></FONT><B></B>,
which sets the ``<FONT SIZE="-1">DNSSEC</FONT> <FONT SIZE="-1">OK</FONT>'' bit in the <FONT SIZE="-1">EDNS0</FONT> header; and <B></B><FONT SIZE="-1"><B>RES_DEBUG</B></FONT><B></B>, which
enables debugging.
<DT><I>ns_retry</I><DD>
<A NAME="ixAAJ"></A>
Specifies the maximum number of attempts that must be made to obtain a name
from an unresponsive name server before giving up.
<DT><I>ns_retrans</I><DD>
<A NAME="ixAAK"></A>
Specifies the retransmission interval in seconds for queries sent to
unresponsive name servers.
<DT><I>ns_next</I><DD>
<A NAME="ixAAL"></A>
The address of the next name server in the list.
<DT><I>ns_number_of_addresses</I><DD>
<A NAME="ixAAM"></A>
The number of elements in the array <I>ns_addresses</I>.  This field is
currently unused.
<DT><I>ns_addresses</I><DD>
<A NAME="ixAAN"></A>
The <FONT SIZE="-1">IP</FONT> address of the name server.  
</DL>
<A NAME="lbAE">&nbsp;</A>
<H2>OTHER SYMBOLS EXPORTED</H2>

<A NAME="ixAAO"></A>
The <I>libsres</I> library also exports the following <FONT SIZE="-1">BIND</FONT> functions,
documentation for which can be found in the <FONT SIZE="-1">BIND</FONT> sources and documentation
manuals:
<P>



<PRE>
  res_nametoclass
  res_nametotype
  ns_name_ntop
  ns_name_pton
  ns_name_unpack
  ns_parse_ttl
  p_class
  p_section
  p_type

</PRE>


<P>

The <I>p_type()</I> function exported from <I>libsres</I> has been augmented such that 
it recognizes the various <FONT SIZE="-1">DNSSEC</FONT> type codes such <FONT SIZE="-1">DNSKEY</FONT>, <FONT SIZE="-1">RRSIG</FONT>, <FONT SIZE="-1">NSEC</FONT>, 
<FONT SIZE="-1">NSEC3</FONT> and <FONT SIZE="-1">DLV</FONT>.
<A NAME="lbAF">&nbsp;</A>
<H2>RETURN VALUES</H2>

<A NAME="ixAAP"></A>
<DL COMPACT>
<DT><B></B><FONT SIZE="-1"><B>SR_UNSET</B></FONT><B></B><DD>
<A NAME="ixAAQ"></A>
No error.
<DT><B></B><FONT SIZE="-1"><B>SR_CALL_ERROR</B></FONT><B></B><DD>
<A NAME="ixAAR"></A>
An invalid parameter was passed to <I>get()</I>, <I>query_send()</I>, or
<I>response_recv()</I>.
<DT><B></B><FONT SIZE="-1"><B>SR_INTERNAL_ERROR</B></FONT><B></B><DD>
<A NAME="ixAAS"></A>
The resolver encountered some internal error.
<DT><B></B><FONT SIZE="-1"><B>SR_TSIG_ERROR</B></FONT><B></B><DD>
<A NAME="ixAAT"></A>
The resolver encountered some TSIG-related error.  This is currently
not implemented.
<DT><B></B><FONT SIZE="-1"><B>SR_NO_ANSWER</B></FONT><B></B><DD>
<A NAME="ixAAU"></A>
No answers were received from any name server.
<DT><B></B><FONT SIZE="-1"><B>SR_NO_ANSWER_YET</B></FONT><B></B><DD>
<A NAME="ixAAV"></A>
No answer currently available; the query is still active.
<DT><B></B><FONT SIZE="-1"><B>SR_HEADER_ERROR</B></FONT><B></B><DD>
<A NAME="ixAAW"></A>
The length and count of records in the header were incorrect.
<DT><B></B><FONT SIZE="-1"><B>SR_NXDOMAIN</B></FONT><B></B><DD>
<A NAME="ixAAX"></A>
The queried name did not exist.
<DT><B></B><FONT SIZE="-1"><B>SR_FORMERR</B></FONT><B></B><DD>
<A NAME="ixAAY"></A>
The name server was not able to parse the query message.
<DT><B></B><FONT SIZE="-1"><B>SR_SERVFAIL</B></FONT><B></B><DD>
<A NAME="ixAAZ"></A>
The name server was not reachable.
<DT><B></B><FONT SIZE="-1"><B>SR_NOTIMPL</B></FONT><B></B><DD>
<A NAME="ixABA"></A>
A particular functionality is not yet implemented.
<DT><B></B><FONT SIZE="-1"><B>SR_REFUSED</B></FONT><B></B><DD>
<A NAME="ixABB"></A>
The name server refused to answer this query.
<DT><B></B><FONT SIZE="-1"><B>SR_DNS_GENERIC_FAILURE</B></FONT><B></B><DD>
<A NAME="ixABC"></A>
Other failure returned by the name server and reflected in the
returned message <B></B><FONT SIZE="-1"><B>RCODE</B></FONT><B></B>.
<DT><B></B><FONT SIZE="-1"><B>SR_EDNS_VERSION_ERROR</B></FONT><B></B><DD>
<A NAME="ixABD"></A>
The <FONT SIZE="-1">EDNS</FONT> version was not recognized
<DT><B></B><FONT SIZE="-1"><B>SR_NAME_EXPANSION_FAILURE</B></FONT><B></B><DD>
<A NAME="ixABE"></A>
A failure was encountered while trying to expand a compressed domain name.
</DL>
<A NAME="lbAG">&nbsp;</A>
<H2>CURRENT STATUS</H2>

<A NAME="ixABF"></A>
There is currently no support for IPv6.
<P>

There is limited support for specifying resolver policy; members of the
<I>struct name_server</I> are still subject to change.
<A NAME="lbAH">&nbsp;</A>
<H2>COPYRIGHT</H2>

<A NAME="ixABG"></A>
Copyright 2004-2007 <FONT SIZE="-1">SPARTA</FONT>, Inc.  All rights reserved.
See the <FONT SIZE="-1">COPYING</FONT> file included with the dnssec-tools package for details.
<A NAME="lbAI">&nbsp;</A>
<H2>SEE ALSO</H2>

<A NAME="ixABH"></A>

<A HREF="http://dnssec-tools.sourceforge.net">http://dnssec-tools.sourceforge.net</A>
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">OTHER SYMBOLS EXPORTED</A><DD>
<DT><A HREF="#lbAF">RETURN VALUES</A><DD>
<DT><A HREF="#lbAG">CURRENT STATUS</A><DD>
<DT><A HREF="#lbAH">COPYRIGHT</A><DD>
<DT><A HREF="#lbAI">SEE ALSO</A><DD>
</DL>
<HR>
</BODY>
</HTML>
