Index: devtools/Site/site.config.m4
===================================================================
--- devtools/Site/site.config.m4	2005-04-25 11:33:21.000000000 -0400
+++ devtools/Site/site.config.m4	2006-02-09 10:59:44.000000000 -0500
@@ -0,0 +1,3 @@
+APPENDDEF(`confENVDEF', `-DSUPPORT_DNSSEC=1')
+define(`confLibSEARCH', `db 44bsd')
+APPENDDEF(`confLIBS', `-lsres -lval -lcrypto')
Index: libmilter/sm_gethost.c
===================================================================
--- libmilter/sm_gethost.c	2005-04-28 13:32:29.000000000 -0400
+++ libmilter/sm_gethost.c	2006-02-09 11:06:02.000000000 -0500
@@ -17,6 +17,43 @@
 #endif /* NETINET || NETINET6 */
 #include "libmilter.h"
 
+#if SUPPORT_DNSSEC
+# include <validator.h>
+#endif /* SUPPORT_DNSSEC */
+
+/*
+**  MI_VAL_GETHOSTBYNAME -- wrapper for gethostbyname with support for
+**                          DNSSEC validation
+**
+**      Parameters:
+**              name -- a host name, or an IPv4 address in standard dot
+**                      notation, or an IPv6 address in colon (and possibly
+**                      dot) notation.
+**
+**      Returns:
+**              NULL, if there was an error
+**              A non-NULL value of type struct hostent*, if no error occurs
+**
+*/
+
+static struct hostent *
+mi_val_gethostbyname(name)
+        char *name;
+{
+	struct hostent *h;
+#if SUPPORT_DNSSEC
+	int dnssec_status = INTERNAL_ERROR;
+	h = val_gethostbyname(NULL, name, &dnssec_status);
+	if (RequireDNSSEC && (dnssec_status != VALIDATE_SUCCESS)) {
+		h = NULL;
+	}
+#else /* SUPPORT_DNSSEC */
+	h = gethostbyname(name);
+#endif /* SUPPORT_DNSSEC */
+
+	return h;
+}
+
 /*
 **  MI_GETHOSTBY{NAME,ADDR} -- compatibility routines for gethostbyXXX
 **
@@ -59,13 +96,15 @@
 		_res.options |= RES_USE_INET6;
 	}
 	SM_SET_H_ERRNO(0);
-	h = gethostbyname(name);
+	h = mi_val_gethostbyname(name);
 	if (family == AF_INET6 && !resv6)
 		_res.options &= ~RES_USE_INET6;
 	*err = h_errno;
 	return h;
 }
+#endif /* NEEDSGETIPNODE && NETINET6 */
 
+#if (NETINET6 && NEEDSGETIPNODE) || SUPPORT_DNSSEC
 void
 freehostent(h)
 	struct hostent *h;
@@ -77,7 +116,7 @@
 
 	return;
 }
-#endif /* NEEDSGETIPNODE && NETINET6 */
+#endif /* (NEEDSGETIPNODE && NETINET6) || SUPPORT_DNSSEC */
 
 struct hostent *
 mi_gethostbyname(name, family)
@@ -110,7 +149,7 @@
 	h = getipnodebyname(name, family, flags, &err);
 	SM_SET_H_ERRNO(err);
 # else /* NETINET6 */
-	h = gethostbyname(name);
+	h = mi_val_gethostbyname(name);
 # endif /* NETINET6 */
 
 #endif /* (SOLARIS > 10000 && SOLARIS < 20400) || (defined(SOLARIS) && SOLARIS < 204) || (defined(sony_news) && defined(__svr4)) */
Index: doc/op/op.me
===================================================================
--- doc/op/op.me	2005-03-03 12:11:58.000000000 -0500
+++ doc/op/op.me	2005-03-03 12:27:45.000000000 -0500
@@ -3487,6 +3487,11 @@
 (a temporary failure)
 on T_AAAA (IPv6) lookups
 during hostname canonification.
+Use
+.q RequireDNSSEC
+to require DNSSEC validation of responses to DNS queries in
+sendmail.  If this option is set, a failure in DNSSEC validation
+is treated as a failure in the name lookup.
 Notice: it might be necessary to apply the same (or similar) options to
 .i submit.cf
 too.
Index: sendmail/conf.c
===================================================================
--- sendmail/conf.c	2005-04-25 11:32:20.000000000 -0400
+++ sendmail/conf.c	2006-02-09 11:02:20.000000000 -0500
@@ -4169,6 +4169,45 @@
 }
 
 #endif /* NEEDSTRSTR */
+
+#if SUPPORT_DNSSEC
+# include <validator.h>
+#endif
+
+/*
+**  SM_VAL_GETHOSTBYNAME -- wrapper for gethostbyname with support for
+**                          DNSSEC validation
+**
+**      Parameters:
+**              name -- a host name, or an IPv4 address in standard dot
+**                      notation, or an IPv6 address in colon (and possibly
+**                      dot) notation.
+**
+**      Returns:
+**              NULL, if there was an error
+**              A non-NULL value of type struct hostent*, if no error occurs
+**
+*/
+
+static struct hostent *
+sm_val_gethostbyname(name)
+        char *name;
+{
+	struct hostent *h;
+
+#if SUPPORT_DNSSEC
+	int dnssec_status = INTERNAL_ERROR;
+	h = val_gethostbyname(NULL, name, &dnssec_status);
+	if (RequireDNSSEC && (dnssec_status != VALIDATE_SUCCESS)) {
+		h = NULL;
+	}
+#else /* SUPPORT_DNSSEC */
+	h = gethostbyname(name);
+#endif /* SUPPORT_DNSSEC */
+
+	return h;
+}
+
 /*
 **  SM_GETHOSTBY{NAME,ADDR} -- compatibility routines for gethostbyXXX
 **
@@ -4212,7 +4251,7 @@
 		_res.options |= RES_USE_INET6;
 	}
 	SM_SET_H_ERRNO(0);
-	h = gethostbyname(name);
+	h = sm_val_gethostbyname(name);
 	if (!resv6)
 		_res.options &= ~RES_USE_INET6;
 	*err = h_errno;
@@ -4233,7 +4272,9 @@
 	*err = h_errno;
 	return h;
 }
+#endif /* NETINET6 && NEEDSGETIPNODE */
 
+#if (NETINET6 && NEEDSGETIPNODE) || SUPPORT_DNSSEC
 void
 freehostent(h)
 	struct hostent *h;
@@ -4245,7 +4286,7 @@
 
 	return;
 }
-#endif /* NETINET6 && NEEDSGETIPNODE */
+#endif /* (NETINET6 && NEEDSGETIPNODE) || SUPPORT_DNSSEC*/
 
 struct hostent *
 sm_gethostbyname(name, family)
@@ -4292,7 +4333,7 @@
 	h = getipnodebyname(name, family, flags, &err);
 	SM_SET_H_ERRNO(err);
 # else /* NETINET6 */
-	h = gethostbyname(name);
+	h = sm_val_gethostbyname(name);
 # endif /* NETINET6 */
 
 	save_errno = errno;
@@ -4332,7 +4373,7 @@
 				SM_SET_H_ERRNO(err);
 				save_errno = errno;
 # else /* NETINET6 */
-				h = gethostbyname(hbuf);
+				h = sm_val_gethostbyname(hbuf);
 				save_errno = errno;
 # endif /* NETINET6 */
 			}
@@ -4638,7 +4679,7 @@
 					*ha);
 		}
 	}
-#if NETINET6
+#if NETINET6 || SUPPORT_DNSSEC
 	freehostent(hp);
 #endif /* NETINET6 */
 	return 0;
Index: sendmail/readcf.c
===================================================================
--- sendmail/readcf.c	2005-02-25 10:54:42.000000000 -0500
+++ sendmail/readcf.c	2005-08-19 11:37:03.000000000 -0400
@@ -2578,6 +2578,13 @@
 				WorkAroundBrokenAAAA = !clearmode;
 				continue;
 			}
+# if SUPPORT_DNSSEC
+			if (sm_strcasecmp(q, "RequireDNSSEC") == 0)
+			{
+				RequireDNSSEC = !clearmode;
+				continue;
+			}
+# endif /* SUPPORT_DNSSEC */
 			for (rfp = ResolverFlags; rfp->rf_name != NULL; rfp++)
 			{
 				if (sm_strcasecmp(q, rfp->rf_name) == 0)
@@ -2591,8 +2598,13 @@
 				_res.options |= rfp->rf_bits;
 		}
 		if (tTd(8, 2))
+# if SUPPORT_DNSSEC
+			sm_dprintf("_res.options = %x, RequireDNSSEC = %d, HasWildcardMX = %d\n",
+				   (unsigned int) _res.options, RequireDNSSEC, HasWildcardMX);
+# else /* SUPPORT_DNSSEC */
 			sm_dprintf("_res.options = %x, HasWildcardMX = %d\n",
 				   (unsigned int) _res.options, HasWildcardMX);
+# endif /* SUPPORT_DNSSEC */
 #else /* NAMED_BIND */
 		usrerr("name server (I option) specified but BIND not compiled in");
 #endif /* NAMED_BIND */
Index: sendmail/domain.c
===================================================================
--- sendmail/domain.c	2005-06-03 15:09:51.000000000 -0400
+++ sendmail/domain.c	2006-02-09 11:02:53.000000000 -0500
@@ -23,6 +23,9 @@
 
 # include <arpa/inet.h>
 
+# if SUPPORT_DNSSEC
+#  include <validator.h>
+# endif /* SUPPORT_DNSSEC */
 
 /*
 **  The standard udp packet size PACKETSZ (512) is not sufficient for some
@@ -268,8 +271,53 @@
 		resfunc = res_search;
 
 	errno = 0;
+
+# if SUPPORT_DNSSEC
+	/* perform DNSSEC Validation of the answer */
+	do
+	{
+		char dname[MAXDNAME];
+		int dnssec_status = INTERNAL_ERROR;
+		struct val_response resp[1];
+		int resp_length = 1;
+	    
+		bzero(dname, MAXDNAME);
+		strncpy(dname, host, MAXDNAME);
+		getcanonname(dname, MAXDNAME, true, NULL);
+		resp[0].response = (unsigned char *) &answer;
+		resp[0].response_length = sizeof answer;
+
+		if (tTd(8, 2))
+			sm_dprintf("getmxrr(24): performing dnssec validation query.\n");
+		
+		n = val_query (NULL, dname, C_IN, T_MX, VAL_QUERY_MERGE_RRSETS, resp, &resp_length);
+
+		if (n == 0) {
+			dnssec_status = resp[0].val_status;
+			n = resp[0].response_length;
+		
+			if (RequireDNSSEC) {
+				if (dnssec_status == VALIDATE_SUCCESS) {
+					if (tTd(8, 2))
+						sm_dprintf("getmxrr: DNSSEC validation of MX record of %s succeeded.\n", dname);
+				}
+				else {
+					if (tTd(8, 1))
+						sm_dprintf("getmxrr: DNSSEC validation of MX record of %s failed.\n", dname);
+					syserr("Error: DNSSEC validation of MX record of %s failed.\n", dname);
+					*rcode = EX_NOHOST;
+					return -1;
+				}
+			}
+		}
+		else {
+			n = -(abs(n));
+		}
+	} while (0);
+# else /* SUPPORT_DNSSEC */
 	n = (*resfunc)(host, C_IN, T_MX, (unsigned char *) &answer,
 		       sizeof(answer));
+# endif /* SUPPORT_DNSSEC */
 	if (n < 0)
 	{
 		if (tTd(8, 1))
@@ -517,10 +565,10 @@
 				       host, MyHostName);
 				return -1;
 			}
-# if NETINET6
+# if NETINET6 || SUPPORT_DNSSEC
 			freehostent(h);
 			hp = NULL;
-# endif /* NETINET6 */
+# endif /* NETINET6 || SUPPORT_DNSSEC */
 		}
 		if (strlen(host) >= sizeof MXHostBuf)
 		{
@@ -895,8 +943,62 @@
 				qtype == T_MX ? "MX" :
 				"???");
 		errno = 0;
+# if SUPPORT_DNSSEC
+		do
+		{
+			char dname[MAXDNAME];
+			int dnssec_status = INTERNAL_ERROR;
+			struct val_response resp[1];
+			int resp_length = 1;
+			
+			bzero(dname, MAXDNAME);
+			memcpy(dname, host, strlen(host));
+			memcpy(dname + strlen(host), ".", 1);
+			memcpy(dname + strlen(host) + 1, *dp, strlen(*dp));
+
+			if (tTd(8, 5))
+				sm_dprintf("dns_getcanonname(938): performing dnssec validation query.\n");
+			
+			resp[0].response = (unsigned char *) &answer;
+			resp[0].response_length = sizeof answer;
+			ret = val_query (NULL, dname, C_IN, qtype, VAL_QUERY_MERGE_RRSETS, resp, &resp_length);
+
+			if (ret == 0) {
+				dnssec_status = resp[0].val_status;
+				ret = resp[0].response_length;
+
+				if (RequireDNSSEC) {
+					if (dnssec_status == VALIDATE_SUCCESS) {
+						if (tTd(8, 2))
+							sm_dprintf("DNSSEC validation of %s succeeded.\n",
+								   dname);
+					}
+					else {
+						if (tTd(8, 7))
+							sm_dprintf("\tNO: errno=%d, h_errno=%d\n",
+								   errno, h_errno);
+						
+						if (tTd(8, 5))
+							sm_dprintf("DNSSEC validation of %s (%s) failed.\n",
+								   dname,
+#  if NETINET6
+								   qtype == T_AAAA ? "AAAA" :
+#  endif /* NETINET6 */
+								   qtype == T_A ? "A" :
+								   qtype == T_MX ? "MX" :
+								   "???");
+						goto nexttype;
+					}
+				}
+			}
+			else {
+				ret = -(abs(ret));
+			}
+		} while (0);
+# else /* SUPPORT_DNSSEC */
 		ret = res_querydomain(host, *dp, C_IN, qtype,
 				      answer.qb2, sizeof(answer.qb2));
+# endif /* SUPPORT_DNSSEC */
 		if (ret <= 0)
 		{
 			int save_errno = errno;
Index: sendmail/sm_resolve.c
===================================================================
--- sendmail/sm_resolve.c	2005-02-25 10:55:24.000000000 -0500
+++ sendmail/sm_resolve.c	2006-02-09 11:03:26.000000000 -0500
@@ -70,6 +70,10 @@
 	{	NULL,		0		}
 };
 
+#  if SUPPORT_DNSSEC
+#   include <validator.h>
+#  endif /* SUPPORT_DNSSEC */
+
 static DNS_REPLY_T *parse_dns_reply __P((unsigned char *, int));
 
 /*
@@ -409,7 +413,53 @@
 	}
 	errno = 0;
 	SM_SET_H_ERRNO(0);
+
+#  if SUPPORT_DNSSEC
+	if (tTd(8, 16))
+	    sm_dprintf("dns_lookup_int(%s, %d, %s): ",
+		       domain, rr_class, dns_type_to_string(rr_type));
+	do
+	{
+		char dname[MAXDNAME];
+		struct val_response resp[1];
+		int resp_length = 1;
+		int dnssec_status = INTERNAL_ERROR;
+		resp[0].response = reply;
+		resp[0].response_length = sizeof reply;
+		
+		bzero(dname, MAXDNAME);
+		strncpy(dname, domain, MAXDNAME);
+		getcanonname(dname, MAXDNAME, true, NULL);
+		
+		if (tTd(8, 16))
+			sm_dprintf("dns_lookup_int(): performing dnssec validation query.\n");
+		
+		len = val_query(NULL, dname, rr_class, rr_type, VAL_QUERY_MERGE_RRSETS, resp, &resp_length);
+		
+		if (len == 0) {
+			dnssec_status = resp[0].val_status;
+			len = resp[0].response_length;
+			
+			if (RequireDNSSEC) {
+				if (dnssec_status == VALIDATE_SUCCESS) {
+					if (tTd(8, 2))
+						sm_dprintf("\t\tdnssec validation of %s succeeded.\n", domain);
+				}
+				else {
+					if (tTd(8, 1))
+						sm_dprintf("\t\tdnssec validation of %s failed.\n", domain);
+					return NULL;
+				}
+			}
+		}
+		else {
+			len = -(abs(len));
+		}
+	} while (0);
+#  else /* SUPPORT_DNSSEC */
 	len = res_search(domain, rr_class, rr_type, reply, sizeof reply);
+#  endif /* SUPPORT_DNSSEC */
+
 	if (tTd(8, 16))
 	{
 		_res.options = old_options;
Index: sendmail/sendmail.h
===================================================================
--- sendmail/sendmail.h	2005-08-19 11:12:07.000000000 -0400
+++ sendmail/sendmail.h	2005-08-19 11:36:51.000000000 -0400
@@ -2146,6 +2146,9 @@
 #endif /* !defined(_USE_SUN_NSSWITCH_) && !defined(_USE_DEC_SVC_CONF_) */
 EXTERN bool	volatile DataProgress;	/* have we sent anything since last check */
 EXTERN bool	DisConnected;	/* running with OutChannel redirect to transcript file */
+#if SUPPORT_DNSSEC
+EXTERN bool     RequireDNSSEC;  /* perform DNSSEC validation of DNS queries */
+#endif /* SUPPORT_DNSSEC */
 EXTERN bool	DontExpandCnames;	/* do not $[...$] expand CNAMEs */
 EXTERN bool	DontInitGroups;	/* avoid initgroups() because of NIS cost */
 EXTERN bool	DontLockReadFiles;	/* don't read lock support files */
@@ -2472,9 +2475,9 @@
 extern void	finis __P((bool, bool, volatile int));
 extern void	fixcrlf __P((char *, bool));
 extern long	freediskspace __P((char *, long *));
-#if NETINET6 && NEEDSGETIPNODE
+#if (NETINET6 && NEEDSGETIPNODE) || SUPPORT_DNSSEC
 extern void	freehostent __P((struct hostent *));
-#endif /* NETINET6 && NEEDSGETIPNODE */
+#endif /* (NETINET6 && NEEDSGETIPNODE) || SUPPORT_DNSSEC */
 extern char	*get_column __P((char *, int, int, char *, int));
 extern char	*getauthinfo __P((int, bool *));
 extern int	getdtsize __P((void));
