Index: src/libspf2/spf_interpret.c
===================================================================
--- src/libspf2/spf_interpret.c	2005-03-02 13:13:09.000000000 -0500
+++ src/libspf2/spf_interpret.c	2005-06-05 12:44:07.000000000 -0400
@@ -254,6 +254,14 @@
 	
 	char			*p, *p_end;
 
+#ifdef SUPPORT_DNSSEC
+	int 		 firstdnssecerr;
+	int 		 i;
+	int 		 num_errs;
+	SPF_error_t 	*err;
+	SPF_errcode_t 	 errcode;
+	const char 	*errmsg = "";
+#endif
 	SPF_ASSERT_NOTNULL(spf_response);
 	spf_request = spf_response->spf_request;
 	SPF_ASSERT_NOTNULL(spf_request);
@@ -328,6 +336,58 @@
 		}
 	#endif
 
+#ifdef SUPPORT_DNSSEC
+		/* add in the DNSSEC validation status */
+		firstdnssecerr = 1;
+		num_errs = SPF_response_warnings( spf_response );
+		for ( i = 0; i < num_errs; i++ )
+		{
+		    err = SPF_response_message( spf_response, i );
+		    if ( err )
+		    {
+			errcode = SPF_error_code ( err );
+			if ( errcode == SPF_E_DNSSEC_FAILURE )
+			{
+			    errmsg = SPF_error_message( err );
+			    if ( errmsg == NULL ) errmsg = "";
+
+			    if ( firstdnssecerr )
+			    {
+				p += snprintf( p, p_end - p,
+					       " x-dnssec=\"fail (%s",
+					       errmsg );
+				firstdnssecerr = 0;
+			    }
+			    else
+			    {
+				p += snprintf( p, p_end - p, ", %s", errmsg );
+			    }
+			}
+			if ( p_end - p <= 0 ) break;
+		    }
+		}
+
+		if ( p_end - p <= 0 ) break;
+
+		if ( firstdnssecerr )
+		{
+		    if ( ( spf_server->dodnssec ) &&
+			 ( spf_response->result != SPF_RESULT_NONE ) )
+		    {
+			p += snprintf( p, p_end - p, " x-dnssec=\"pass\";" );
+		    }
+		    else
+		    {
+			p += snprintf( p, p_end - p, " x-dnssec=\"none\";" );
+		    }
+		}
+		else
+		{
+		    p += snprintf( p, p_end - p, ")\";" );
+		}
+
+		if ( p_end - p <= 0 ) break;
+#endif
 		/* FIXME  should the explanation string be included in the header? */
 
 		/* FIXME  should the header be reformated to include line breaks? */
@@ -747,6 +807,15 @@
 				return DONE_TEMPERR(SPF_E_DNS_ERROR); /* REASON_MECH */
 			}
 
+#ifdef SUPPORT_DNSSEC
+			if ( rr_a->herrno == DNSSEC_FAILURE )
+			{
+			        SPF_response_add_warn( spf_response,
+						       SPF_E_DNSSEC_FAILURE,
+						       "DNSSEC validation failed for the A record of '%s'.",
+						       lookup );	    
+			}
+#endif
 			for (i = 0; i < rr_a->num_rr; i++) {
 				if ( rr_a->rr_type != fetch_ns_type )
 					continue;
@@ -787,6 +856,14 @@
 				return DONE_TEMPERR(SPF_E_DNS_ERROR);
 			}
 
+#ifdef SUPPORT_DNSSEC
+			if ( rr_mx->herrno == DNSSEC_FAILURE ) {
+			        SPF_response_add_warn( spf_response,
+						       SPF_E_DNSSEC_FAILURE,
+						       "DNSSEC validation failed for the MX record of '%s'.",
+						       lookup );	    
+			}
+#endif
 			max_mx = rr_mx->num_rr;
 			if ( max_mx > spf_server->max_dns_mx )
 				max_mx = spf_server->max_dns_mx;
@@ -815,6 +892,20 @@
 					return DONE_TEMPERR( SPF_E_DNS_ERROR );
 				}
 
+#ifdef SUPPORT_DNSSEC
+				if ( rr_a->herrno == DNSSEC_FAILURE ) {
+					if ( spf_request->client_ver == AF_INET ) {
+						SPF_response_add_warn( spf_response, SPF_E_DNSSEC_FAILURE,
+								       "DNSSEC validation failed for the A record of '%s'.",
+								       rr_mx->rr[j]->mx );
+					}
+					else {
+						SPF_response_add_warn( spf_response, SPF_E_DNSSEC_FAILURE,
+								       "DNSSEC validation failed for the AAAA record of '%s'.",
+								       rr_mx->rr[j]->mx );
+					}
+				}
+#endif
 				for( i = 0; i < rr_a->num_rr; i++ ) {
 					if ( rr_a->rr_type != fetch_ns_type )
 						continue;
@@ -890,6 +981,13 @@
 						return DONE_TEMPERR( SPF_E_DNS_ERROR );
 					}
 
+#ifdef SUPPORT_DNSSEC
+					if( rr_a->herrno == DNSSEC_FAILURE ) {
+					        SPF_response_add_warn( spf_response, SPF_E_DNSSEC_FAILURE,
+								       "DNSSEC validation failed for the A record of '%s'.",
+								       rr_ptr->rr[i]->ptr );
+					}
+#endif
 					for( j = 0; j < rr_a->num_rr; j++ ) {
 						if ( spf_server->debug ) {
 							INET_NTOP( AF_INET, &rr_a->rr[j]->a.s_addr,
@@ -951,6 +1049,13 @@
 						return DONE_TEMPERR( SPF_E_DNS_ERROR );
 					}
 
+#ifdef SUPPORT_DNSSEC
+					if( rr_aaaa->herrno == DNSSEC_FAILURE ) {
+					        SPF_response_add_warn( spf_response, SPF_E_DNSSEC_FAILURE,
+								       "DNSSEC validation failed for the AAAA record of '%s'.",
+								       rr_ptr->rr[i]->ptr );
+					}
+#endif
 					for( j = 0; j < rr_aaaa->num_rr; j++ ) {
 						if ( spf_server->debug ) {
 							INET_NTOP(AF_INET6, &rr_aaaa->rr[j]->aaaa.s6_addr,
@@ -1069,6 +1174,32 @@
 				spf_response = save_spf_response;
 				save_spf_response = NULL;
 
+#ifdef SUPPORT_DNSSEC
+				/* Copy any DNSSEC validation warnings from
+				 * spf_response_subr to spf_response
+				 */
+				do {
+				    int num_errs;
+				    int i;
+				    SPF_error_t *err;
+				    SPF_errcode_t errcode;
+				    char *errmsg;
+
+				    num_errs = SPF_response_warnings( spf_response_subr );
+				    for ( i = 0; i < num_errs; i++ ) {
+					err = SPF_response_message( spf_response_subr, i );
+					if ( err ) {
+					    errcode = SPF_error_code( err );
+					    if ( errcode == SPF_E_DNSSEC_FAILURE ) {
+						errmsg = ( char * ) SPF_error_message( err );
+					        SPF_response_add_warn( spf_response,
+								       SPF_E_DNSSEC_FAILURE,
+								       errmsg );
+					    }
+					}
+				    }
+				} while (0);
+#endif
 				/* Rewrite according to prefix of include */
 				switch (SPF_response_result(spf_response_subr)) {
 					case SPF_RESULT_PASS:
@@ -1152,6 +1283,13 @@
 				SPF_FREE_LOOKUP_DATA();
 				return DONE_TEMPERR(SPF_E_DNS_ERROR);
 			}
+#ifdef SUPPORT_DNSSEC
+			if( rr_a->herrno == DNSSEC_FAILURE ) {
+			        SPF_response_add_warn( spf_response, SPF_E_DNSSEC_FAILURE,
+						       "DNSSEC validation failed for the A record of '%s'.",
+						       lookup );
+			}
+#endif
 			if ( rr_a->num_rr > 0 ) {
 				SPF_FREE_LOOKUP_DATA();
 				return DONE_MECH(mech->prefix_type);
Index: src/libspf2/spf_server.c
===================================================================
--- src/libspf2/spf_server.c	2005-03-01 16:05:02.000000000 -0500
+++ src/libspf2/spf_server.c	2005-06-05 12:34:58.000000000 -0400
@@ -88,19 +88,30 @@
 	sp->max_dns_ptr = SPF_MAX_DNS_PTR;
 	sp->max_dns_mx = SPF_MAX_DNS_MX;
 	sp->debug = debug;
+#ifdef SUPPORT_DNSSEC
+	sp->dodnssec = 0;
+#endif
 
 	SPF_server_set_rec_dom_ghbn(sp);
 
 	switch (dnstype) {
 		case SPF_DNS_RESOLV:
+#ifdef SUPPORT_DNSSEC
+			dc_r = SPF_dns_resolv_new(NULL, NULL, debug, 0);
+#else
 			dc_r = SPF_dns_resolv_new(NULL, NULL, debug);
+#endif
 			if (dc_r == 0)
 				SPF_error("Failed to create DNS resolver");
 			sp->resolver = dc_r;
 			break;
 
 		case SPF_DNS_CACHE:
+#ifdef SUPPORT_DNSSEC
+			dc_r = SPF_dns_resolv_new(NULL, NULL, debug, 0);
+#else
 			dc_r = SPF_dns_resolv_new(NULL, NULL, debug);
+#endif
 			if (dc_r == 0)
 				SPF_error("Failed to create DNS resolver");
 			dc_c = SPF_dns_cache_new(dc_r, NULL, debug, 8);
@@ -109,6 +120,26 @@
 			sp->resolver = dc_c;
 			break;
 
+#ifdef SUPPORT_DNSSEC			
+	        case SPF_DNS_DNSSEC_RESOLV:
+			dc_r = SPF_dns_resolv_new(NULL, NULL, debug, 1);
+			if (dc_r == 0)
+				SPF_error("Failed to create DNS resolver");
+			sp->resolver = dc_r;
+			sp->dodnssec = 1;
+			break;
+
+	        case SPF_DNS_DNSSEC_CACHE:
+			dc_r = SPF_dns_resolv_new(NULL, NULL, debug, 1);
+			if (dc_r == 0)
+				SPF_error("Failed to create DNS resolver");
+			dc_c = SPF_dns_cache_new(dc_r, NULL, debug, 8);
+			if (dc_c == 0)
+				SPF_error("Failed to create DNS cache");
+			sp->resolver = dc_c;
+			sp->dodnssec = 1;
+			break;
+#endif
 		default:
 			SPF_errorf("Unknown DNS type %d", dnstype);
 	}
@@ -279,8 +310,7 @@
 			SPF_dns_rr_free(rr_txt);
 			spf_response->result = SPF_RESULT_NONE;
 			spf_response->reason = SPF_REASON_FAILURE;
-			return SPF_response_add_error(spf_response, 
-SPF_E_NOT_SPF,
+			return SPF_response_add_error(spf_response, SPF_E_NOT_SPF,
 					"Host '%s' not found.", domain);
 			break;
 
@@ -301,6 +331,13 @@
 		case NETDB_SUCCESS:
 			break;
 
+#ifdef SUPPORT_DNSSEC
+		case DNSSEC_FAILURE:
+			SPF_response_add_warn(spf_response, SPF_E_DNSSEC_FAILURE,
+					      "DNSSEC validation failed for the SPF (TXT) record of '%s'.",
+					      domain);
+			break;
+#endif
 		default:
 			SPF_dns_rr_free(rr_txt);
 			return SPF_response_add_error(spf_response, SPF_E_DNS_ERROR,
Index: src/libspf2/spf_strerror.c
===================================================================
--- src/libspf2/spf_strerror.c	2005-03-02 13:13:31.000000000 -0500
+++ src/libspf2/spf_strerror.c	2005-06-05 12:30:29.000000000 -0400
@@ -162,6 +162,11 @@
 	return "include: or redirect= caused unlimited recursion";
 	break;
 
+#ifdef SUPPORT_DNSSEC
+    case SPF_E_DNSSEC_FAILURE:
+	return "DNSSEC Validation of SPF record failed";
+	break;
+#endif
     default:
 	return "Unknown SPF error code";
 	break;
Index: src/libspf2/spf_dns_resolv.c
===================================================================
--- src/libspf2/spf_dns_resolv.c	2005-06-03 12:46:00.000000000 -0400
+++ src/libspf2/spf_dns_resolv.c	2005-08-23 13:15:37.000000000 -0400
@@ -45,6 +45,10 @@
 # include <pthread.h>
 #endif
 
+#ifdef SUPPORT_DNSSEC
+#include <validator.h>
+#endif
+
 #include "spf.h"
 #include "spf_dns.h"
 #include "spf_internal.h"
@@ -52,6 +56,13 @@
 #include "spf_dns_resolv.h"
 
 
+#ifdef SUPPORT_DNSSEC
+typedef struct
+{
+    int dodnssec;
+} SPF_dns_resolv_config_t;
+#endif
+
 #if 0
 typedef struct
 {
@@ -88,7 +99,7 @@
 }
 
 
-#if 0
+#ifdef SUPPORT_DNSSEC
 static inline SPF_dns_resolv_config_t *SPF_voidp2spfhook(void *hook)
 	{ return (SPF_dns_resolv_config_t *)hook; }
 static inline void *SPF_spfhook2voidp(SPF_dns_resolv_config_t *spfhook)
@@ -100,7 +111,7 @@
 SPF_dns_resolv_lookup(SPF_dns_server_t *spf_dns_server,
 				const char *domain, ns_type rr_type, int should_cache)
 {
-#if 0
+#ifdef SUPPORT_DNSSEC
     SPF_dns_resolv_config_t	*spfhook;
 #endif
     SPF_dns_rr_t			*spfrr;
@@ -133,9 +144,12 @@
 	void				*res_spec;
 	struct __res_state	*res_state;
 
+#ifdef SUPPORT_DNSSEC
+        int dnssec_status = INTERNAL_ERROR;
+#endif
 	SPF_ASSERT_NOTNULL(spf_dns_server);
 
-#if 0
+#ifdef SUPPORT_DNSSEC
 	spfhook = SPF_voidp2spfhook(spf_dns_server->hook);
 	SPF_ASSERT_NOTNULL(spfhook);
 #endif
@@ -156,6 +170,19 @@
     /*
      * try resolving the name
      */
+#ifdef SUPPORT_DNSSEC
+	SPF_debugf("libval present.  Checking if dodnssec flag is set");
+	if ( spfhook->dodnssec ) {
+		SPF_debugf( "dodnssec flag is set.  Performing val_query" );
+		dns_len = val_query( domain, ns_c_in, rr_type, response, sizeof( response ),
+				     0, &dnssec_status );
+		SPF_debugf( "val_query() returned %d, dnssec_status = %s\n", dns_len,
+			    p_val_error( dnssec_status ) );
+	}
+	else {
+		SPF_debugf( "dodnssec flag is not set" );
+#endif
+
 #if HAVE_DECL_RES_NINIT
 	dns_len = res_nquery(res_state, domain, ns_c_in, rr_type,
 			 response, sizeof(response));
@@ -164,6 +191,10 @@
 			 response, sizeof(response));
 #endif
 
+#ifdef SUPPORT_DNSSEC
+        }
+#endif
+
 	if ( dns_len < 0 ) {
 		/* This block returns unconditionally. */
 		if ( spf_dns_server->debug )
@@ -175,6 +206,16 @@
 			return SPF_dns_lookup(spf_dns_server->layer_below,
 							domain, rr_type, should_cache);
 		}
+#ifdef SUPPORT_DNSSEC
+		if ( spfhook->dodnssec && ( dnssec_status != VALIDATE_SUCCESS ) ) {
+			if ( h_errno == NETDB_SUCCESS ) {
+				h_errno = DNSSEC_FAILURE;
+			}
+			return SPF_dns_rr_new_init( spf_dns_server,
+						    domain, rr_type, 0, h_errno );
+		}
+		else
+#endif
 		return SPF_dns_rr_new_init(spf_dns_server,
 						domain, rr_type, 0, SPF_h_errno);
 	}
@@ -182,6 +223,16 @@
     /*
      * initialize stuff
      */
+#ifdef SUPPORT_DNSSEC
+	if ( spfhook->dodnssec && ( dnssec_status != VALIDATE_SUCCESS ) ) {
+		if ( h_errno == NETDB_SUCCESS ) {
+			h_errno = DNSSEC_FAILURE;
+		}
+		spfrr = SPF_dns_rr_new_init( spf_dns_server,
+					     domain, rr_type, 0, h_errno );
+	}
+	else
+#endif
 	spfrr = SPF_dns_rr_new_init(spf_dns_server,
 					domain, rr_type, 0, NETDB_SUCCESS);
 
@@ -447,6 +498,14 @@
     if ( spfrr->num_rr == 0 )
 		spfrr->herrno = NO_DATA;
 
+#ifdef SUPPORT_DNSSEC
+    if ( spfhook->dodnssec && ( dnssec_status != VALIDATE_SUCCESS ) ) {
+	    if ( spfrr->herrno == NETDB_SUCCESS ) {
+		    spfrr->herrno = DNSSEC_FAILURE;
+	    }
+    }
+#endif
+
     return spfrr;
 }
 
@@ -454,12 +513,18 @@
 static void
 SPF_dns_resolv_free(SPF_dns_server_t *spf_dns_server)
 {
-#if 0
+#ifdef SUPPORT_DNSSEC
 	SPF_dns_resolv_config_t	*spfhook;
 #endif
 
 	SPF_ASSERT_NOTNULL(spf_dns_server);
 
+#ifdef SUPPORT_DNSSEC
+    if ( spf_dns_server->hook ) {
+		spfhook = SPF_voidp2spfhook( spf_dns_server->hook );
+		free( spf_dns_server->hook );
+    }
+#endif
 #if 0
     if (spf_dns_server->hook) {
 		spfhook = SPF_voidp2spfhook(spf_dns_server->hook);
@@ -477,12 +542,18 @@
 	free(spf_dns_server);
 }
 
+#ifdef SUPPORT_DNSSEC
+SPF_dns_server_t *
+SPF_dns_resolv_new(SPF_dns_server_t *layer_below,
+				const char *name, int debug, int dodnssec)
+#else
 SPF_dns_server_t *
 SPF_dns_resolv_new(SPF_dns_server_t *layer_below,
 				const char *name, int debug)
+#endif
 {
 	SPF_dns_server_t		*spf_dns_server;
-#if 0
+#ifdef SUPPORT_DNSSEC
 	SPF_dns_resolv_config_t	*spfhook;
 #endif
 
@@ -493,7 +564,7 @@
 		return NULL;
 	memset(spf_dns_server, 0, sizeof(SPF_dns_server_t));
 
-#if 0
+#ifdef SUPPORT_DNSSEC
     spf_dns_server->hook = calloc(1, sizeof(SPF_dns_resolv_config_t));
     if ( spf_dns_server->hook == NULL ) {
 		free( spf_dns_server );
@@ -513,9 +584,12 @@
     spf_dns_server->name        = name;
     spf_dns_server->debug       = debug;
 
-#if 0
+#ifdef SUPPORT_DNSSEC
     spfhook = SPF_voidp2spfhook( spf_dns_server->hook );
 #endif
+#ifdef SUPPORT_DNSSEC
+    spfhook->dodnssec = dodnssec;
+#endif
 
 #if HAVE_DECL_RES_NINIT
 #if 0
Index: src/libspf2/spf_get_exp.c
===================================================================
--- src/libspf2/spf_get_exp.c	2005-03-02 13:12:45.000000000 -0500
+++ src/libspf2/spf_get_exp.c	2005-06-03 12:48:24.000000000 -0400
@@ -164,6 +164,13 @@
 		RETURN_DEFAULT_EXP();
 		break;
 
+#ifdef SUPPORT_DNSSEC
+	case DNSSEC_FAILURE:
+	        SPF_response_add_warn(spf_response, SPF_E_DNSSEC_FAILURE,
+				      "DNSSEC validation failed for the SPF (TXT) record of '%s'.",
+				      *bufp);
+		break;
+#endif
 	case NETDB_SUCCESS:
 		break;
 
Index: src/libspf2/Makefile.am
===================================================================
--- src/libspf2/Makefile.am	2005-02-28 18:33:12.000000000 -0500
+++ src/libspf2/Makefile.am	2005-04-18 15:38:32.000000000 -0400
@@ -32,7 +32,6 @@
 	spf_record.c \
 	spf_request.c \
 	spf_response.c \
-	spf_result.c \
 	spf_server.c \
 	spf_strerror.c \
 	spf_utils.c \
Index: src/include/spf_dns.h
===================================================================
--- src/include/spf_dns.h	2005-02-28 18:35:21.000000000 -0500
+++ src/include/spf_dns.h	2005-06-03 12:15:59.000000000 -0400
@@ -98,6 +98,15 @@
 #define	NO_RECOVERY	3		/* invalid/unimplmeneted query	*/
 #define	NO_DATA		4		/* host found, but no RR of req type*/
 #endif
+
+#ifdef SUPPORT_DNSSEC
+/*
+ * Additional Error code for DNSSEC validation
+ */
+#define DNSSEC_FAILURE  5               /* DNSSEC validation failed. */
+#include <netinet/in.h>
+#endif
+
 typedef int SPF_dns_stat_t;
 
 typedef struct SPF_dns_server_struct SPF_dns_server_t;
Index: src/include/spf_response.h
===================================================================
--- src/include/spf_response.h	2005-03-01 15:50:58.000000000 -0500
+++ src/include/spf_response.h	2005-06-03 12:28:28.000000000 -0400
@@ -149,6 +149,10 @@
 								mechanism will be ignored */
 ,	SPF_E_INCLUDE_RETURNED_NONE	/* If an include recursive query returns none it's a perm error */
 ,	SPF_E_RECURSIVE			/* Recursive include */
+
+#ifdef SUPPORT_DNSSEC
+,	SPF_E_DNSSEC_FAILURE		/* DNSSEC validation failure */
+#endif
 } SPF_errcode_t;
 
 typedef
Index: src/include/spf_server.h
===================================================================
--- src/include/spf_server.h	2005-06-03 12:31:29.000000000 -0400
+++ src/include/spf_server.h	2005-06-03 12:32:54.000000000 -0400
@@ -20,7 +20,6 @@
 
 #include "spf_record.h"
 #include "spf_dns.h"
-#include "spf_dns_internal.h"
 
 #ifndef SPF_MAX_DNS_MECH
 /* It is a bad idea to change this for two reasons.
@@ -66,11 +65,20 @@
 
 	int				 sanitize;		/* limit charset in messages */
 	int				 debug;			/* print debug info */
+
+#ifdef SUPPORT_DNSSEC
+        int                              dodnssec;      /* perform DNSSEC validation */
+#endif
 };
 
 typedef
 enum SPF_server_dnstype_enum {
 	SPF_DNS_RESOLV, SPF_DNS_CACHE
+
+#ifdef SUPPORT_DNSSEC
+	,SPF_DNS_DNSSEC_RESOLV
+	,SPF_DNS_DNSSEC_CACHE
+#endif
 } SPF_server_dnstype_t;
 
 SPF_server_t	*SPF_server_new(SPF_server_dnstype_t dnstype,int debug);
Index: src/include/spf_dns_resolv.h
===================================================================
--- src/include/spf_dns_resolv.h	2005-06-03 12:23:53.000000000 -0400
+++ src/include/spf_dns_resolv.h	2005-06-03 12:23:56.000000000 -0400
@@ -40,7 +40,12 @@
  * libresolv will be displayed.  This information is often not passed
  * on to (and not needed by) the higher level DNS layers.
  */
+#ifdef SUPPORT_DNSSEC
+SPF_dns_server_t	*SPF_dns_resolv_new(SPF_dns_server_t *layer_below,
+				const char *name, int debug, int dodnssec);
+#else
 SPF_dns_server_t	*SPF_dns_resolv_new(SPF_dns_server_t *layer_below,
 				const char *name, int debug);
+#endif
 
 #endif
Index: config.h.in
===================================================================
--- config.h.in	2005-02-28 15:16:25.000000000 -0500
+++ config.h.in	2005-08-23 13:14:47.000000000 -0400
@@ -46,6 +46,9 @@
 /* Define to 1 if you have the <inttypes.h> header file. */
 #undef HAVE_INTTYPES_H
 
+/* Define to 1 if you have the `crypto' library (-lcrypto). */
+#undef HAVE_LIBCRYPTO
+
 /* Define to 1 if you have the `intl' library (-lintl). */
 #undef HAVE_LIBINTL
 
@@ -61,6 +64,12 @@
 /* Define to 1 if you have the `socket' library (-lsocket). */
 #undef HAVE_LIBSOCKET
 
+/* Define to 1 if you have the `sres' library (-lsres). */
+#undef HAVE_LIBSRES
+
+/* Define to 1 if you have the `val' library (-lval). */
+#undef HAVE_LIBVAL
+
 /* Define to 1 if you have the <limits.h> header file. */
 #undef HAVE_LIMITS_H
 
@@ -213,6 +222,9 @@
 /* Define to 1 if the system has the type `u_int8_t'. */
 #undef HAVE_U_INT8_T
 
+/* Define to 1 if you have the <validator.h> header file. */
+#undef HAVE_VALIDATOR_H
+
 /* Define to 1 if you have the `vfork' function. */
 #undef HAVE_VFORK
 
@@ -276,6 +288,9 @@
 /* Define to 1 if you have the ANSI C header files. */
 #undef STDC_HEADERS
 
+/* Support DNSSEC validation */
+#undef SUPPORT_DNSSEC
+
 /* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
 #undef TIME_WITH_SYS_TIME
 
Index: configure.ac
===================================================================
--- configure.ac	2005-02-28 15:11:51.000000000 -0500
+++ configure.ac	2005-08-23 13:14:30.000000000 -0400
@@ -92,35 +92,97 @@
 	exit 1;
 ])
 
-dnl Moved to after header checks by Shevek
-AC_ARG_WITH(bind,
-        [  --with-bind=DIR  Find BIND resolver in DIR],
-        [AC_CHECK_FILE([$withval/include/bind/resolv.h],
-                [CFLAGS="$CFLAGS -I$withval/include/bind"],
-                [CFLAGS="$CFLAGS -I$withval/include"])
-         LDFLAGS="$LDFLAGS -L$withval/lib -Wl,$rpath$withval/lib"
-         AC_CHECK_LIB([bind], [res_query], [LIBS="$LIBS -lbind"],
-                [AC_CHECK_LIB([resolv],
-                        [res_query],
-                        [LIBS="$LIBS -lresolv"],
-                        [echo "cannot find resolver library"; exit 1;])
-                ])
-        ],
-		[dnl Have to include resolv.h as res_query is sometimes defined as a macro
-				AC_MSG_CHECKING([for res_query in -lresolv (with resolv.h if present)])
-				saved_libs="$LIBS"
-				LIBS="-lresolv $LIBS"
-				AC_TRY_LINK([
-						#ifdef HAVE_RESOLV_H
-						#include <resolv.h>
-						#endif],
-						[res_query(0,0,0,0,0)],
-						[AC_MSG_RESULT(yes)
-								have_res_query=yes],
-						[AC_MSG_RESULT(no)
-								LIBS="$saved_libs"])
-        ])
-		
+AC_MSG_CHECKING(whether we need to support DNSSEC validation)
+AC_ARG_ENABLE(dnssec-support,
+[  --enable-dnssec-support Support DNSSEC validation.],
+    support_dnssec=yes)
+
+if test "x$support_dnssec" = "xyes"; then
+
+   AC_MSG_RESULT(yes)
+
+   dnl Check DNSSEC Validator library header
+   AC_CHECK_HEADERS([validator.h])
+
+   dnl Check the openssl crypto library
+   AC_CHECK_LIB(crypto, RSA_verify, , [
+	echo "the openssl crypto library is required to build this program."
+	exit 1;
+   ])
+
+   dnl Check libsres
+   AC_ARG_WITH(libsres,
+	[  --with-libsres=PATH     Look for the libsres library in PATH],
+	if test "x$withval" != "xyes"; then
+	  if test "x$withval" != x -a -d $withval; then
+	      LDFLAGS="-L$withval $LDFLAGS"
+	      AC_MSG_CHECKING(libsres)
+	      AC_MSG_RESULT("$withval")
+	  fi
+	fi
+   )
+
+   dnl Check Secure Resolver Library libsres
+   AC_CHECK_LIB(sres, query_send, , [
+	echo "the secure resolver library is required to build this program."
+	echo "see http://dnssec-tools.sourceforge.net"
+	exit 1;
+   ])
+
+   dnl Check libval
+   AC_ARG_WITH(libval,
+	[  --with-libval=PATH      Look for the libval library in PATH],
+	if test "x$withval" != "xyes"; then
+	  if test "x$withval" != x -a -d $withval; then
+	      LDFLAGS="-L$withval $LDFLAGS"
+	      AC_MSG_CHECKING(libval)
+	      AC_MSG_RESULT("$withval")
+	  fi
+	fi
+   )
+
+   dnl Check DNSSEC Validator library
+   AC_CHECK_LIB(val, val_query, , [
+	echo "the validator library is required to build this program."
+        echo "see http://dnssec-tools.sourceforge.net"
+	exit 1;
+   ])
+
+   AC_DEFINE([SUPPORT_DNSSEC], [], [Support DNSSEC validation])
+
+else
+   AC_MSG_RESULT(no)
+
+   dnl Moved to after header checks by Shevek
+   AC_ARG_WITH(bind,
+         [  --with-bind=DIR         Find BIND resolver in DIR],
+         [AC_CHECK_FILE([$withval/include/bind/resolv.h],
+                 [CFLAGS="$CFLAGS -I$withval/include/bind"],
+                 [CFLAGS="$CFLAGS -I$withval/include"])
+          LDFLAGS="$LDFLAGS -L$withval/lib -Wl,$rpath$withval/lib"
+          AC_CHECK_LIB([bind], [res_query], [LIBS="$LIBS -lbind"],
+                 [AC_CHECK_LIB([resolv],
+                         [res_query],
+                         [LIBS="$LIBS -lresolv"],
+                         [echo "cannot find resolver library"; exit 1;])
+                 ])
+         ],
+ 		[dnl Have to include resolv.h as res_query is sometimes defined as a macro
+ 				AC_MSG_CHECKING([for res_query in -lresolv (with resolv.h if present)])
+ 				saved_libs="$LIBS"
+ 				LIBS="-lresolv $LIBS"
+ 				AC_TRY_LINK([
+ 						#ifdef HAVE_RESOLV_H
+ 						#include <resolv.h>
+ 						#endif],
+ 						[res_query(0,0,0,0,0)],
+ 						[AC_MSG_RESULT(yes)
+ 								have_res_query=yes],
+ 						[AC_MSG_RESULT(no)
+ 								LIBS="$saved_libs"])
+         ])
+ 		
+fi		
 		
 		
 dnl [AC_CHECK_LIB(resolv, res_query)])
