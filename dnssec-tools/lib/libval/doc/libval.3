.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "libval 3"
.TH libval 3 "2005-08-31" "perl v5.8.3" "Programmer's Manual"
.SH "NAME"
resolve_n_check, free_query_chain, free_assertion_chain, 
free_result_chain \- query and validate answers from a DNS name server
.PP
get_context, destroy_context, switch_effective_policy \- manage validator context
.PP
p_val_error \- display error information
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
#include <validator.h>
.PP
int resolve_n_check( val_context_t          *context,
                     u_char                 *domain_name_n,
                     const u_int16_t        type,
                     const u_int16_t        class,
                     const u_int8_t         flags,
                     struct query_chain     **queries,
                     struct assertion_chain **assertions,
                     struct val_result      **results);
.PP
void free_query_chain(struct query_chain **queries);
.PP
void free_assertion_chain(struct assertion_chain **assertions);
.PP
void free_result_chain(struct val_result **results);
.PP
int get_context(const char *label, val_context_t **newcontext);
.PP
int switch_effective_policy(val_context_t *ctx, const char *label);
.PP
void destroy_context(val_context_t *context);
.PP
char *p_val_error(int valerrno);
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fB\f(BIresolve_n_check()\fB\fR method can be used to query a set of name
servers for the <\fIdomain_name_n\fR, \fItype\fR, \fIclass\fR> tuple and 
to verify and validate the response. Verification is the step of 
checking the RRSIGs and validation includes performing 
verification up the chain of trust all the way to a trust 
anchor. The \fIdomain_name_n\fR parameter is the queried name in 
\&\s-1DNS\s0 wire format. The conversion from host format to \s-1DNS\s0 wire format 
can be done using the  \fB\f(BIns_name_pton()\fB\fR function exported by 
the \fB\f(BIlibsres\fB\|(3)\fR library.
.PP
Answers returned by \fB\f(BIresolve_n_check()\fB\fR are made available 
in the *\fIresults\fR array.  Each answer is a 
distinct RRset; multiple RRs within the RRset are
treated as the same answer. Multiple answers are possible when
\&\fItype\fR is \f(CW\*(C`ns_t_any\*(C'\fR or when a proof of non-existence is 
returned in which case RRsets of type \f(CW\*(C`ns_t_nsec\*(C'\fR and 
\&\f(CW\*(C`ns_t_soa\*(C'\fR are also returned. 
.PP
Individual elements in *\fIresults\fR point to corresponding 
elements in the **\fIassertions\fR linked list. The assertions contain
the actual RRsets returned by the name server in response to the
query. The **\fIqueries\fR linked-list provides a handle to
the query that returned the data present within an assertion.
.PP
The three dimensions of results, assertions and queries allow the
invoking application to select the level of detail it needs to 
investigate the \s-1DNSSEC\s0 validation status of a particular response. 
Most applications would only require *\fIresults\fR since this provides a 
single error code for representing the authenticity of returned 
data. Other more intrusive applications such as a \s-1DNSSEC\s0 
troubleshooting utility may look at the individual assertions 
to identify what particular component in the chain-of-trust led 
to validation failure if any.
.PP
*\fIqueries\fR, *\fIassertions\fR and *\fIresults\fR must be initially set
to \s-1NULL\s0.  The libval library internally allocates memory for these 
parameters  so they must be freed by the invoking application 
using the \fB\f(BIfree_query_chain()\fB\fR, \fB\f(BIfree_assertion_chain()\fB\fR 
and \fB\f(BIfree_result_chain()\fB\fR interfaces respectively. 
.PP
The first parameter to \fB\f(BIresolve_n_check()\fB\fR is the validator context. 
Applications can create a new validator context using the
\&\fB\f(BIget_context()\fB\fR method. This method parses the resolver and validator 
configuration files and creates the handle \fInewcontext\fR to this parsed 
information. Information stored as part of validator context includes 
the validation policy and resolver policy. Validator policy is 
applied hierarchically based on the name used to identify a particular 
policy fragment. 
.PP
As an example, \f(CW\*(C`browser\*(C'\fR and \f(CW\*(C`mozilla.browser\*(C'\fR form a 
hierarchical ordering of policy, where the configuration 
under the identifier of \f(CW\*(C`mozilla.browser\*(C'\fR may be used to override 
generic browser policy with mozilla-specific options. Applications may
switch their default policy to a policy that lies below (\f(CW\*(C`mozilla:browser\*(C'\fR 
lies below \f(CW\*(C`browser\*(C'\fR) the originally defined label using the 
\&\fB\f(BIswitch_effective_policy()\fB\fR method. In both of the \fB\f(BIresolve_n_check()\fB\fR 
and \fB\f(BIswitch_effective_policy()\fB\fR, the \fIlabel\fR parameter is a simple string that
must match another string that appears as the policy definition
identifier in the validator configuration file. It is a simple text string
with the \f(CW\*(C`:\*(C'\fR character used as the delimiter between two levels in the
hierarchy. The \f(CW\*(C`:\*(C'\fR label by itself refers to the default policy in the 
configuration file. \f(CW\*(C`NULL\*(C'\fR may also be used to represent the label for
the default policy.
.SH "DATA STRUCTURES"
.IX Header "DATA STRUCTURES"
.IP "\fIstruct val_result\fR {" 4
.IX Item "struct val_result {"
.Vb 4
\&    struct assertion_chain *as;
\&    int status;
\&    int trusted;
\&    struct val_result *next;
.Ve
.Sp
};
.RS 4
.IP "\fIas\fR" 4
.IX Item "as"
The assertion pointed to by the result. 
.IP "\fItrusted\fR" 4
.IX Item "trusted"
If set, this indicates that the chain-of-trust for this answer led up
to trust anchor. This field is used internally and must not be used
by applications. It may go away in the future.
.IP "\fInext\fR" 4
.IX Item "next"
Used internally and must not be used by applications. 
It will go away in the future.
.IP "\fIstatus\fR" 4
.IX Item "status"
Can be one of the following:
.Sp
.Vb 2
\&        BARE_RRSIG
\&                No DNSSEC validation possible, query was for an RRSIG.
.Ve
.Sp
.Vb 2
\&        VALIDATE_SUCCESS
\&                Answer received and validated successfully.
.Ve
.Sp
.Vb 2
\&        BOGUS_UNPROVABLE 
\&                Could not build a chain of trust for a failure condition.
.Ve
.Sp
.Vb 2
\&        BOGUS_PROVABLE
\&                Failure condition that was provable.
.Ve
.Sp
.Vb 3
\&        VALIDATION_ERROR
\&                Did not have sufficient or relevant data to complete validation, 
\&                or encountered some DNS error.
.Ve
.Sp
.Vb 2
\&        NONEXISTENT_NAME        
\&                No name present, trusted, and proof present.
.Ve
.Sp
.Vb 2
\&        NONEXISTENT_TYPE
\&                No type exists for name, trusted, and proof present.
.Ve
.Sp
.Vb 2
\&        INCOMPLETE_PROOF
\&                Proof does not have all required components to prove non-existence.
.Ve
.Sp
.Vb 2
\&        BOGUS_PROOF
\&                Proof of non-existence cannot be validated.
.Ve
.Sp
.Vb 2
\&        INDETERMINATE_DS
\&                Can't prove that the DS is trusted.
.Ve
.Sp
.Vb 4
\&        INDETERMINATE_PROOF
\&                Some intermediate Proof of non-existence obtained
\&                dont know if answer exists and proof is bogus
\&                or answer is bogus.
.Ve
.Sp
.Vb 2
\&        INDETERMINATE_ERROR
\&                Sequence of errors.
.Ve
.Sp
.Vb 2
\&        INDETERMINATE_TRUST
\&                Don't know if trust is absent or answer is bogus.
.Ve
.Sp
.Vb 2
\&        INDETERMINATE_ZONE
\&                Dont know if zone is unsigned or sigs have been stripped.
.Ve
.Sp
Error values in **\fIresults\fR returned by the validator can be displayed 
in a more user friendly format using the \fB\f(BIp_val_error()\fB\fR method.
.RE
.RS 4
.RE
.IP "\fIstruct assertion_chain\fR {" 4
.IX Item "struct assertion_chain {"
.Vb 7
\&    u_int16_t ac_state;
\&    struct rrset_rec *ac_data;
\&    struct query_chain *ac_pending_query;
\&    struct assertion_chain *ac_more_data;
\&    struct assertion_chain *ac_trust;
\&    struct assertion_chain *ac_next;
\&};
.Ve
.RS 4
.IP "\fIac_state\fR" 4
.IX Item "ac_state"
This contains the validation state of the assertion. Upon completion 
of the \fB\f(BIresolve_n_check()\fB\fR call this field will contain the error
or success code for \s-1DNSSEC\s0 validation over the current assertion. This
field may contain the following values:
.Sp
.Vb 2
\&        DNSKEY_NOMATCH
\&                RRSIG was created by a DNSKEY that does not exist in the apex keyset.
.Ve
.Sp
.Vb 3
\&        WRONG_LABEL_COUNT
\&                The number of labels on the signature is greater than the the count given in
\&                the RRSIG RDATA.
.Ve
.Sp
.Vb 2
\&        SECURITY_LAME
\&                RRSIG created by a key that does not exist in the parent DS record set.
.Ve
.Sp
.Vb 3
\&        NOT_A_ZONE_KEY
\&                The key used to verify the RRSIG is not a zone key, but some other key such as
\&                the public key used for TSIG.
.Ve
.Sp
.Vb 2
\&        RRSIG_NOTYETACTIVE
\&                The RRSIG's inception time is in the future.
.Ve
.Sp
.Vb 2
\&        RRSIG_EXPIRED
\&                The RRSIG has expired.
.Ve
.Sp
.Vb 2
\&        ALGO_NOT_SUPPORTED
\&                Algorithm in DNSKEY or RRSIG or DS is not supported.
.Ve
.Sp
.Vb 2
\&        UNKNOWN_ALGO
\&                Unknown DNSKEY or RRSIG or DS algorithm
.Ve
.Sp
.Vb 2
\&        RRSIG_VERIFIED
\&                The RRSIG verified successfully.
.Ve
.Sp
.Vb 2
\&        RRSIG_VERIFY_FAILED
\&                The RRSIG did not verify.
.Ve
.Sp
.Vb 2
\&        NOT_VERIFIED
\&                Different RRSIGs failed for different reasons
.Ve
.Sp
.Vb 2
\&        KEY_TOO_LARGE
\&                The zone is using a key size that is too large as per local policy.
.Ve
.Sp
.Vb 2
\&        KEY_TOO_SMALL
\&                The zone is using a key size that is too small as per local policy
.Ve
.Sp
.Vb 2
\&        KEY_NOT_AUTHORIZED
\&                The zone is using a key that is not authorized as per local policy.
.Ve
.Sp
.Vb 2
\&        ALGO_REFUSED
\&                Algorithm in DNSKEY or RRSIG or DS is not allowed as per local policy
.Ve
.Sp
.Vb 2
\&        CLOCK_SKEW
\&                Verified but with clock skew taken into accoun
.Ve
.Sp
.Vb 2
\&        DUPLICATE_KEYTAG
\&                Two DNSKEYs have the same keytag
.Ve
.Sp
.Vb 3
\&        NO_PREFERRED_SEP
\&                There is no DNSKEY in the parent DS set that our local policy allows us to
\&                traverse
.Ve
.Sp
.Vb 3
\&        WRONG_RRSIG_OWNER
\&                The RRSIG and the data that it purportedly covers have differing notions of
\&                owner name
.Ve
.Sp
.Vb 2
\&        RRSIG_ALGO_MISMATCH
\&                 The DNSKEY and RRSIG pair have a mismatch in their algorithm.
.Ve
.Sp
.Vb 2
\&        KEYTAG_MISMATCH
\&                 The DNSKEY and RRSIG pair have a mismatch in the key tags.
.Ve
.Sp
.Vb 2
\&        VERIFIED
\&                The signature verified OK.
.Ve
.Sp
.Vb 2
\&        LOCAL_ANSWER
\&                Answer was obtained locally. This is currently not implemented.
.Ve
.Sp
.Vb 2
\&        TRUST_KEY
\&                The key present in this assertion is trusted.
.Ve
.Sp
.Vb 2
\&        TRUST_ZONE
\&                The zone in this assertion is trusted.
.Ve
.Sp
.Vb 2
\&        BARE_RRSIG
\&                Query was for an RRSIG.
.Ve
.Sp
In cases where data is insufficient to generate a validation result, 
\&\fIac_state\fR may also contain the following status values. The final 
validation result in such circumstances is \s-1VALIDATION_ERROR\s0.
.Sp
.Vb 3
\&        DATA_MISSING
\&                No data was returned in the response. Based on what data was queried
\&                for this also covers cases where the DNSKEY or DS are missing.
.Ve
.Sp
.Vb 2
\&        RRSIG_MISSING
\&                Could not find an RRSIG that matched the query type.
.Ve
.Sp
.Vb 3
\&        NO_TRUST_ANCHOR
\&                No trust anchor at current level and no possiblity
\&                for finding any up this tree.
.Ve
.Sp
.Vb 2
\&        UNTRUSTED_ZONE
\&                The zone has been configured as un-trusted.
.Ve
.Sp
.Vb 3
\&        IRRELEVANT_PROOF
\&                An NSEC received does not contribute towards proving
\&                non-existence.
.Ve
.Sp
.Vb 2
\&        DNSSEC_VERSION_ERROR
\&                DNSSEC version error. Not implemented.
.Ve
.Sp
.Vb 3
\&        TOO_MANY_LINKS
\&                Too many links were traversed in going up the chain-of-trust. 
\&                Not implemented.
.Ve
.Sp
.Vb 2
\&        UNKNOWN_DNSKEY_PROTO
\&                The protocol field in the DNSKEY is not set to 3 (DNSSEC).
.Ve
.Sp
.Vb 3
\&        FLOOD_ATTACK_DETECTED
\&                Detected multiple (conflicting) answers for the same query. 
\&                Possible spoofing attack. Not implemented.
.Ve
.Sp
.Vb 2
\&        CONFLICTING_ANSWERS     
\&                Multiple answers received for a query which conflict.
.Ve
.Sp
.Vb 2
\&        SR_REFERRAL_ERROR
\&                Some error encountered while following referrals.
.Ve
.Sp
.Vb 2
\&        SR_MISSING_GLUE
\&                Glue was missing
.Ve
.Sp
.Vb 1
\&        All other resolver errors returned by libsres(3)
.Ve
.IP "\fIac_data\fR" 4
.IX Item "ac_data"
This field contains a pointer to an RRset obtained from the \s-1DNS\s0 response.
.IP "\fIac_pending_query\fR" 4
.IX Item "ac_pending_query"
This field contains a pointer to an element in the **\fIqueries\fR 
linked list. In order to validate a resource record, the
validator may have to send additional queries for data not returned 
as part of the original answer. Dependencies such as these are 
reflected in the \fIac_pending_query\fR field. 
.IP "\fIac_more_data\fR" 4
.IX Item "ac_more_data"
Certain queries may return more than one RRset as part of the answer.
This field points to the next RRset in the \s-1DNS\s0 response.
.IP "\fIac_trust\fR" 4
.IX Item "ac_trust"
This field points to an assertion that either contains a \s-1DNSKEY\s0 RRset that
can be used to verify RRSIGs over the current record, or contains a \s-1DS\s0
RRset that can be used to build the chain-of-trust towards a trust
anchor. 
.IP "\fIac_next\fR" 4
.IX Item "ac_next"
This field points to the next element in the **\fIassertions\fR linked\-list.
.RE
.RS 4
.RE
.IP "\fIstruct query_chain\fR {" 4
.IX Item "struct query_chain {"
.Vb 10
\&    u_char qc_name_n[MAXCDNAME];
\&    u_int16_t qc_type_h;
\&    u_int16_t qc_class_h;
\&    u_int16_t qc_state; /* DOS, TIMED_OUT, etc */
\&    struct name_server *qc_ns_list;
\&    struct delegation_info *qc_referral;
\&    int qc_trans_id;
\&    struct assertion_chain *qc_as;
\&    struct query_chain *qc_next;
\&};
.Ve
.RS 4
.IP "\fIqc_name_n\fR" 4
.IX Item "qc_name_n"
Contains the queried name in \s-1DNS\s0 wire format.
.IP "\fIqc_type_h\fR" 4
.IX Item "qc_type_h"
Contains the queried type.
.IP "\fIqc_class_h\fR" 4
.IX Item "qc_class_h"
Contains the queried class.
.IP "\fIqc_state\fR" 4
.IX Item "qc_state"
This field contains the current status of the query. Upon completion
of the \fB\f(BIresolve_n_check()\fB\fR call this field will either be Q_ANSWERED, 
which says that the query was answered, and the returned response in present in
he assertion pointed to by \fIqc_as\fR, or a value greater than Q_ERROR_BASE in which
case the error value is one of those returned by the resolver as defined in 
\&\fB\f(BIlibsres\fB\|(3)\fR offset by Q_ERROR_BASE. For example, if the resolver returned 
an error of \s-1SR_SERVFAIL\s0, this value would contain the value 
Q_ERROR_BASE+SR_SERVFAIL.
.IP "\fIqc_ns_list\fR" 4
.IX Item "qc_ns_list"
Contains the list of name servers towards which the query is directed.
Details on the \fIstruct name_server\fR structure may be found in the 
man page for \fB\f(BIlibsres\fB\|(3)\fR
.IP "\fIqc_referral\fR" 4
.IX Item "qc_referral"
Points to referral information. This field is used internally and may
go away in future. 
.IP "\fIqc_trans_id\fR" 4
.IX Item "qc_trans_id"
The identifier that the resolver uses to keep track of the query. Additional
information about the query transaction \s-1ID\s0 may be found in the man page 
for \fB\f(BIlibsres\fB\|(3)\fR.
.IP "\fIqc_as\fR" 4
.IX Item "qc_as"
This field points to an assertion that contains the response returned by 
the \s-1DNS\s0 name server for this query.
.IP "\fIqc_next\fR" 4
.IX Item "qc_next"
Points to the next element in the **\fIqueries\fR linked\-list.
.RE
.RS 4
.RE
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
.IP "\fB\f(BIresolve_n_check()\fB\fR can return one of the following values:" 4
.IX Item "resolve_n_check() can return one of the following values:"
.RS 4
.PD 0
.IP "\s-1NO_ERROR\s0" 4
.IX Item "NO_ERROR"
.PD
No error was encountered.
.IP "\s-1ERROR\s0" 4
.IX Item "ERROR"
Generic error encountered.
.IP "\s-1NOT_IMPLEMENTED\s0" 4
.IX Item "NOT_IMPLEMENTED"
Functionality not yet implemented. 
.IP "\s-1OUT_OF_MEMORY\s0" 4
.IX Item "OUT_OF_MEMORY"
Could not allocate memory.
.IP "\s-1BAD_ARGUMENT\s0" 4
.IX Item "BAD_ARGUMENT"
Bad arguments passed as parameters.
.IP "\s-1INTERNAL_ERROR\s0" 4
.IX Item "INTERNAL_ERROR"
Encountered some internal error.
.IP "\s-1NO_PERMISSION\s0" 4
.IX Item "NO_PERMISSION"
No permission to perform operation. Currently not implemented.
.IP "\s-1RESOURCE_UNAVAILABLE\s0" 4
.IX Item "RESOURCE_UNAVAILABLE"
Some resource (crypto possibly) was unavailable. Currently not implemented.
.IP "\s-1NO_SPACE\s0" 4
.IX Item "NO_SPACE"
Not enough space in *\fIresults\fR for storing all available answers.
.RE
.RS 4
.RE
.IP "\fB\f(BIget_context()\fB\fR can return one of the following values:" 4
.IX Item "get_context() can return one of the following values:"
.RS 4
.PD 0
.IP "\s-1NO_ERROR\s0" 4
.IX Item "NO_ERROR"
.PD
No error was encountered.
.IP "\s-1OUT_OF_MEMORY\s0" 4
.IX Item "OUT_OF_MEMORY"
Could not allocate memory.
.IP "\s-1CONF_PARSE_ERROR\s0" 4
.IX Item "CONF_PARSE_ERROR"
Error in parsing some configuration file.
.IP "\s-1NO_POLICY\s0" 4
.IX Item "NO_POLICY"
Could not find one or both of the configuration files 
/etc/resolv.conf and /etc/dnsval.conf.
.RE
.RS 4
.RE
.IP "\fB\f(BIswitch_effective_policy()\fB\fR can return one of the following values:" 4
.IX Item "switch_effective_policy() can return one of the following values:"
.RS 4
.PD 0
.IP "\s-1NO_ERROR\s0" 4
.IX Item "NO_ERROR"
.PD
No error was encountered.
.IP "\s-1OUT_OF_MEMORY\s0" 4
.IX Item "OUT_OF_MEMORY"
Could not allocate memory.
.IP "\s-1UNKNOWN_LOCALE\s0" 4
.IX Item "UNKNOWN_LOCALE"
Could not identify the policy to which we need to switch.
.RE
.RS 4
.RE
.SH "FILES"
.IX Header "FILES"
The validator library reads configuration information from two separate files,
/etc/resolv.conf and /etc/dnsval.conf.
.IP "/etc/resolv.conf" 4
.IX Item "/etc/resolv.conf"
Only the \*(L"nameserver\*(R" option is supported in the resolv.conf file. This option
is used to specify the \s-1IP\s0 address of the name server to which queries must be
sent by default. For example,
.Sp
nameserver 10.0.0.1
.IP "/etc/dnsval.conf" 4
.IX Item "/etc/dnsval.conf"
This file contains a sequence of the following \*(L"policy\-fragments\*(R":
.Sp
<label> <\s-1KEYWORD\s0> <additional\-data>; 
.Sp
label is the context to which this policy applies
and \s-1KEYWORD\s0 is the specific policy component that is 
being configured. The format of additional-data depends on the 
keyword specified.
.Sp
Policy fragments are indexed by the label and keyword. If multiple
policy fragments are defined for the same label and keyword combination
then the last definition in the file is used.  
.Sp
Currently two different keywords are specified:
.RS 4
.IP "trust-anchor" 4
.IX Item "trust-anchor"
Specifies the trust anchors for a sequence of zones. The additional
data portion for this keyword is a sequence of the zone name and a 
quoted string containing the \s-1RDATA\s0 portion for the trust anchor's 
\&\s-1DNSKEY\s0. An example is:
.RS 4
.IP "mozilla trust-anchor" 4
.IX Item "mozilla trust-anchor"
.RS 4
.PD 0
.IP "fruits.netsec.tislabs.com." 4
.IX Item "fruits.netsec.tislabs.com."
.PD
\&\*(L"257 3 5 AQO8XS4y9r77X9SHBmrxMoJf1Pf9AT9Mr/L5BBGtO9/e9f/zl4FFgM2l B6M2XEm6mp6mit4tzpB/sAEQw1McYz6bJdKkTiqtuWTCfDmgQhI6/Ha0 EfGPNSqnY 99FmbSeWNIRaa4fgSCVFhvbrYq1nXkNVyQPeEVHkoDNCAlr qOA3lw==\*(R"
.IP "netsec.tislabs.com." 4
.IX Item "netsec.tislabs.com."
\&\*(L"257 3 5 AQO8XS4y9r77X9SHBmrxMoJf1Pf9AT9Mr/L5BBGtO9/e9f/zl4FFgM2l B6M2XEm6mp6mit4tzpB/sAEQw1McYz6bJdKkTiqtuWTCfDmgQhI6/Ha0 EfGPNSqnY 99FmbSeWNIRaa4fgSCVFhvbrYq1nXkNVyQPeEVHkoDNCAlr qOA3lw==\*(R"
.Sp
;
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.IP "zone-security-expectation" 4
.IX Item "zone-security-expectation"
Specifies the local security expection for a zone. The additional
data portion for this keyword is a sequence of the zone name and 
its trust status \- trusted or untrusted. An example is:
.Sp
mozilla zone-security-expectation wesh.fruits.netsec.tislabs.com untrusted;		 
.RE
.RS 4
.RE
.SH "CURRENT STATUS"
.IX Header "CURRENT STATUS"
There is currently no support for IPv6. 
The library is not thread\-safe. 
The caching functionality is very basic and no timeout logic currently exists. 
There are a number of feature enhancements that still remain to be done.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2004\-2005 \s-1SPARTA\s0, Inc.  All rights reserved.
See the \s-1COPYING\s0 file included with the dnssec-tools package for details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fB\f(BIlibsres\fB\|(3)\fR
.PP
\&\fB\f(BIval_x_query\fB\|(3)\fR
.PP
http://dnssec\-tools.sourceforge.net
