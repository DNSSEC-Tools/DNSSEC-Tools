<?xml version="1.0"  encoding='ISO-8859-1' standalone='no' ?>
<?rfc compact="yes" ?>
<?rfc editing="no" ?>
<?rfc toc="yes"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<rfc ipr="full3978" docName="draft-dnssec-validator-api-00">
  <front>
  <title> DNSSEC Validator API </title>
  <author initials="S." surname="Krishnaswamy"
                fullname="Suresh Krishnaswamy"> 
    <organization> SPARTA, Inc. </organization>
    <address>
       <postal>
        <street>7075 Samuel Morse Dr.</street>
        <city>Columbia</city>
        <region>MD</region>
        <code>21046</code>
        <country>US</country>
      </postal>
      <email>suresh AT sparta.com</email>
    </address>
  </author>

  <author initials="A." surname="Hayatnagarkar"
                fullname="Abhijit Hayatnagarkar"> 
    <organization> SPARTA, Inc. </organization>
    <address>
       <postal>
        <street>7075 Samuel Morse Dr.</street>
        <city>Columbia</city>
        <region>MD</region>
        <code>21046</code>
        <country>US</country>
      </postal>
      <email>abhijit AT sparta.com</email>
    </address>
  </author>

  <date month="February" year="2006" />
  <workgroup> DNS Extensions </workgroup>
  <keyword>Internet-Draft</keyword>

  <abstract> 
    <t>The DNS Security Extensions (DNSSEC) provide origin authentication and
integrity of DNS data.  However, the current resolver API does not allow a
security-aware resolver to communicate results of DNSSEC processing back to the
application.  This document describes an Application Programming Interface between
applications and a validating security-aware stub resolver that allows
applications to control the validation process and obtain results of
DNSSEC processing.</t>
  </abstract>
  </front>

  <middle>
  <section title="Introduction">
  <!--           ############## -->

  <t>
  DNS Security Extensions (<xref target="refs.RFC4033">RFC 4033</xref>,
<xref target="refs.RFC4034">RFC 4034</xref>, <xref target="refs.RFC4035">RFC 4035</xref>)
allow applications to test the origin authenticity and integrity of data returned by the 
DNS.  The validator is a piece of software that performs this test
by checking the cryptographic signatures that cover DNS records and by
verifying a sequence of such records up to a trusted key. </t>

  <t>
  This document presents an Application Programming Interface (API) 
for the validator.  The API functions provide
a convenient way for applications to control the DNSSEC validation
process and to obtain results of the validation process. </t>
  <t>
  The API can be broadly divided into three groups: 
the high-Level validator API, the low-Level validator API and 
the context management API. </t>

  <t>
  The high-level validator API is designed for ease of 
use and mirrors existing DNS-related functions.
These interfaces are best suited for existing applications that already use 
legacy DNS-related functions such as gethostbyname(), 
getaddrinfo() and res_query(). </t>

  <t> The low-level validator API gives more control over the 
validation process and allows detailed inspection of validation 
status for each element of the chain-of-trust. </t>

  <t> Context management is orthogonal to the process of validation up the
chain-of-trust. Results returned by the validator are often guided by local
policy decisions.  
The context
management API provides interfaces to manage the validator context.</t>

  <t> This range of API functions allows for the creation of applications
that are either only interested in basic results such as "validated"
or "not-validated", or more sophisticated applications that can look
for specific errors as a sign of some network abnormality or attack. </t>

  <t> <xref target="high_level_api"/>, <xref target="low_level_api"/>,
and <xref target="val-context"/> describe these interfaces in greater detail. </t>

  </section> <!-- Introduction -->


  <section title="Terminology">
  <!--            ############# -->

  <t>
  The following terms are used in this specification: </t>

      <list style="hanging">

	<t> </t>
	<t hangText="validator policy:"> 
	A set of configuration parameters for the validator which could potentially influence 
	the eventual outcome of the validation process. </t>

	<t> </t>
        <t hangText="policy attribute: ">
        Refers to a particular configurable component of the validator policy,
        for instance a trust anchor setting or an untrusted algorithm definition. </t>
        <t> </t>

        <t hangText="validator context:">
	An opaque structure encapsulating the validator policy that may be used by
	applications to fine tune and control their validation processes. 
        The validator context is the application's handle to the validator policy. 
	Contexts also maintain a reference to a "policy scope" 
	(see definition below), which may be explicitly changed 
	by applications. 
        </t>

        <t> </t>
        <t hangText="base policy:">
        Refers to the default policy associated with a context when the context is created.
	This policy is looked up  whenever a policy attribute not existing in other more 
	specific policy scopes is required. A "default" base policy can also be defined
	to provide the definitions for system-wide policy attribute defaults.
	</t>	

	<t> </t>
        <t hangText="policy scope: ">
        Refers to a customization within the base-policy to address a particular scenario. 
        Policy scopes are useful
        when it becomes necessary to override certain policy attributes in specific
        environments. As an example, an application may support functions for a web browser 
        as well as a mail client with slighty differing validator policies for
        each piece of functionality. In such cases the application may define a common
        base policy and have overrides for specific scopes -- one for the mail
        client and one for the web browser. </t> 

	<t> </t>
        <t hangText="effective policy:">
        Refers to the policy that finally governs the validator action after all
        relevant policy scopes have been applied. 
        Policy scopes may be defined 
        hierarchically, one below the other. 
The effective policy is computed by applying the default policy and the base policy for the context, followed by overrides defined for all valid scopes in the configuration file in increasing order of specificity, up to and including the scope passed to val_switch_policy_scope(). </t>

      </list>

  </section> <!-- Terminology -->


    <section title="High-level Validator API" anchor="high_level_api">
    <!--            ######################### -->
    <t>
    The high-level validator API provides DNSSEC-aware substitutes for commonly
used DNS functions such as gethostbyname(), getaddrinfo() and res_query().
It provides an easy path for applications already using these legacy functions
to transition towards becoming DNSSEC-aware.
  </t>
  <t>
The ctx parameter of type val_context_t* used in the following functions points
to the validator context.  
An application may explicitly create a context using the val_get_context() function
described later, or allow the API to create one internally on its behalf by 
specifying the value of NULL for the ctx parameter.  Details for the validator
context appear in <xref target="val-context"/>.
  </t>
     <section title="val_gethostbyname, val_gethostbyname_r, val_gethostbyaddr, val_gethostbyaddr_r">
      <figure>
      <artwork>
struct hostent *val_gethostbyname( const val_context_t *ctx,
                                   const char          *name,
                                   val_status_t        *val_status );

int val_gethostbyname_r( const val_context_t *ctx,
                         const char          *name,
                         struct hostent      *ret,
                         char                *buf,
                         size_t              buflen,
                         struct hostent      **result,
                         int                 *h_errnop,
                         val_status_t        *val_status ); 

struct hostent *val_gethostbyaddr( const val_context_t *ctx,
                                   const char          *addr,
                                   int                 len,
                                   int                 type,
                                   val_status_t        *val_status );

int val_gethostbyaddr_r( const val_context_t *ctx,
                         const char          *addr,
                         int                 len,
                         int                 type,
                         char                *buf,
                         int                 buflen,
                         struct hostent      **result,
                         int                 *h_errnop,
                         val_status_t        *val_status );
      </artwork>
      <postamble>
      <t>
      The val_gethostbyname() and val_gethostbyname_r() functions perform
name-to-address translation.  The val_gethostbyaddr() and val_gethostbyaddr_r()
functions perform the address-to-name translation.
      These functions are DNSSEC-aware versions of the gethostbyname(),
gethostbyname_r(), gethostbyaddr() and gethostbyaddr_r() functions and
can be used by applications to get the validation status of DNS queries
performed during the name-to-address or address-to-name translation.
      </t>
      <t>
      The val_gethostbyname() function returns a pointer to a structure of
type hostent for the given host name.  The val_gethostbyaddr() function
returns a pointer to a structure of type hostent for the given host address
addr whose length is given by the len parameter and address type is given by
the type parameter.  Valid address types are AF_INET and AF_INET6.  As with
gethostbyname() and gethostbyaddr(), the val_gethostbyname() and
val_gethostbyaddr() functions set the value of the global h_errno variable.
Their return value may point to static data, and it may be overwritten by
subsequent calls.  These functions return a pointer to a struct hostent value
on success, and NULL on error.
      </t>
      <t>
      The val_gethostbyname_r() and val_gethostbyaddr_r() functions are
reentrant versions of the val_gethostbyname() and val_gethostbyaddr() functions.
They return 0 on success, and a non-zero value on error.  The result of the
call is stored in the hostent structure whose address is passed in the ret
parameter.  These functions do not modify the global h_errno variable, but
return the error numbers in the variable whose address is passed in the
h_errnop parameter. After the call, *result will be NULL on error
or point to the result on success.  Auxiliary data is stored in the buffer
buf of length buflen. If the buffer is too small, this function will
return an error.
      </t>
      <t>
      The val_status parameter is used to return the status of DNSSEC
validation, and must contain the address of a variable of type val_status_t. 
Possible values for val_status_t are defined in <xref target="low_level_api"/>.
      </t>
      </postamble>
      </figure>
      </section>

      <section title="val_getaddrinfo, val_getnameinfo, val_free_addrinfo">
      <figure>
      <artwork>
int val_getaddrinfo( const val_context_t   *ctx, 
                     const char            *nodename,
                     const char            *servname,
                     const struct addrinfo *hints,
                     struct val_addrinfo   **res ); 

int val_getnameinfo( const val_context_t   *ctx, 
                     const struct sockaddr *sa,
                     socklen_t             salen,
                     char                  *host,
                     size_t                hostlen,
                     char                  *serv,
                     size_t                servlen,
                     int                   flags,
                     val_status_t          *val_status );

void val_free_addrinfo( struct val_addrinfo *ainfo );

struct val_addrinfo {
           int                 ai_flags;
           int                 ai_family;
           int                 ai_socktype;
           int                 ai_protocol;
           size_t              ai_addrlen;
           struct sockaddr     *ai_addr;
           char                *ai_canonname;
           struct val_addrinfo *ai_next;
           val_status_t        val_status;
}
      </artwork>
      <postamble>
      <t>
      The val_getaddrinfo() function returns the address and service
information for the specified domain name and service.  It is a
DNSSEC-aware version of the getaddrinfo() function
(<xref target="refs.RFC3493">RFC 3493</xref>).
This function supports both IPv4 and IPv6
addresses.  It returns a pointer to a value of type val_addrinfo in *res on
success, and NULL on error.  The val_addrinfo structure is an augmented form
of the addrinfo structure.  It contains an additional val_status field that
represents the status of DNSSEC validation for that particular answer.  A
successful validation status must be set only if both the address and
canonical name (if present) have been validated successfully.  The memory for
the value returned in *res is dynamically allocated by this function.  The
caller should free it after use using the val_free_addrinfo() function.
      </t>
      <t>
      The val_getnameinfo() function performs an address-to-name translation
in a protocol independent manner.  It is a DNSSEC-aware version of the
getnameinfo() function (<xref target="refs.RFC3493">RFC 3493</xref>).  In
addition to the values returned by the getnameinfo() function, it returns
the DNSSEC validation status via the val_status parameter.
      </t>
      <t>
The val_getaddrinfo() and val_getnameinfo() functions return 0 on success and
a non-zero value on error.
      </t>
      </postamble>
      </figure>
      </section>

      <section title="val_query">
      <figure>
      <artwork>
int val_query( const val_context_t *ctx, 
               const char          *domain_name,
               const u_int16_t     class, 
               const u_int16_t     type,
               const u_int8_t      flags, 
               struct val_response *resp,
               int                 *resp_count ); 

struct val_response {
        unsigned char *response;
        int           response_length;
        val_status_t  val_status;
};
      </artwork>
      <postamble>
      <t>
      The val_query() function queries the name server for a fully qualified
domain name of the given class and type.  In addition to the answers to the
query, it gives the status of DNSSEC validation for each answer returned.
It is a intended as a DNSSEC-aware replacement for the res_query() function.
      </t>
      <t>
      Multiple RRsets may be returned in response to a query, each with a 
potentially different validation status. The answers are returned in an
array (resp) of val_response structures.  This array must be allocated by
the caller to be of sufficient size to hold all RRsets returned by the
DNS name server.  The caller must also allocate memory for the response
field within each val_response structure.  This field is a buffer that will
contain the actual answer (RRset) on a successful return from this function.</t>
      <t>
      By default, each val_response structure holds a single RRset response.
The format of the response field is similar to the format of the answer returned
by res_query().  The val_status field contains the status of DNSSEC validation
for that particular RRset.</t>
     <t>
     The resp_count parameter is a value-result parameter.  When this
function is called *resp_count must contain the number of elements in the
resp array.  On return, it will contain the actual number of responses
returned by the validator.</t>
     <t>
     The flags parameter controls the scope of validation and name
resolution, and the output format.  At present only one flag is defined:
VAL_QUERY_MERGE_RRSETS.  This flag has been provided for legacy applications
that already use res_query() and want to transition to val_query() with
minimal change.  When this flag is specified, all RRsets in the answer
are merged into a single response and returned in the first element of the
resp array.  The response field of this element will have a format similar
to the answer returned by res_query().  The validation status will be
VALIDATE_SUCCESS only if all the individual RRsets have been successfully
validated.  Otherwise, the validation status will be one of the other error
codes.  Note that if a value other than VALIDATE_SUCCESS is returned and if
multiple RRsets are present in the answer, it is not possible to know which
RRset resulted in the error status, if this flag is used.</t>
     <t>
     The val_query() function returns 0 on success and a non-zero error code
on failure. The error code NO_SPACE is returned if the resp array does not
contain enough elements or memory to hold all results returned by the validator.
In this case, on return *resp_count will contain the total
number of elements in the answer.  The caller can use this value to retry
val_query() with the appropriate number of elements in the resp array.</t>

<!-- Value of NO_SPACE ? -->
      </postamble>
      </figure>
      </section>

      </section> <!-- High-level Validator API -->


      <section title="Low-level Validator API" anchor="low_level_api">
      <!-- #################################### -->

      <t> 
      The low-level validator API provides the application with greater control and visibility 
into the validation process. The functions and data structures defined in this API are 
summarized below. </t>e

        <figure>
        <artwork>
int val_resolve_and_check( const val_context_t    *context, 
                           const char             *domain_name,
                           const u_int16_t        class,
                           const u_int16_t        type, 
                           const u_int8_t         flags,
                           struct val_result      **results, 
                           struct assertion_chain **assertions,
                           struct query_chain     **queries); 

void val_free_result( struct val_result *results );

void val_free_assertion_chain( struct assertion_chain *assertions );

void val_free_query_chain ( struct query_chain *queries );


struct val_result_chain {
    val_status_t               val_rc_status;
    struct val_assertion_chain *val_rc_trust;
    struct val_result          *val_rc_next;
};

struct val_assertion_chain {
    val_astatus_t              val_ac_status;
    struct val_rrset           *val_ac_rrset;
    struct val_query_chain     *val_ac_query_more;
    struct val_assertion_chain *val_ac_trust;
    struct val_assertion_chain *val_ac_rrset_next;
    struct val_assertion_chain *val_ac_next;
};

struct val_rrset {
    u_int8_t  val_rrset_section;
    u_int16_t val_rrset_len;
    u_int8_t  *val_rrset_data;
};


struct val_query_chain {
    val_qstatus_t              val_qc_status;
    u_int16_t                  val_qc_raw_response_length;
    u_int8_t                   *val_qc_raw_response;
    struct val_assertion_chain *val_qc_answer;
    struct val_assertion_chain *val_qc_creator;
    struch val_query_chain     *val_qc_next;
};
        </artwork>
        <postamble>
        <t>
        The val_resolve_and_check() function can be used to query a set of name servers
for the &lt;domain_name, class, type&gt; tuple and to verify and validate
the responses received. Verification is the step of checking the RRSIGs and
validation includes performing verification up the chain-of-trust to a trust
anchor.  All the information necessary for inspecting the validation
chain-of-trust is available through the results, assertions and queries
parameters. </t> 


        <t>
        Answers to the query are returned in the val_result_chain linked list.  
Each answer corresponds to a distinct RRset and is stored as a different element in the linked list; 
multiple RRs within the RRset are all part of the same answer. Multiple answers are possible
when type is ANY or when a proof of non-existence is returned, in
which case RRsets of type NSEC and SOA may also be returned. 
val_rc_trust points to the next element in the chain-of-trust sequence and val_rc_next can be used
to iterate through the list of all results returned by the validator. 
The consolidated validation status value for an RRset in the  DNS response based on the 
individual status values for all components in the chain-of-trust is stored in val_rc_status, which is of type val_status_t. Possible values for this type are listed below. </t> 

        <t> <list style="hanging">
        <t> </t>
        <t hangText="VALIDATE_SUCCESS">
        Returned if the response was verified and validated.
        </t>
        <t hangText="LOCAL_ANSWER">
        Returned if the response was obtained locally from a configuration file such as /etc/hosts.
        </t>
        <t hangText="BARE_RRSIG">
        Returned if the response was for a query of type RRSIG. RRSIGs contain the cryptographic
	signatures for other DNS data and cannot themselves be validated.
        </t>
        <t hangText="NONEXISTENT_NAME">
        Returned if the proof for denial of existence for a domain name
	was validated. 
        </t>
        <t hangText="NONEXISTENT_TYPE">
        Returned if the proof for denial of existence for the resource record type for the
	name queried was validated. 
        </t>
        <t hangText="INDETERMINATE">
        Returned if the validator lacked detail to complete validation up the chain-of-trust. 
        </t>
        <t hangText="BOGUS">
        Returned if the origin authenticity for the response could not be verified. 
        </t>
        <t hangText="VALIDATION_ERROR">
        Returned if the DNS returned some error for the original query. 
        </t>
        <t hangText="PROVABLY_UNSECURE">
        Returned if the zone to which the response belongs can be shown to be 
        legitimately un-signed.  
        </t>
        </list>
        </t>

        <t>
        The validator may initiate multiple queries to the DNS while trying to construct the
chain-of-trust. Each response is encapsulated within one or more elements of the struct val_assertion_chain linked list. However not all elements in this list are present in the chain-of-trust. 
For instance, responses for glue-fetching operations are not directly a part of the chain-of-trust and and not validated.
The assertions parameter in val_resolve_and_check() returns a pointer to the set
 of all digested responses  
received over the course of validating an answer including data received for any ancillary information.
assertions may also be thought of as a cache of responses obtained during the validation process.</t>

        <t>
        Most applications would only be interested in the results parameter 
since this provides a single error code that represents the authenticity of 
returned data.  More sophisticated applications such as a DNSSEC troubleshooting 
utility may look more closely at an individual assertion or query to identify 
whch particular component in the chain-of-trust led to validation failure, if any.
Given a pointer to an element of type struct val_assertion_chain within the chain-of-trust, 
it is possible to inspect further details of the validation status of each component therein using
this structure's member variables. </t> 

	<t> val_ac_status returns the validation status for the specified 
component in the linked list. 
(Author's note: the definition of the  
error codes is an activity being undertaken in parallel by a sub-working group at the IETF. 
The list of error codes returned by the validator in val_astatus_t will draw upon that effort.)  
        The val_ac_rrset_next member inside struct val_assertion_chain points to the 
next digested answer within the set of responses returned for a query. 
In cases where validation fails due to some non-DNSSEC error, the val_ac_query_more variable can be used to identify the
query where the error was encountered. 
val_ac_trust points to the next element in the chain-of-trust. Its value is NULL when the current element in the linked list points to a valid trust anchor. 
val_ac_next can be used to iterate through the list of DNS responses within the struct val_assertion_chain linked list.</t> 

<t>
val_ac_rrset contains the actual RRset data stored internally within the struct val_rrset structure as a length-value pair given by val_rrset_len and val_rrset_data. The section in which the RRset appears in the DNS response is also saved in val_rrset_section. The following values may be returned in this variable. </t> 
        <t> <list style="hanging">
        <t> </t>
        <t hangText="VAL_FROM_ANS">
        Returned if the RRset was present in the answer section of the DNS response.
        </t>
        <t> </t>
        <t hangText="VAL_FROM_AUT">
        Returned if the RRset was present in the authority section of the DNS response.
        </t>
        <t> </t>
        <t hangText="VAL_FROM_ADD">
        Returned if the RRset was present in the additional section of the DNS response.
        </t>
	</list></t>

        <t>
        The queries parameter in val_resolve_and_check() returns a pointer to a linked list containing the complete set 
of DNS queries that were issued while resolving and validating the 
original DNS query inclusive of the original query. This parameter 
may also be thought of as a cache of queries sent out during the 
validation process. The val_qc_status member variable for an element in this liked list returns the
status of the query: if it was answered, if there was no response or some other DNS-related value 
(Author's note: the definition of possible values for this field, as in the case of values for val_astatus_t will draw upon efforts within the IETF to generate a complete list of error codes for the validator.) 
The on-the-wire bytes returned as the response to a query are stored as a length-value field in
val_qc_raw_response_length and val_qc_raw_response respectively.
val_qc_answer points to the set of digested answers created for the response and may be NULL when no responses are returned. 
val_qc_creator is used to identify which link in the chain-of-trust led to the generation of this query and is NULL for
the initial query issued by the val_resolve_and_check() method. 
val_qc_next can be used to iterate through the list of DNS queries within the struct val_query_chain linked list.
The combination of the previous two functions makes it possible to identify all queries sent out in order to validate a particular assertion. </t> 


        <t>
The val_resolve_and_check() method internally allocates memory for the values of the results, queries and assertions parameters  so they must be freed by the invoking application using the
val_free_query_chain(), val_free_assertion_chain() and val_free_result() functions.</t>

        </postamble>
        </figure>

    </section> <!-- Low-level API -->

    <section title="Context Management and Validator Policy API" anchor="val-context">
    <!--            ####################################### -->

      <t>
      Local policy for the validator is stored in the /etc/dnsval.conf file.
      Applications can use local policy to influence the decision 
      about when the validator must break 
      out from the process of constructing a chain-of-trust with 
      either a success or failure condition.  
      Examples of local policy elements include trust anchors for 
      different zones, untrusted algorithms for cryptographic keys and hashes, 
      acceptable clock skew for signature inception and expiration times and default 
      name servers to direct queries to, all of which may be different for different 
      applications and operation scenarios. </t>


      <t> 
      The context management and validator policy API allows an application 
	some flexibility in choosing its validation policy based on its scope of execution. </t>


      <section title="val_get_context">
      <figure>
      <artwork>

int val_get_context( const char    *label,
                 val_context_t **newcontext );
      </artwork>
      <postamble>
      <t>
      Returns a pointer to the val_context_t structure in newcontext.  
A NULL context is returned if some error was encountered. 
The application must release the memory allocated 
by the val_get_context() function using the val_free_context() interface once it is done with using it.</t>

<t> 
label identifies the particular policy to be used as the base policy for the context during validation. The policy label is a simple text string that can be used to identify the policy in the configuration file. As an example "browser" could be used as the label for a policy that defines the base policy for all web-browsers in a system.  
The ':' character in the label string is used to specify a new scope within a given policy. Thus, "mail:mozilla:browser" could be used as the identifier to refer to the mail-specific validation policy for the mozilla suite. </t> 

<t> 
The label parameter in val_get_context() must be uniquely defined within the configuration file. A NULL
label creates a context with the default base policy. The default base policy is identified within the validator configuration file by a lable value of ':'.</t> 

      </postamble>
      </figure>
      </section>

      <section title="val_free_context">
      <figure>
      <artwork>
void val_free_context( val_context_t *context );
      </artwork>
      <postamble>
      <t>
      Releases memory in the val_context_t structure previously allocated by the val_get_context() function.</t>
      </postamble>
      </figure>
      </section>

      <section title="val_switch_policy_scope">
      <figure>
      <artwork>
int val_switch_policy_scope( val_context_t *ctx,
                             const char    *scope );
      </artwork>
      <postamble>
      <t>
      This function allows applications to switch their current to a particular scope.  
The context supplied in ctx must not be NULL. The API only allows the context to switch its policy to a valid scope. Thus, trying to switch the policy scope to "mail:mozilla:browser" when the context was created with a base policy of "safari:browser" would result in an error. 

A NULL label switches the context's current policy scope to its base policy. </t> 
      </postamble>
      </figure>
      </section>

      <section title="val_get_scopes_within_context">
      <figure>
      <artwork>
int val_get_scopes_within_context( val_context *ctx,
                                   char        **scopes,
                                   int         *count );
      </artwork>
      <postamble>
      <t>
      This function allows applications to obtain the list of policy scopes available within a given context.
The application must allocate the scopes array to be large enough to hold all available answers. 
Each element in the array must be pre-allocated to at least MAX_POLICY_ID_LENGTH. 
count is a value-result parameter that must be set to the number of elements allocated in the scopes array. 
If the size of the array is not large enough to hold all answers, the function returns -1 and *count contains 
the actual number of scopes available within the context. 0 is returned on success and *count contains 
the number of scopes. </t> 
      </postamble>
      </figure>
      </section>

      <section title="val_get_scope_definition">
      <figure>
      <artwork>
int val_get_scope_definition( val_context *ctx,
                              char        *scope,
                              char        **pol_def ); 
      </artwork>
      <postamble>
      <t>
      This function allows applications to obtain the policy definition for a given scope identifier.
The context supplied in ctx must not be NULL.</t> 
      </postamble>
      </figure>
      </section>

      <section title="val_set_scope_definition">
      <figure>
      <artwork>
int val_set_scope_definition( val_context *ctx,
                              const char  *label, 
                              char        *policy_string );
      </artwork>
      <postamble>
      <t>
      This function allows an application to modify an existing policy scope or 
define a new policy scope within a context. The context supplied in ctx must not 
be NULL. A label of NULL can be used to 
update the base policy within the context.</t> 

      </postamble>
      </figure>
      </section>


    </section> <!-- Context Management -->


   <section title="IANA Considerations">
   <t> This document has no actions for IANA.</t>
   </section> <!-- IANA Considerations -->

   <section title="Security Considerations" anchor="security-considerations">
   <t>
   DNSSEC Security Extensions provide origin authentication and data integrity
of DNS data.  This document describes an API for communicating results of
DNSSEC validation to an application and for an application to control the
validation process.
   </t>
   <t>
   The validator API relies on three factors for performing validation.  The
first is the /etc/hosts file for local name-to-address and address-to-name
translations.  The second is the /etc/resolv.conf file for determining the
DNS search path and addresses of name servers.  The third is the validator
policy.  Each of these will affect the validation result.
   </t>
   <t>
   The validator API functions can return a status of LOCAL_ANSWER if they get
the answer to the query locally (for example, from the /etc/hosts file).  The
application cannot assume that these answers can be trusted, unless the
application is certain that local data (the /etc/hosts file) is trustworthy.
If the /etc/hosts file is modified during a DHCP lookup, for example, the client
system should ensure that the DHCP server is a trusted source, and that the
communication path between the DHCP server and the client system is secured. 
 If these conditions are not satisfied and if the application chooses to trust
a validation status of LOCAL_ANSWER, there exists a potential attack vector
whereby an attacker can poison the /etc/hosts file and an application using
this API may trust the result.
   </t>
   <t>
   The DNS search path may affect the result of validation, especially in
the current Internet environment where not all DNS name servers are
expected to be DNSSEC-aware.  If the name server pointed to by /etc/resolv.conf
is not DNSSEC-aware (i.e. it does not return DNSSEC records), this API will not
be able to perform validation.  This will prevent applications from getting
results of DNSSEC validation.  The system on which the validator runs must
ensure that the name servers listed in /etc/resolv.conf are DNSSEC-aware.
Similarly, if the client system uses DHCP, it must ensure that the DHCP server
is a trusted source, and that the communication path between the DHCP server
and the client system is secured.
   </t>
   <t>
   The default validator policy file (/etc/dnsval.conf) needs to be protected
so that it cannot be overwritten by unauthorized users or processes.  Policies
in this file will list the trust anchors for classes of applications.  The
system administrator must ensure that the list of trust anchors are kept
up-to-date in the event of key-rollovers.  If the trust anchors are outdated,
the validator will not be able to validate responses from DNS.
   </t>
   </section> <!-- Security Considerations -->

   <section title="Acknowledgements">
   <t>We would like to acknowledge the following individuals who have provided
valuable feedback and suggestions for improving this document: Lindy Foster,
Wayne Morrison, Bill Sommerfeld, Robert Story.  We would like to acknowledge
our team members at SPARTA for their inputs and suggestions while developing the
validator API.</t>
   </section> <!-- Acknowledgements -->

   </middle>
   <back>
        <references>
            <reference anchor="refs.RFC3493">
              <front>
                <title>Basic Socket Interface Extensions for IPv6</title>
                <author initials="R." surname="Gilligan" fullname="Bob Gilligan" />
                <author initials="S." surname="Thomson" fullname="Susan Thomson" />
                <author initials="J." surname="Bound" fullname="Jim Bound" />
                <author initials="J." surname="McCann" fullname="Jack McCann" />
                <author initials="W." surname="Stevens" fullname="W. Richard Stevens" />
                <date month="February" year="2003" />
              </front>
              <seriesInfo name="RFC" value="3493" />
            </reference>
            <reference anchor="refs.RFC4033">
              <front>
                <title>DNS Security Introduction and Requirements</title>
                <author initials="R." surname="Arends" fullname="Roy Arends" />
                <author initials="R." surname="Austein" fullname="Rob Austein" />
                <author initials="M." surname="Larson" fullname="Matt Larson" />
                <author initials="D." surname="Massey" fullname="Dan Massey" />
                <author initials="S." surname="Rose" fullname="Scott Rose" />
                <date month="March" year="2005" />
              </front>
              <seriesInfo name="RFC" value="4033" />
            </reference>
            <reference anchor="refs.RFC4034">
              <front>
                <title>Resource Records for the DNS Security Extensions</title>
                <author initials="R." surname="Arends" fullname="Roy Arends" />
                <author initials="R." surname="Austein" fullname="Rob Austein" />
                <author initials="M." surname="Larson" fullname="Matt Larson" />
                <author initials="D." surname="Massey" fullname="Dan Massey" />
                <author initials="S." surname="Rose" fullname="Scott Rose" />
                <date month="March" year="2005" />
              </front>
              <seriesInfo name="RFC" value="4034" />
            </reference>
            <reference anchor="refs.RFC4035">
              <front>
                <title>Protocol Modifications for the DNS Security Extensions</title>
                <author initials="R." surname="Arends" fullname="Roy Arends" />
                <author initials="R." surname="Austein" fullname="Rob Austein" />
                <author initials="M." surname="Larson" fullname="Matt Larson" />
                <author initials="D." surname="Massey" fullname="Dan Massey" />
                <author initials="S." surname="Rose" fullname="Scott Rose" />
                <date month="March" year="2005" />
              </front>
              <seriesInfo name="RFC" value="4035" />
            </reference>
        </references>
        <!-- Appendices
        <section ...>
        <section ...>
        -->
    </back>
</rfc>

<!-- last updated Feb. 24, 2006 -->

