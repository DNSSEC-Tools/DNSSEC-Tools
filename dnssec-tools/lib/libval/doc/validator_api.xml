<?xml version="1.0"  encoding='ISO-8859-1' standalone='no' ?>
<?rfc compact="yes" ?>
<?rfc editing="no" ?>
<?rfc toc="yes"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<rfc ipr="full3978" docName="draft-dnssec-validator-api-00">
  <front>
  <title> DNSSEC Validator API </title>
  <author initials="S." surname="Krishnaswamy"
                fullname="Suresh Krishnaswamy"> 
    <organization> SPARTA Inc. </organization>
    <address>
       <postal>
        <street>7075 Samuel Morse Dr.</street>
        <city>Columbia</city>
        <region>MD</region>
        <code>21046</code>
        <country>US</country>
      </postal>
      <email>suresh AT sparta.com</email>
    </address>
  </author>

  <author initials="A." surname="Hayatnagarkar"
                fullname="Abhijit Hayatnagarkar"> 
    <organization> SPARTA Inc. </organization>
    <address>
       <postal>
        <street>7075 Samuel Morse Dr.</street>
        <city>Columbia</city>
        <region>MD</region>
        <code>21046</code>
        <country>US</country>
      </postal>
      <email>abhijit AT sparta.com</email>
    </address>
  </author>

  <date month="February" year="2006" />
  <workgroup> DNS Extensions </workgroup>
  <keyword>Internet-Draft</keyword>

  <abstract> 
    <t>DNS Security Extensions allow a resolver to determine whether a DNS query
was validated successfully or not.  However they do not address the issue of how
to communicate details of the validation result to an application that wants to
make decisions based on this result.  This document describes an Application
Programming Interface that allows applications to control and get the results
of the validation process.</t>
  </abstract>
  </front>

  <middle>
  <section title="Introduction">
  <!--           ############## -->

  <t>
  DNS Security Extensions (<xref target="refs.RFC4033">RFC 4033</xref>,
<xref target="refs.RFC4034">RFC 4034</xref>, <xref target="refs.RFC4035">RFC 4035</xref>)
allow applications to test the origin authenticity and integrity of data returned by the 
DNS.  The validator is a piece of software that performs this test
by checking the cryptographic signatures that cover DNS records and by
verifying a sequence of such records up to a trusted key. </t>

  <t>
  This document presents an Application Programming Interface (API) 
for the validator.  The API functions provide
a convenient way for applications to control the DNSSEC validation
process and to obtain results of validation.  The API contains 
DNSSEC-aware substitutes for a number of well-known interfaces that
applications may use in lieu of older interfaces. Other interfaces
are also provided that allow applications to obtain more detail and fine-tune the
validation process. This range allows for the creation of applications
that are either only interested in basic results such as "validated"
or "not-validated", or more sophisticated applications that can look
for specific errors as a sign of some network abnormality or attack. </t>
  </section> <!-- Introduction -->


  <section title="Terminology">
  <!--            ############# -->

  <t>
  The following terms are used in this specification: </t>

      <list style="hanging">

	<t> </t>
	<t hangText="validator policy:"> 
	A set of configuration parameters for the validator which could potententially influence 
	the eventual outcome from the validation process. </t>

	<t> </t>
        <t hangText="policy attribute: ">
        Refers to a particular configurable component of the validator policy,
        for instance a trust anchor setting or an untrusted algorithm definition. </t>
        <t> </t>

        <t hangText="validator context:">
	The validator context encapsulates
	the validator policy into an opaque structure that may be used by
	applications to fine tune and control their validation processes. 
        The validator context is the application's handle to the validator policy. 
	Contexts also maintain a reference to a "policy scope" 
	(see definition below), which may be explicitly changed 
	by applications. 
        </t>

        <t> </t>
        <t hangText="base policy:">
        Refers to the default policy associated with a context that is looked up  
	whenever a policy attribute not existing in other more specific policy scopes 
        is required. Different applications can have different base policies. 
	</t>	

	<t> </t>
        <t hangText="policy scope: ">
        Refers to a customization within the base-policy to address a particular scenario. 
        Policy scopes are useful
        when it becomes necessary to override certain policy attributes in specific
        environments. As an example, an application may support functions for a web browser 
        as well as a mail client with slighty differing validator policies for
        each piece of functionality. In such cases the application may define a common
        base policy and have overrides for specific scopes -- one for the mail
        client and one for the web browser. </t> 

	<t> </t>
        <t hangText="effective policy:">
        Refers to the policy that finally governs the validator action after all
        relevant policy scopes have been applied. 
        Policy scopes may be defined 
        hierarchically, one below the other. In order to determine the effective policy, 
        the validator context cumulatively applies the validator policy 
        for all scopes that lie above its current scope up to and including its base policy. </t>

      </list>

  </section> <!-- Terminology -->


  <section title="Validator API">
  <!--            ############# -->

  <t>
  The API can be broadly divided into three groups: 
the High-Level validator API, the Low-Level validator API and 
the Context management API. </t>

  <t>
  The high-level validator API is designed for ease of 
use and mirrors existing DNS-related functions.
These interfaces are best suited for existing applications that already use 
legacy DNS-related functions such as gethostbyname(), 
getaddrinfo() and res_query(). </t>

  <t> The low-level validator API gives more control over the 
validation process and allows detailed inspection of validation 
status for each element of the chain-of-trust. </t>

  <t> Context management is orthogonal to the process of validation up the
chain-of-trust. Results returned by the validator are often guided by local
policy decisions.  
The context
management API provides interfaces to manage the validator context.</t>

  <t> The following sections describe these interfaces in greater detail. </t>

    <section title="High-level Validator API" anchor="high_level_api">
    <!--            ######################### -->
    <t>
    The high-level validator API provides DNSSEC-aware substitutes for commonly
used DNS functions such as gethostbyname(), getaddrinfo() and res_query().
It provides an easy path for applications already using these legacy functions
to transition towards becoming DNSSEC-aware.
  </t>
  <t>
The ctx parameter of type val_context_t* used in the following functions points
to the validator context.  The validator context is an abstraction to the current
validator policy in effect when a query is issued for resolution and validation.
An application may explicitly create a context using the val_get_context() function
described later, or allow the API to create one internally on its behalf by 
specifying the value of NULL for the ctx parameter.  Details for the validator
context appear in <xref target="val-context"/>.
  </t>
     <section title="val_gethostbyname, val_gethostbyname_r, val_gethostbyaddr, val_gethostbyaddr_r">
      <figure>
      <artwork>
struct hostent *val_gethostbyname( const val_context_t *ctx,
                                   const char          *name,
                                   val_status_t        *val_status );

int val_gethostbyname_r( const val_context_t *ctx,
                         const char          *name,
                         struct hostent      *ret,
                         char                *buf,
                         size_t              buflen,
                         struct hostent      **result,
                         int                 *h_errnop,
                         val_status_t        *val_status ); 

struct hostent *val_gethostbyaddr( const val_context_t *ctx,
                                   const char          *addr,
                                   int                 len,
                                   int                 type,
                                   val_status_t        *val_status );

int val_gethostbyaddr_r( const val_context_t *ctx,
                         const char          *addr,
                         int                 len,
                         int                 type,
                         char                *buf,
                         int                 buflen,
                         struct hostent      **result,
                         int                 *h_errnop,
                         val_status_t        *val_status );
      </artwork>
      <postamble>
      <t>
      The val_gethostbyname() and val_gethostbyname_r() functions perform
name to address translation.  The val_gethostbyaddr() and val_gethostbyaddr_r()
function perform the address to name translation.
      These functions are DNSSEC-aware versions of the gethostbyname()
gethostbyname_r(), gethostbyaddr() and gethostbyaddr_r() functions and
can be used by applications to get the validation status of DNS queries
performed during the name to address or address to name translation.
      </t>
      <t>
      The val_gethostbyname() function returns a structure of type hostent for
the given host name.  As with gethostbyname(), the val_gethostbyname()
function sets the value of the global h_errno variable.  The return value
may point to static data, which may be overwritten by subsequent calls.  This
function returns a pointer to a struct hostent value on success, and NULL on
error.</t>
      <t>
      The val_gethostbyaddr() function returns a pointer to a structure
of type hostent for the given host address addr of length len and address
type type.  Valid address types are AF_INET and AF_INET6.  As with
gethostbyaddr(), the val_gethostbyaddr() function sets the value of the
global h_errno variable.  The return value may point to static data,
which may be overwritten by subsequent calls.  This function returns a
pointer to a struct hostent value on success, and NULL on error.
      </t>
      <t>
      The val_gethostbyname_r() and val_gethostbyaddr_r() functions are
reentrant versions of the val_gethostbyname() and val_gethostbyaddr() functions.
They return 0 on success, and a non-zero value on error.  The result of the
call is stored in the hostent structure whose address is passed in the ret
parameter.  These functions do not modify the global h_errno variable, but
return the error numbers in the variable whose address is passed in the
h_errnop parameter. After the call, *result will be NULL on error
or point to the result on success.  Auxiliary data is stored in the buffer
buf of length buflen. If the buffer is too small, this function will
return an error.
      </t>
      <t>
      The val_status parameter is used to return the status of DNSSEC
validation, and must contain the address of a variable of type val_status_t.
      </t>
      </postamble>
      </figure>
      </section>

      <section title="val_getaddrinfo, val_getnameinfo, free_val_addrinfo">
      <figure>
      <artwork>
int val_getaddrinfo( const val_context_t   *ctx, 
                     const char            *nodename,
                     const char            *servname,
                     const struct addrinfo *hints,
                     struct val_addrinfo   **res ); 

int val_getnameinfo( const val_context_t   *ctx, 
                     const struct sockaddr *sa,
                     socklen_t             salen,
                     char                  *host,
                     size_t                hostlen,
                     char                  *serv,
                     size_t                servlen,
                     int                   flags,
                     val_status_t          *val_status );

void free_val_addrinfo( struct val_addrinfo *ainfo );

struct val_addrinfo {
           int                 ai_flags;
           int                 ai_family;
           int                 ai_socktype;
           int                 ai_protocol;
           size_t              ai_addrlen;
           struct sockaddr     *ai_addr;
           char                *ai_canonname;
           struct val_addrinfo *ai_next;
           val_status_t        val_status;
}
      </artwork>
      <postamble>
      <t>
      The val_getaddrinfo() function returns the address and service
information for the specified domain name and service.  It is a
DNSSEC-aware version of the getaddrinfo() function
(<xref target="refs.RFC3493">RFC 3493</xref>).
This function supports both IPv4 and IPv6
addresses.  It returns a pointer to a value of type val_addrinfo in *res on
success, and NULL on error.  The val_addrinfo structure is an augmented form
of the addrinfo structure.  It contains an additional val_status field that
represents the status of DNSSEC validation for that particular answer.  A
successful validation status must be set only if both the address and
canonical name (if present) have been validated successfully.  The memory for
the value returned in *res is dynamically allocated by this function.  The
caller should free it after use using the free_val_addrinfo() function. The
val_getaddrinfo() function returns 0 on success and a non-zero value on error.
      </t>
      <t>
      The val_getnameinfo() function performs an address to name translation
in a protocol independent manner.  It is a DNSSEC-aware version of the
getnameinfo() function (<xref target="refs.RFC3493">RFC 3493</xref>).  In
addition to the values returned by the getnameinfo() function, it returns
the DNSSEC validation status via the val_status parameter.
      </t>
      </postamble>
      </figure>
      </section>

      <section title="val_query">
      <figure>
      <artwork>
int val_query( const val_context_t *ctx, 
               const char          *domain_name,
               const u_int16_t     class, 
               const u_int16_t     type,
               const u_int8_t      flags, 
               struct val_response *resp,
               int                 *resp_count ); 

struct val_response {
        unsigned char *response;
        int           response_length;
        val_status_t  val_status;
};
      </artwork>
      <postamble>
      <t>
      This function is a DNSSEC-aware replacement for the res_query() function.
It performs a DNS query for the given &lt;domain_name, class, type&gt; tuple similar
to res_query() and additionally performs DNSSEC validation of the answers
returned.</t>
      <t>
      Multiple RRsets may be returned in response to a query, each with a 
potentially different validation status. The answers are returned in an
array (resp) of val_response structures.  This array must be allocated by
the caller to be of sufficient size to hold all RRsets returned by the
DNS name server.  The caller must also allocate memory for the response
field within each val_response structure.  This field is a buffer that will
contain the actual answer (RRset) on a successful return from this function.</t>
      <t>
      By default, each val_response structure holds a single RRset response.
The format of the response field is similar to the format of the answer returned
by res_query().  The val_status field contains the status of DNSSEC validation
for that particular RRset.</t>
     <t>
     The resp_count parameter is a value-result parameter.  When this
function is called *resp_count must contain the number of elements in the
resp array.  On return, it will contain the actual number of responses
returned by the validator.</t>
     <t>
     The ctx parameter is the validator context and can be set to NULL
for default settings.</t>
     <t>
     The flags parameter controls the scope of validation and name
resolution, and the output format.  At present only one flag is defined:
VAL_QUERY_MERGE_RRSETS.  This flag has been provided for legacy applications
that already use res_query() and want to transition to val_query() with
minimal change.  When this flag is specified, all RRsets in the answer
are merged into a single response and returned in the first element of the
resp array.  The response field of this element will have a format similar
to the answer returned by res_query().  The validation status will be
VALIDATE_SUCCESS only if all the individual RRsets have been successfully
validated.  Otherwise, the validation status will be one of the other error
codes.  Note that if a value other than VALIDATE_SUCCESS is returned and if
multiple RRsets are present in the answer, it is not possible to know which
RRset resulted in the error status, if this flag is used.</t>
     <t>
     The val_query() function returns 0 on success and a non-zero error code
on failure. The error code NO_SPACE is returned if the resp array does not
contain enough elements or memory to hold all results returned by the validator.
In this case, on return *resp_count will contain the total
number of elements in the answer.  The caller can use this value to retry
val_query() with the appropriate number of elements in the resp array.</t>

<!-- Value of NO_SPACE ? -->
      </postamble>
      </figure>
      </section>


      <section title="val_istrusted">
      <figure>
      <artwork>
int val_istrusted( const val_status_t val_status );
      </artwork>
      <postamble>
      <t>
      This function indicates whether the given validation status value
can be trusted or not.  A validation status value can be trusted if the
result of a DNS query has been obtained locally (for example from
/etc/hosts) or if the validator was able to validate the result of the
DNS query up to a trust anchor.  This function returns 1 if the val_status
value can be trusted, and 0 if it cannot be trusted.  This function can
be used by the application in conjunction with the other functions
described in this document to determine whether the answers returned by these
functions can be trusted.
      </t>
      </postamble>
      </figure>
      </section>

      </section> <!-- High-level Validator API -->


      <section title="Low-level Validator API">
      <!-- #################################### -->

      <t> 
      The low-level validator API provides the application with greater control and visibility 
into the validation process. The functions and data structures defined in this API are 
summarized below. </t>e

        <figure>
        <artwork>
int val_resolve_and_check( const val_context_t    *context, 
                     const char             *domain_name,
                     const u_int16_t        class,
                     const u_int16_t        type, 
                     const u_int8_t         flags,
                     struct val_result      **results, 
                     struct assertion_chain **assertions,
                     struct query_chain     **queries); 

void val_free_query_chain ( struct query_chain *queries );

void val_free_assertion_chain( struct assertion_chain *assertions );

void val_free_result( struct val_result *results );


struct val_result_chain {
    val_status_t val_rc_status;
    struct val_assertion_chain *val_rc_trust;
    struct val_result *val_rc_next;
};

struct val_assertion_chain {
  val_astatus_t val_ac_status;
  struct val_rrset *val_ac_rrset;
  struct val_query_chain *val_ac_query_more;
  struct val_assertion_chain *val_ac_trust;
  struct val_assertion_chain *val_ac_rrset_next;
  struct val_assertion_chain *val_ac_next;
};

struct val_rrset {
   u_int8_t  val_rrset_section;
   u_int16_t val_rrset_len;
   u_int8_t *val_rrset_data;
};


struct val_query_chain {
    val_qstatus_t val_qc_status;
    u_int16_t val_qc_raw_response_length;
    u_int8_t *val_qc_raw_response;
    struct val_assertion_chain *val_qc_answer;
    struct val_assertion_chain *val_qc_creator;
    struch val_query_chain *val_qc_next;
};
        </artwork>
        <postamble>
        <t>
        The val_resolve_and_check() function can be used to query a set of name servers
for the &lt;domain_name, class, type&gt; tuple and to verify and validate
the responses received. Verification is the step of checking the RRSIGs and
validation includes performing verification up the chain-of-trust to a trust
anchor.  All the information necessary for inspecting the validation
chain-of-trust is available through the results, assertions and queries
parameters. </t> 


        <t>
        Answers to the query are returned in the val_result_chain linked list.  
Each answer corresponds to a distinct RRset and is stored as a different element in the linked list; 
multiple RRs within the RRset are all part of the same answer. Multiple answers are possible
when type is ANY or when a proof of non-existence is returned, in
which case RRsets of type NSEC and SOA may also be returned. 
val_rc_trust points to the next element in the chain-of-trust sequence and val_rc_next can be used
to iterate through the list of results returned by the validator. 
The consolidated validation status value for an RRset in the  DNS response based on the 
individual status values for all components in the chain-of-trust is stored in val_rc_status, which is of type val_status_t. Possible values for this type are listed below: </t> 
        <t> <list style="hanging">
        <t> </t>
        <t hangText="VALIDATE_SUCCESS">
        Returned if the response was verified and validated.
        </t>
        <t hangText="INDETERMINATE_TRUST">
        Returned if the validator lacked detail to complete validation up the chain-of-trust. 
        </t>
        <t hangText="BOGUS_PROVABLE">
        Returned if the cryptographic signatures for the response could not be verified but the 
        remaining portion of the chain-of-trust was. 
        </t>
        <t hangText="BOGUS_UNPROVABLE">
        Returned if neither the response nor the chain-of-trust beyond it were verifiable.  
        </t>
        <t hangText="VALIDATION_ERROR">
        Returned if the DNS returned some error for the original query. 
        </t>
        <t hangText="PROVABLY_UNSECURE">
        Returned if the zone to which the response belongs can be shown to be 
        part of an intentionally un-signed delegation.  
        </t>
        </list>
        </t>

        <t>
        The validator may initiate multiple queries to the DNS while trying to create the
chain-of-trust. Each response is encapsulated into one or more elements of the struct val_assertion_chain linked list. However not all elements in this list are present in the chain-of-trust. 
For instance, responses for glue-fetching operations are not directly validated.
The assertions parameter in val_resolve_and_check() returns a pointer to the set
 of all digested responses  
received over the course of validating an answer including data received for such ancillary information.
assertions may also be thought of as a cache of responses obtained during the validation process.</t>

        <t>
        Most applications would only be interested in the results parameter 
since this provides a single error code that represents the authenticity of 
returned data.  More sophisticated applications such as a DNSSEC troubleshooting 
utility may look more closely at an individual assertion or query to identify 
whch particular component in the chain-of-trust led to validation failure, if any.
Given a pointer to an element of type struct val_assertion_chain within the chain-of-trust, 
it is possible to inspect further details of the validation status of each component therein using
this structure's member variables. </t> 

	<t> val_ac_status returns the validation status 
the particular component of the chain-of-trust referenced in the linked list. 
(Author's note: the definition of the  
error codes is an activity being undertaken in parallel by a sub-working group at the IETF. 
The list of error codes returned by the validator in val_astatus_t will draw upon that effort.)  
val_ac_rrset contains the actual RRset data stored internally within the struct val_rrset structure as a length-value pair given by val_rrset_len and val_rrset_data. The section in which the RRset appears in the DNS response is also saved in val_rrset_section. The following values may be returned in this variable. </t> 
        <t> <list style="hanging">
        <t> </t>
        <t hangText="VAL_FROM_ANS">
        Returned if the RRset was present in the answer section of the DNS response.
        </t>
        <t> </t>
        <t hangText="VAL_FROM_AUT">
        Returned if the RRset was present in the authority section of the DNS response.
        </t>
        <t> </t>
        <t hangText="VAL_FROM_ADD">
        Returned if the RRset was present in the additional section of the DNS response.
        </t>
	</list></t>

        <t>
        The val_ac_rrset_next member inside struct val_assertion_chain points to the 
next digested answer within the set of responses returned for a query. 
In cases where validation fails due to some non-DNSSEC error, the val_ac_query_more variable can be used to identify the
query where the error was encountered. 
val_ac_trust points to the next element in the chain-of-trust. Its value is NULL when a trust anchor is encountered. 
val_ac_next can be used to iterate through the list of DNS responses within the struct val_assertion_chain linked list.</t> 


        <t>
        The queries parameter in val_resolve_and_check() returns a pointer to a linked list containing the complete set 
of DNS queries that were issued while resolving and validating the 
original DNS query inclusive of the original query. This parameter 
may also be thought of as a cache of queries sent out during the 
validation process. The val_qc_status member variable for an element in this liked list returns the
status of the query: if it was answered, if there was no response or some other DNS-related value.
The on-the-wire bytes returned as the response to a query are stored as a length-value field in
val_qc_raw_response_length and val_qc_raw_response respectively.
val_qc_answer points to the digested answers created for the response and may be NULL when no responses are returned. 
val_qc_creator isused to identify which link in the chain-of-trust led to the generation of this query and is NULL for
the initial query issued by the val_resolve_and_check() method. 
val_qc_next can be used to iterate through the list of DNS queries within the struct val_query_chain linked list.
The combination of the previous two functions makes it possible to identify all queries sent out for a
particular assertion. </t> 


        <t>
The val_resolve_and_check() method internally allocates memory for the values of the results, queries and assertions 
parameters  so they must be freed by the invoking application using the
val_free_query_chain(), val_free_assertion_chain() and val_free_result() functions.</t>

        </postamble>
        </figure>

    </section> <!-- Low-level API -->

    <section title="Context Management and Validator Policy" anchor="val-context">
    <!--            ####################################### -->

      <t>
      Applications can use local policy to influence the decision 
      about when the validator must break 
      out from the process of constructing a chain-of-trust with 
      either a success or failure condition.  
      Examples of local policy elements include trust anchors for 
      different zones, untrusted algorithms for cryptographic keys and hashes, 
      acceptable clock skew for signature inception and expiration times and default 
      name servers to direct queries to, all of which may be different for different 
      applications and operation scenarios. </t>


      <t> 
      The context management and validator policy API allows an application 
	some flexibility in choosing its validation policy based on its scope of execution. </t>


      <section title="get_context">
      <figure>
      <artwork>

int get_context( const char    *label,
                 val_context_t **newcontext );
      </artwork>
      <postamble>
      <t>
      Returns a pointer to the val_context_t structure in newcontext.  
A NULL context is returned if some error was encountered. 
The application must release the memory allocated 
by the get_context() function using the free_context() interface once it is done with using it.</t>

<t> 
label identifies the particular policy to be used as the base policy for the context during validation. The policy label is a simple text string that can be used to identify the policy in the configuration file. As an example "browser" could be used as the label for a policy that defines the base policy for all web-browsers in a system.  
The ':' character in the label string is used to specify a new scope within a given policy. Thus, "mail:mozilla:browser" could be used as the identifier to refer to the mail-specific validation policy for the mozilla suite.  
A label string with the value of ":" identifies the default base policy. </t>

<t> 
The label parameter in get_context() must be uniquely defined within the configuration file. A NULL
label creates a context with the default base policy. </t> 

      </postamble>
      </figure>
      </section>

      <section title="free_context">
      <figure>
      <artwork>
void free_context( val_context_t *context );
      </artwork>
      <postamble>
      <t>
      Releases memory in the val_context_t structure previously allocated by the get_context() function.</t>
      </postamble>
      </figure>
      </section>

      <section title="switch_policy_scope">
      <figure>
      <artwork>
int switch_policy_scope( val_context_t *ctx,
                          const char    *scope );
      </artwork>
      <postamble>
      <t>
      This function allows applications to switch their current to a particular scope.  
The context supplied in ctx must not be NULL. The API only allows the context to switch its policy to a valid scope. Thus, trying to switch the policy scope to "mail:mozilla:browser" which the context was created with a base policy of "safari:browser" would result in an error. The effective policy is computed by applying the base policy for the context followed by overrides defined for all valid scopes defined in the configuration file in increasing order of specificity, up to and including the scope passed to switch_policy_scope().
A NULL label switches the context's current policy scope to its base policy. </t> 
      </postamble>
      </figure>
      </section>

      <section title="get_scopes_within_context">
      <figure>
      <artwork>
int get_scopes_within_context( val_context *ctx,
                                char        **scopes,
                                int         *count );
      </artwork>
      <postamble>
      <t>
      This function allows applications to obtain the list of policy scopes available within a given context.
The application must allocate the scopes array to be large enough to hold all available answers. 
Each element in the array must be pre-allocated to at least MAX_POLICY_ID_LENGTH. 
count is a value-result parameter that must be set to the number of elements allocated in the scopes array. 
If the size of the array is not large enough to hold all answers, the function returns -1 and *count contains 
the actual number of scopes available within the context. 0 is returned on success and *count contains 
the number of scopes. </t> 
      </postamble>
      </figure>
      </section>

      <section title="get_scope_definition">
      <figure>
      <artwork>
int get_scope_definition( val_context *ctx,
                           char        *scope,
                           char        **pol_def ); 
      </artwork>
      <postamble>
      <t>
      This function allows applications to obtain the policy definition for a given scope identifier.
The context supplied in ctx must not be NULL.</t> 
      </postamble>
      </figure>
      </section>

      <section title="set_scope_definition">
      <figure>
      <artwork>
int set_scope_definition( val_context *ctx,
                           const char  *label, 
                           char        *policy_string );
      </artwork>
      <postamble>
      <t>
      This function allows an application to modify an existing policy scope or 
define a new policy scope within a context. The context supplied in ctx must not 
be NULL. A label of NULL can be used to 
update the base policy within the context.</t> 

      </postamble>
      </figure>
      </section>


    </section> <!-- Context Management -->


   </section> <!-- Validator API -->




   <section title="IANA Considerations">
   <t> This document has no actions for IANA.</t>
   </section> <!-- IANA Considerations -->

   <section title="Security Considerations" anchor="security-considerations">
   <t>(TODO)</t>
   </section> <!-- Security Considerations -->

   <section title="Acknowledgements">
   <t>(TODO)</t>
   </section> <!-- Acknowledgements -->

   </middle>
   <back>
        <references>
            <reference anchor="refs.RFC3493">
              <front>
                <title>Basic Socket Interface Extensions for IPv6</title>
                <author initials="R." surname="Gilligan" fullname="Bob Gilligan" />
                <author initials="S." surname="Thomson" fullname="Susan Thomson" />
                <author initials="J." surname="Bound" fullname="Jim Bound" />
                <author initials="J." surname="McCann" fullname="Jack McCann" />
                <author initials="W." surname="Stevens" fullname="W. Richard Stevens" />
                <date month="February" year="2003" />
              </front>
              <seriesInfo name="RFC" value="3493" />
            </reference>
            <reference anchor="refs.RFC4033">
              <front>
                <title>DNS Security Introduction and Requirements</title>
                <author initials="R." surname="Arends" fullname="Roy Arends" />
                <author initials="R." surname="Austein" fullname="Rob Austein" />
                <author initials="M." surname="Larson" fullname="Matt Larson" />
                <author initials="D." surname="Massey" fullname="Dan Massey" />
                <author initials="S." surname="Rose" fullname="Scott Rose" />
                <date month="March" year="2005" />
              </front>
              <seriesInfo name="RFC" value="4033" />
            </reference>
            <reference anchor="refs.RFC4034">
              <front>
                <title>Resource Records for the DNS Security Extensions</title>
                <author initials="R." surname="Arends" fullname="Roy Arends" />
                <author initials="R." surname="Austein" fullname="Rob Austein" />
                <author initials="M." surname="Larson" fullname="Matt Larson" />
                <author initials="D." surname="Massey" fullname="Dan Massey" />
                <author initials="S." surname="Rose" fullname="Scott Rose" />
                <date month="March" year="2005" />
              </front>
              <seriesInfo name="RFC" value="4034" />
            </reference>
            <reference anchor="refs.RFC4035">
              <front>
                <title>Protocol Modifications for the DNS Security Extensions</title>
                <author initials="R." surname="Arends" fullname="Roy Arends" />
                <author initials="R." surname="Austein" fullname="Rob Austein" />
                <author initials="M." surname="Larson" fullname="Matt Larson" />
                <author initials="D." surname="Massey" fullname="Dan Massey" />
                <author initials="S." surname="Rose" fullname="Scott Rose" />
                <date month="March" year="2005" />
              </front>
              <seriesInfo name="RFC" value="4035" />
            </reference>
            <reference anchor="">
              <front>
                <title>(TODO)</title>
              </front>
            </reference>
        </references>
        <!-- Appendices
        <section ...>
        <section ...>
        -->
    </back>
</rfc>

<!-- last updated Feb. 1, 2006 -->

