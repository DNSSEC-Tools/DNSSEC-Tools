.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "val_query 3"
.TH val_query 3 "2006-02-08" "perl v5.8.5" "Programmer's Manual"
.SH "NAME"
val_query \- DNSSEC\-validated resolution of DNS queries
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  #include <validator.h>
.Ve
.PP
.Vb 7
\&  int val_query(const val_context_t *ctx,
\&                const char *dname,
\&                const u_int16_t class,
\&                const u_int16_t type,
\&                const u_int8_t flags,
\&                struct val_response *resp,
\&                int *resp_count)
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fB\f(BIval_query()\fB\fR function is a DNSSEC-aware substitute for \fB\f(BIres_query\fB\|(3)\fR.
It performs \s-1DNSSEC\s0 validation of \s-1DNS\s0 queries.
.PP
The \fIctx\fR parameter is the validator context and can be set to \s-1NULL\s0 for
default settings.  More information about this field can be found in
\&\fB\f(BIlibval\fB\|(3)\fR.
.PP
The \fIdname\fR parameter specifies the domain name, \fIclass\fR specifies the
\&\s-1DNS\s0 class and \fItype\fR specifies the \s-1DNS\s0 type.
.PP
The \fB\f(BIval_query()\fB\fR function returns results in the \fIresp\fR array which
encapsultes the results into the following structure:
.PP
.Vb 5
\&  struct val_response {
\&        unsigned char *response;
\&        int response_length;
\&        val_status_t val_status;
\&  };
.Ve
.PP
\&\fIresponse\fR and \fIresponse_length\fR fields are functionally similar to the
\&\fIanswer\fR and \fIanslen\fR parameters in \fB\f(BIres_query\fB\|(3)\fR.  \fIresp\fR is an array
and must be allocated by the user to be of sufficient size to hold all the
answers returned by the \s-1DNS\s0 name server.  Each element in the \fIresp\fR array
will contain an answer corresponding to a single RRSet in the \s-1DNS\s0 reply.
The \fIresponse\fR field in each \fIval_response\fR structure must also be
allocated by the user to be of sufficient size to hold an answer. 
.PP
If \s-1DNSSEC\s0 validation succeeds for a given RRSet, a value of
\&\fB\s-1VALIDATE_SUCCESS\s0\fR is returned in the \fIval_status\fR field of the
\&\fIval_response\fR structure for that RRSet. Other values are returned in case
of errors.  See \fBval_errors.h\fR for a listing of possible error codes.  The
\&\fB\f(BIp_val_error()\fB\fR function can be used to return a brief string description
of the error code.  The \fB\f(BIval_istrusted()\fB\fR function can be used to determine
if the error code represents a value which indicates that the response can
be trusted.
.PP
The number of answers actually available is returned in the \fIresp_count\fR
parameter.  In case \fIresp\fR is not large enough to hold all answers returned
from \fB\f(BIval_query()\fB\fR, it returns an error code of \fB\s-1NO_SPACE\s0\fR and
\&\fIresp_count\fR is set to the total number of answers available.  Applications
may re-query after reallocating \fIresp\fR to hold that many answers.  For
queries that are not of type \f(CW\*(C`ns_t_any\*(C'\fR it is generally sufficient to
allocate an array of three elements for the \fIresp\fR array.
.PP
The \fIflags\fR parameter controls the scope of validation and name
resolution, and the output format.  At present only one flag is
defined: \fB\s-1VAL_QUERY_MERGE_RRSETS\s0\fR.  This flag has been provided for
legacy applications that already use \fB\f(BIres_query\fB\|(3)\fR and want to
transition to \fB\f(BIval_query()\fB\fR with minimal change.  When this flag is
specified, all RRsets in the answer are merged into a single response
and returned in the first element of the \fIresp\fR array.  The response
field of this element will have a format similar to the answer
returned by \fB\f(BIres_query\fB\|(3)\fR.  The validation status will be
\&\fB\s-1VALIDATE_SUCCESS\s0\fR only if all the individual RRsets have been
successfully validated.  Otherwise, the validation status will be one
of the other error codes.  Note that if a value other than
\&\fB\s-1VALIDATE_SUCCESS\s0\fR is returned and if multiple RRsets are present in
the answer, it is not possible to know which RRset resulted in the
error status, if this flag is used.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
The \fB\f(BIval_query()\fB\fR function returns \fB\s-1NO_ERROR\s0\fR on success.  It returns
\&\fB\s-1NO_SPACE\s0\fR if the application has not allocated enough memory to hold all
results returned by the validator.  This function internally invokes
\&\fB\f(BIresolve_n_check()\fB\fR, and errors from this function may also be returned.
See \fB\f(BIlibval\fB\|(3)\fR for more details.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 5
\& #include <stdio.h>
\& #include <stdlib.h>
\& #include <strings.h>
\& #include <arpa/nameser.h>
\& #include <validator.h>
.Ve
.PP
.Vb 2
\& #define BUFLEN 8096
\& #define RESPCOUNT 3
.Ve
.PP
.Vb 12
\& int main(int argc, char *argv[])
\& {
\&          int dnssec_status = ERROR;
\&          int retval;
\&          int i;
\&          int class = ns_c_in;
\&          int type = ns_t_a;
\&          struct val_response resp[RESPCOUNT];
\&          int resp_count = RESPCOUNT;
\&          char buf0[BUFLEN];
\&          char buf1[BUFLEN];
\&          char buf2[BUFLEN];
.Ve
.PP
.Vb 4
\&          if (argc < 2) {
\&                  printf("Usage: %s <domain-name>\en", argv[0]);
\&                  exit(1);
\&          }
.Ve
.PP
.Vb 3
\&          bzero(buf0, BUFLEN);
\&          bzero(buf1, BUFLEN);
\&          bzero(buf2, BUFLEN);
.Ve
.PP
.Vb 3
\&          resp[0].response = buf0;
\&          resp[1].response = buf1;
\&          resp[2].response = buf2;
.Ve
.PP
.Vb 3
\&          resp[0].response_length = BUFLEN;
\&          resp[1].response_length = BUFLEN;
\&          resp[2].response_length = BUFLEN;
.Ve
.PP
.Vb 2
\&          retval = val_query(NULL, argv[1], class, type, 0, resp,
\&                             &resp_count);
.Ve
.PP
.Vb 6
\&          if (retval == NO_ERROR) {
\&                  for (i=0; i<resp_count; i++) {
\&                          printf("Validation Status = %d [%s]\en", resp[i].val_status,
\&                                 p_val_error(resp[i].val_status));
\&                  }
\&          }
.Ve
.PP
.Vb 2
\&          return 0;
\& }
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2004\-2006 \s-1SPARTA\s0, Inc.  All rights reserved.
See the \s-1COPYING\s0 file included with the DNSSEC-Tools package for details.
.SH "AUTHORS"
.IX Header "AUTHORS"
Abhijit Hayatnagarkar, Suresh Krishnaswamy.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fB\f(BIres_query\fB\|(3)\fR
.PP
\&\fB\f(BIget_context\fB\|(3)\fR, \fB\f(BIval_getaddrinfo\fB\|(3)\fR, \fB\f(BIval_gethostbyname\fB\|(3)\fR
.PP
\&\fB\f(BIp_val_error()\fB\fR, \fB\f(BIval_istrusted()\fB\fR
.PP
\&\fB\f(BIlibval\fB\|(3)\fR
.PP
http://dnssec\-tools.sourceforge.net
