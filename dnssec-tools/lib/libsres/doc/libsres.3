.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "libsres 3"
.TH libsres 3 "2005-08-27" "perl v5.8.3" "Programmer's Manual"
.SH "NAME"
query_send, response_rcv, get, free_name_server, free_name_servers \- send queries and receive responses from a
DNS name server.
.PP
print_response \- Display answers returned from the name server
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
#include <resolver.h>
.PP
int query_send( const char      *name,
            const u_int16_t     type,
            const u_int16_t     class,
            struct name_server  *nslist,
            int                 *trans_id);
.PP
int response_recv(int           *trans_id,
            struct name_server  **respondent,
            u_int8_t            **response,
            u_int32_t           *response_length);
.PP
int get ( const char            *name_n,
            const u_int16_t     type_h,
            const u_int16_t     class_h,
            struct name_server  *nslist,
            struct name_server  **respondent,
            u_int8_t            **response,
            u_int32_t           *response_length);
.PP
void free_name_server (struct name_server **ns);
void free_name_servers (struct name_server **ns);
.PP
void print_response (u_int8_t *response, int response_length);
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fB\f(BIquery_send()\fB\fR function can be used to send a query comprising of the
<\fIname, class, type\fR> tuple to the name servers specified in \fInslist\fR. 
\&\fItrans_id\fR provides a handle to this transaction within the libsres library.
.PP
The \fB\f(BIresponse_recv()\fB\fR function returns the answers, if available, from the
name server that responds within the transaction identified by \fItrans_id\fR. 
The response is available in \fIresponse\fR and the responding name server is 
returned in \fIrespondent\fR. The length of the response in bytes is returned 
in  \fIresponse_length\fR. 
.PP
The \fB\f(BIget()\fB\fR function provides a wrapper around the \fB\f(BIquery_send()\fB\fR and
\&\fB\f(BIresponse_recv()\fB\fR functions. It blocks until some response is received 
from some name server or the request times out. The libsres library does
not automatically send out recursive queries and referral requests are also
acceptable as valid responses.
.PP
\&\fIresponse\fR must be large enough to hold the number of bytes returned in 
\&\fIresponse_length\fR. The memory pointed to by \fI*respondent\fR is allocated 
by the libsres library and this must be free-d by the invoker using the 
\&\fB\f(BIfree_name_server()\fB\fR method. An entire list of name servers can be free-d 
using the \fB\f(BIfree_name_servers()\fB\fR method.
.PP
\&\fB\f(BIprint_response()\fB\fR provides a convenient way to display answers returned
in \fIresponse\fR by the name server.
.PP
\&\fIstruct name_server\fR is defined in resolver.h as follows.
.PP
struct name_server 
{
    u_int8_t *ns_name_n;
    void *ns_tsig_key;
    u_int32_t ns_security_options;
    u_int32_t ns_status;
    struct name_server *ns_next; 
    int ns_number_of_addresses;
    struct sockaddr ns_address[1];
.PP
};
.PP
The currently defined members of \fIstruct name_server\fR are:
.IP "\fIns_name_n\fR" 4
.IX Item "ns_name_n"
The name of the zone for which this name server is authoritative. This field
provides a convenient way for the invoker to index a list of name servers
while sending queries to different name servers, especially during a referral.
It is not made use of directly by the resolver and can be set to an empty string.
.IP "\fIns_tsig_key\fR" 4
.IX Item "ns_tsig_key"
The tsig key that should be used to protect messsages sent to this name server.
This field is currently un\-used.
.IP "\fIns_security_options\fR" 4
.IX Item "ns_security_options"
The security options for the zone. This can be set to either \s-1ZONE_USE_NOTHING\s0 or
\&\s-1ZONE_USE_TSIG\s0.
.IP "\fIns_status\fR" 4
.IX Item "ns_status"
The status of the zone. This field is used internally by the invoker to maintain 
properties of the zone. Currently defined values for this field are 
\&\s-1SR_ZI_STATUS_UNSET\s0, \s-1SR_ZI_STATUS_PERMANENT\s0 and \s-1SR_ZI_STATUS_LEARNED\s0.
.IP "\fIns_next\fR" 4
.IX Item "ns_next"
The address of the next name server in the list.
.IP "\fIns_number_of_addresses\fR" 4
.IX Item "ns_number_of_addresses"
The number of elements in the array \fIns_addresses\fR. This field is
currently unused.
.IP "\fIns_addresses\fR" 4
.IX Item "ns_addresses"
The \s-1IP\s0 address of the name server. Currently, only IPv4 addresses can be stored. 
.SH "OTHER SYMBOLS EXPORTED"
.IX Header "OTHER SYMBOLS EXPORTED"
The libsres library also exports the following \s-1BIND\s0 symbols: 
    _\|_ns_name_unpack
    _\|_ns_name_ntop
    _\|_ns_name_pton
    _\|_p_type
    _\|_p_class
    _\|_p_section
.PP
Documentation for these symbols can be found in the \s-1BIND\s0 
sources/documentation manuals.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
.IP "\s-1SR_UNSET\s0" 4
.IX Item "SR_UNSET"
No error.
.IP "\s-1SR_CALL_ERROR\s0" 4
.IX Item "SR_CALL_ERROR"
An invalid parameter was passed to the \fB\f(BIquery_send()\fB\fR, 
\&\fB\f(BIresponse_recv()\fB\fR or \fB\f(BIget()\fB\fR method.
.IP "\s-1SR_MEMORY_ERROR\s0" 4
.IX Item "SR_MEMORY_ERROR"
Memory allocation failed.
.IP "\s-1SR_MKQUERY_INTERNAL_ERROR\s0" 4
.IX Item "SR_MKQUERY_INTERNAL_ERROR"
Some internal error was encountered while trying to construct a 
query message.
.IP "\s-1SR_TSIG_INTERNAL_ERROR\s0" 4
.IX Item "SR_TSIG_INTERNAL_ERROR"
Some internal error was encountered while trying to construct a 
signed \s-1TSIG\s0 message.
.IP "\s-1SR_SEND_INTERNAL_ERROR\s0" 4
.IX Item "SR_SEND_INTERNAL_ERROR"
Some internal error was encountered while trying to send the 
message to the name server(s).
.IP "\s-1SR_NO_ANSWER_YET\s0" 4
.IX Item "SR_NO_ANSWER_YET"
No answer currently available; the query is still active.
.IP "\s-1SR_NO_ANSWER\s0" 4
.IX Item "SR_NO_ANSWER"
No answers were received from any name server.
.IP "\s-1SR_RCV_INTERNAL_ERROR\s0" 4
.IX Item "SR_RCV_INTERNAL_ERROR"
Some internal error was encountered while trying to receive 
responses from some name server.
.IP "\s-1SR_WRONG_ANSWER\s0" 4
.IX Item "SR_WRONG_ANSWER"
The header bits did not correctly identify the message as a
response.
.IP "\s-1SR_HEADER_BADSIZE\s0" 4
.IX Item "SR_HEADER_BADSIZE"
The length and count of records in the header was incorrect.
.IP "\s-1SR_TSIG_ERROR\s0" 4
.IX Item "SR_TSIG_ERROR"
\&\s-1TSIG\s0 validation on the response message failed.
.IP "\s-1SR_NXDOMAIN\s0" 4
.IX Item "SR_NXDOMAIN"
The queried name did not exist.
.IP "\s-1SR_FORMERR\s0" 4
.IX Item "SR_FORMERR"
The name server was not able to parse the query message.
.IP "\s-1SR_SERVFAIL\s0" 4
.IX Item "SR_SERVFAIL"
The name server was not reachable. 
.IP "\s-1SR_NOTIMPL\s0" 4
.IX Item "SR_NOTIMPL"
A particular functionality is not yet implemented.
.IP "\s-1SR_REFUSED\s0" 4
.IX Item "SR_REFUSED"
The name server refused to answer this query.
.IP "\s-1SR_GENERIC_FAILURE\s0" 4
.IX Item "SR_GENERIC_FAILURE"
Other failure returned by the name server and reflected in the
returned message \s-1RCODE\s0.
.IP "\s-1SR_EDNS_VERSION_ERROR\s0" 4
.IX Item "SR_EDNS_VERSION_ERROR"
Wrong \s-1EDNS\s0 version used. Not implemented.
.IP "\s-1SR_UNSUPP_ENDS0_LABEL\s0" 4
.IX Item "SR_UNSUPP_ENDS0_LABEL"
Unsupported \s-1EDNS\s0 version used. Not implemented.
.IP "\s-1SR_SUSPICIOUS_BIT\s0" 4
.IX Item "SR_SUSPICIOUS_BIT"
Some bit in the header was set funny. Not implemented.
.IP "\s-1SR_NAME_EXPANSION_FAILURE\s0" 4
.IX Item "SR_NAME_EXPANSION_FAILURE"
Could not expand name from wire format. Not used.
.SH "CURRENT STATUS"
.IX Header "CURRENT STATUS"
There is currently no support for IPv6. There is limited support for 
specifying resolver policy; members of the \fIstruct name_server\fR are 
still subject to change. 
The library is not thread\-safe. 
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2004\-2005 \s-1SPARTA\s0, Inc.  All rights reserved.
See the \s-1COPYING\s0 file included with the dnssec-tools package for details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIlibval\fR\|(3)
.PP
http://dnssec\-tools.sourceforge.net
