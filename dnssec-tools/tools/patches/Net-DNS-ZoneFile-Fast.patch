--- Fast.pm.~1~	2004-04-15 14:17:26.000000000 -0700
+++ Fast.pm	2005-04-19 20:38:58.000000000 -0700
@@ -15,6 +15,7 @@
 use vars qw($VERSION);
 use IO::File;
 use Net::DNS;
+use MIME::Base64;
 
 $VERSION = '0.5';
 
@@ -35,9 +36,15 @@
 my $ttl;
 my @zone;
 my $soa;
+my $rrsig;
+my $dnskey;
+my $ds;
 my $on_error;
 my $quiet;
 my $soft_errors;
+my $fh;
+my @fhs;
+my @lns;
 
 sub parse
 {
@@ -59,9 +66,10 @@
 		if (defined $param{text}) {
 			$text = $param{text};
 		} elsif (defined $param{fh}) {
+		    $fh = $param{fh};
 		} elsif (defined $param{file}) {
-			$param{fh} = IO::File->new($param{file}, "r");
-			error("cannot open $param{file}: $!") unless defined $param{fh};
+			$fh = IO::File->new($param{file}, "r");
+			error("cannot open $param{file}: $!") unless defined $fh;
 		} else {
 			error("want zone text, or file, or fh");
 		}
@@ -79,12 +87,15 @@
 	$soft_errors = $param{soft_errors};
 
 	eval {
-		if ($param{fh}) {
-			my $fh = $param{fh};
+		if ($fh) {
+		    do {
 			while ($_ = readline($fh)) {
-				$ln++;
-				$parse->();
+			    $ln++;
+			    $parse->();
 			}
+			$fh = shift @fhs;
+			$ln = shift @lns;
+		    } while ($fh);
 		} else {
 			my @text = split "\n", $text;
 			for (@text) {
@@ -149,9 +160,21 @@
 
 sub parse_line
 {
-	if (/^\$include\b/ig) {
-		error("include niy");
+	if (/^\$include[ \t]+/ig) {
+	    if (!/\G[\"\']*([^\s\'\"]+)[\"\']*/igc) {
+		error("no include file specified $_");
+		return;
+	    }
+	    if (! -f $1) {
+		error("could not find file $1");
 		return;
+	    }
+	    unshift @fhs, $fh;
+	    unshift @lns, $ln;
+	    $fh = IO::File->new($1, "r");
+	    $ln = 0;
+	    error("cannot open include file $1: $!") unless defined $fh;
+	    return;
 	} elsif (/^\$origin[ \t]+/ig) {
 		if (/\G($pat_maybefullname)$pat_skip$/gc) {
 			my $name = $1;
@@ -526,6 +549,108 @@
 		} else {
 			error("bad SRV data");
 		}
+	} elsif (/\G(rrsig)[ \t]+/igc) {
+	    if (!/\G(\w+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+/gc) {
+		error("bad RRSIG data 1");
+	    }
+	    $rrsig = {
+		      first     => 1,
+		      Line      => $ln,
+		      name      => $domain,
+		      type      => "RRSIG",
+		      class     => "IN",
+		      ttl       => $ttl,
+		      typecovered => $1,
+		      algorithm => $2,
+		      labels    => $3,
+		      orgttl    => $4,
+		      sigexpiration => $5
+		     };
+	    if (/\G\(\s*$/gc) {
+		# multi-line
+		$parse = \&parse_rrsig;
+	    } elsif (/\G(\d+)\s+(\d+)\s+($pat_maybefullname)\s+([^=]+=)\s*/gc) {
+		# single-line
+		$rrsig->{'siginceptation'} = $1;
+		$rrsig->{'keytag'} = $2;
+		$rrsig->{'signame'} = $3;
+		$rrsig->{'sig'} = $4;
+		push @zone, $rrsig;
+		$rrsig = undef;
+	    } else {
+		error("bad RRSIG data 2");
+	    }
+	} elsif (/\G(dnskey)[ \t]+/igc) {
+		if (!/\G(\d+)\s+(\d+)\s+(\d+)\s+/gc) {
+		    error("bad DNSKEY data 1");
+		}
+		$dnskey = {
+			   first     => 1,
+			   Line      => $ln,
+			   name      => $domain,
+			   ttl       => $ttl,
+			   class     => "IN",
+			   type      => "DNSKEY",
+			   flags     => $1,
+			   protocol  => $2,
+			   algorithm => $3
+			  };
+		if (/\G\(\s*$/gc) {
+		    # multi-line
+		    $parse = \&parse_dnskey;
+		} elsif (/\G(.*\S)\s*$/) {
+		    # single-line
+		    $dnskey->{'key'} .= $1;
+		    $dnskey->{'key'} =~ s/\s//g;
+		    $dnskey->{'keybin'} = decode_base64($dnskey->{'key'});
+		    push @zone, $dnskey;
+		    $dnskey = undef;
+		} else {
+		    error("bad DNSKEY data 2");
+		}
+	} elsif (/\G(ds)[ \t]+/igc) {
+		if (!/\G(\d+)\s+(\d+)\s+(\d+)\s+/gc) {
+		    error("bad DS data 1");
+		}
+		$ds = {
+		       Line      => $ln,
+		       name      => $domain,
+		       class     => "IN",
+		       ttl       => $ttl,
+		       type      => "DS",
+		       keytag    => $1,
+		       algorithm => $2,
+		       digtype   => $3,
+		      };
+		if (/\G\(\s*$/gc) {
+		    # multi-line
+		    $parse = \&parse_ds;
+		} elsif (/\G(.*\S)\s*$/) {
+		    # single line
+		    $ds->{'digest'} .= $1;
+		    $ds->{'digest'} = lc($ds->{'digest'});
+		    $ds->{'digestbin'} = pack("H*", $ds->{'digest'});
+		    push @zone, $ds;
+		    $ds = undef;
+		} else {
+		    error("bad DS data");
+		}
+	} elsif (/\G(nsec)[ \t]+/igc) {
+		if (/\G\s*($pat_maybefullname)\s+(.*)$pat_skip$/gc) {
+		    # XXX: set the typebm field ourselves?
+		    push @zone, 
+		      {
+		       Line      => $ln,
+		       name      => $domain,
+		       class     => "IN",
+		       ttl       => $ttl,
+		       type      => "NSEC",
+		       nxtdname  => lc($1),
+		       typelist  => $2
+		      };
+		} else {
+			error("bad NSEC data");
+		}
 	} elsif (/\G(rp)[ \t]+/igc) {
 		my $mbox;
 		if (/\G($pat_maybefullname)[ \t]+/gc) {
@@ -562,6 +687,8 @@
 			mbox     => $mbox,
 			txtdname => $txtdname,
 		};
+	} elsif (/\Gany\s+tsig.*$/igc) {
+	    # XXX ignore tsigs
 	} else {
 		error("unrecognized type");
 	}
@@ -634,6 +761,90 @@
 	return $v;
 }
 
+sub parse_rrsig
+{
+    # got more data
+    if ($rrsig->{'first'}) {
+	delete $rrsig->{'first'};
+	if (/\G\s*(\d+)\s+(\d+)\s+($pat_maybefullname)/gc) {
+	    $rrsig->{'siginceptation'} = $1;
+	    $rrsig->{'keytag'} = $2;
+	    $rrsig->{'signame'} = $3;
+	} else {
+	    error("bad rrsig second line");
+	}
+    } else {
+	if (/\)\s*$/) {
+	    if (/\G\s*(\S+)\s*\)\s*$/gc) {
+		$rrsig->{'sig'} .= $1;
+		# we're done
+		$parse = \&parse_line;
+
+		push @zone, $rrsig;
+		$rrsig = undef;
+	    } else {
+		error("bad rrsig last line");
+	    }
+	} else {
+	    if (/\G\s*(\S+)\s*$/gc) {
+		$rrsig->{'sig'} .= $1;
+	    } else {
+		error("bad rrsig remaining lines");
+	    }
+	}
+    }
+}
+
+sub parse_dnskey
+{
+    # got more data?
+    if (/\)\s*;.*$/) {
+	if (/\G\s*(\S*)\s*\)\s*;.*$/gc) {
+	    $dnskey->{'key'} .= $1;
+	    # we're done
+	    $parse = \&parse_line;
+
+	    $dnskey->{'keybin'} = decode_base64($dnskey->{'key'});
+	    push @zone, $dnskey;
+	    $dnskey = undef;
+	} else {
+	    error("bad dnskey last line");
+	}
+    } else {
+	if (/\G\s*(\S+)\s*$/gc) {
+	    $dnskey->{'key'} .= $1;
+	} else {
+	    error("bad dnskey remaining lines");
+	}
+    }
+}
+
+sub parse_ds
+{
+    # got more data
+    if (/\)\s*$/) {
+	if (/\G\s*(\S*)\s*\)\s*$/gc) {
+	    $ds->{'digest'} .= $1;
+	    $ds->{'digest'} = lc($ds->{'digest'});
+
+	    # we're done
+	    $parse = \&parse_line;
+
+	    $ds->{'digestbin'} = pack("H*",$ds->{'digest'});
+	    push @zone, $ds;
+	    $ds = undef;
+	} else {
+	    error("bad ds last line");
+	}
+    } else {
+	if (/\G\s*(\S+)\s*$/gc) {
+	    $ds->{'digest'} .= $1;
+	} else {
+	    error("bad ds remaining lines");
+	}
+    }
+}
+
 sub parse_soa_number
 {
 	error("parse_soa_number: internal error, no \$soa") unless $soa;
@@ -774,6 +985,8 @@
 
 =item B<$TTL> directive
 
+=item B<$INCLUDE> directive (only while processing files or filehandles)
+
 =item B<A> records
 
 =item B<AAAA> records
@@ -798,6 +1011,16 @@
 
 =item B<TXT> records
 
+=item B<RRSIG> records
+
+=item B<DNSKEY> records
+
+=item B<DS> records
+
+=item B<NSEC> records
+
+=item B<RRSIG> records
+
 =back
 
 =head2 Non-standard third-party modules
