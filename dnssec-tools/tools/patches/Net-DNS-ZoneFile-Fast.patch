17a18
> use MIME::Base64;
37a39,41
> my $rrsig;
> my $dnskey;
> my $ds;
40a45,47
> my $fh;
> my @fhs;
> my @lns;
61a69
> 		    $fh = $param{fh};
63,64c71,72
< 			$param{fh} = IO::File->new($param{file}, "r");
< 			error("cannot open $param{file}: $!") unless defined $param{fh};
---
> 			$fh = IO::File->new($param{file}, "r");
> 			error("cannot open $param{file}: $!") unless defined $fh;
82,83c90,91
< 		if ($param{fh}) {
< 			my $fh = $param{fh};
---
> 		if ($fh) {
> 		    do {
85,86c93,94
< 				$ln++;
< 				$parse->();
---
> 			    $ln++;
> 			    $parse->();
87a96,98
> 			$fh = shift @fhs;
> 			$ln = shift @lns;
> 		    } while ($fh);
133c144,148
< 		push @r, Net::DNS::RR->new_from_hash(%$z);
---
> 		my $newrec = Net::DNS::RR->new_from_hash(%$z);
> 		if ($newrec->{'type'} eq 'DNSKEY') {
> 		    $newrec->setkeytag;
> 		}
> 		push @r, $newrec;
152,153c167,169
< 	if (/^\$include\b/ig) {
< 		error("include niy");
---
> 	if (/^\$include[ \t]+/ig) {
> 	    if (!/\G[\"\']*([^\s\'\"]+)[\"\']*/igc) {
> 		error("no include file specified $_");
154a171,181
> 	    }
> 	    if (! -f $1) {
> 		error("could not find file $1");
> 		return;
> 	    }
> 	    unshift @fhs, $fh;
> 	    unshift @lns, $ln;
> 	    $fh = IO::File->new($1, "r");
> 	    $ln = 0;
> 	    error("cannot open include file $1: $!") unless defined $fh;
> 	    return;
276a304,324
> 	} elsif (/\G(afsdb)[ \t]+/igc) {
> 	        my $subtype;
> 		if (/\G(\d+)[ \t]+/gc) {
> 		        $subtype = $1;
> 		} else {
> 			error("bad subtype in AFSDB");
> 		}
> 		if (/\G($pat_maybefullname)$pat_skip$/gc) {
> 		    my $name = $1;
> 		    $name = "$name$origin" unless $name =~ /\.$/;
> 		    chop $name;
> 		    push @zone, {
> 				 Line       => $ln,
> 				 name       => $domain,
> 				 type       => "AFSDB",
> 				 ttl        => $ttl,
> 				 class      => "IN",
> 				 subtype    => $subtype,
> 				 hostname   => $name,
> 				};
> 		}
528a577,681
> 	} elsif (/\G(rrsig)[ \t]+/igc) {
> 	    if (!/\G(\w+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+/gc) {
> 		error("bad RRSIG data 1");
> 	    }
> 	    $rrsig = {
> 		      first     => 1,
> 		      Line      => $ln,
> 		      name      => $domain,
> 		      type      => "RRSIG",
> 		      class     => "IN",
> 		      ttl       => $ttl,
> 		      typecovered => $1,
> 		      algorithm => $2,
> 		      labels    => $3,
> 		      orgttl    => $4,
> 		      sigexpiration => $5
> 		     };
> 	    if (/\G\(\s*$/gc) {
> 		# multi-line
> 		$parse = \&parse_rrsig;
> 	    } elsif (/\G(\d+)\s+(\d+)\s+($pat_maybefullname)\s+([^=]+=)\s*/gc) {
> 		# single-line
> 		$rrsig->{'siginceptation'} = $1;
> 		$rrsig->{'keytag'} = $2;
> 		$rrsig->{'signame'} = $3;
> 		$rrsig->{'sig'} = $4;
> 		$rrsig->{'sigbin'} = decode_base64($rrsig->{'sig'});
> 		push @zone, $rrsig;
> 		$rrsig = undef;
> 	    } else {
> 		error("bad RRSIG data 2");
> 	    }
> 	} elsif (/\G(dnskey)[ \t]+/igc) {
> 		if (!/\G(\d+)\s+(\d+)\s+(\d+)\s+/gc) {
> 		    error("bad DNSKEY data 1");
> 		}
> 		$dnskey = {
> 			   first     => 1,
> 			   Line      => $ln,
> 			   name      => $domain,
> 			   ttl       => $ttl,
> 			   class     => "IN",
> 			   type      => "DNSKEY",
> 			   flags     => $1,
> 			   protocol  => $2,
> 			   algorithm => $3
> 			  };
> 		if (/\G\(\s*$/gc) {
> 		    # multi-line
> 		    $parse = \&parse_dnskey;
> 		} elsif (/\G(.*\S)\s*$/) {
> 		    # single-line
> 		    $dnskey->{'key'} .= $1;
> 		    $dnskey->{'key'} =~ s/\s//g;
> 		    $dnskey->{'keybin'} = decode_base64($dnskey->{'key'});
> 		    push @zone, $dnskey;
> 		    $dnskey = undef;
> 		} else {
> 		    error("bad DNSKEY data 2");
> 		}
> 	} elsif (/\G(ds)[ \t]+/igc) {
> 		if (!/\G(\d+)\s+(\d+)\s+(\d+)\s+/gc) {
> 		    error("bad DS data 1");
> 		}
> 		$ds = {
> 		       Line      => $ln,
> 		       name      => $domain,
> 		       class     => "IN",
> 		       ttl       => $ttl,
> 		       type      => "DS",
> 		       keytag    => $1,
> 		       algorithm => $2,
> 		       digtype   => $3,
> 		      };
> 		if (/\G\(\s*$/gc) {
> 		    # multi-line
> 		    $parse = \&parse_ds;
> 		} elsif (/\G(.*\S)\s*$/) {
> 		    # single line
> 		    $ds->{'digest'} .= $1;
> 		    $ds->{'digest'} = lc($ds->{'digest'});
> 		    $ds->{'digestbin'} = pack("H*", $ds->{'digest'});
> 		    push @zone, $ds;
> 		    $ds = undef;
> 		} else {
> 		    error("bad DS data");
> 		}
> 	} elsif (/\G(nsec)[ \t]+/igc) {
> 		if (/\G\s*($pat_maybefullname)\s+(.*)$pat_skip$/gc) {
> 		    # XXX: set the typebm field ourselves?
> 		    push @zone, 
> 		      {
> 		       Line      => $ln,
> 		       name      => $domain,
> 		       class     => "IN",
> 		       ttl       => $ttl,
> 		       type      => "NSEC",
> 		       nxtdname  => lc($1),
> 		       typelist  => $2,
> 		       typebm    =>
> 		       Net::DNS::RR::NSEC::_typestr2typebm(split(/\s+/,$2)),
> 		      };
> 		} else {
> 			error("bad NSEC data");
> 		}
564a718,719
> 	} elsif (/\Gany\s+tsig.*$/igc) {
> 	    # XXX ignore tsigs
636a792,876
> sub parse_rrsig
> {
>     # got more data
>     if ($rrsig->{'first'}) {
> 	delete $rrsig->{'first'};
> 	if (/\G\s*(\d+)\s+(\d+)\s+($pat_maybefullname)/gc) {
> 	    $rrsig->{'siginceptation'} = $1;
> 	    $rrsig->{'keytag'} = $2;
> 	    $rrsig->{'signame'} = $3;
> 	} else {
> 	    error("bad rrsig second line");
> 	}
>     } else {
> 	if (/\)\s*$/) {
> 	    if (/\G\s*(\S+)\s*\)\s*$/gc) {
> 		$rrsig->{'sig'} .= $1;
> 		$rrsig->{'sigbin'} = decode_base64($rrsig->{'sig'});
> 		# we're done
> 		$parse = \&parse_line;
> 
> 		push @zone, $rrsig;
> 		$rrsig = undef;
> 	    } else {
> 		error("bad rrsig last line");
> 	    }
> 	} else {
> 	    if (/\G\s*(\S+)\s*$/gc) {
> 		$rrsig->{'sig'} .= $1;
> 	    } else {
> 		error("bad rrsig remaining lines");
> 	    }
> 	}
>     }
> }
> 
> sub parse_dnskey
> {
>     # got more data?
>     if (/\)\s*;.*$/) {
> 	if (/\G\s*(\S*)\s*\)\s*;.*$/gc) {
> 	    $dnskey->{'key'} .= $1;
> 	    # we're done
> 	    $parse = \&parse_line;
> 
> 	    $dnskey->{'keybin'} = decode_base64($dnskey->{'key'});
> 	    push @zone, $dnskey;
> 	    $dnskey = undef;
> 	} else {
> 	    error("bad dnskey last line");
> 	}
>     } else {
> 	if (/\G\s*(\S+)\s*$/gc) {
> 	    $dnskey->{'key'} .= $1;
> 	} else {
> 	    error("bad dnskey remaining lines");
> 	}
>     }
> }
> 
> sub parse_ds
> {
>     # got more data
>     if (/\)\s*$/) {
> 	if (/\G\s*(\S*)\s*\)\s*$/gc) {
> 	    $ds->{'digest'} .= $1;
> 	    $ds->{'digest'} = lc($ds->{'digest'});
> 
> 	    # we're done
> 	    $parse = \&parse_line;
> 
> 	    $ds->{'digestbin'} = pack("H*",$ds->{'digest'});
> 	    push @zone, $ds;
> 	    $ds = undef;
> 	} else {
> 	    error("bad ds last line");
> 	}
>     } else {
> 	if (/\G\s*(\S+)\s*$/gc) {
> 	    $ds->{'digest'} .= $1;
> 	} else {
> 	    error("bad ds remaining lines");
> 	}
>     }
> }
> 
776a1017,1018
> =item B<$INCLUDE> directive (only while processing files or filehandles)
> 
800a1043,1052
> =item B<RRSIG> records
> 
> =item B<DNSKEY> records
> 
> =item B<DS> records
> 
> =item B<NSEC> records
> 
> =item B<RRSIG> records
> 
