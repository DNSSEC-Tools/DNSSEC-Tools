#!/usr/bin/perl

use Net::DNS::ZoneFile::Fast;
use GraphViz;
use Getopt::Std;
use Data::Dumper;
use strict;

my %opts;
my %nodes;
my %rtypes;
my %edges;
my %edgesonce;
my %opts = ( o => 'map.png', l => 'neato');
my ($zfile, $dname, $from, $to, $color);
my $seccolor = "green2";

getopts("Rgro:l:s:i:t:h",\%opts);

usage() if (exists($opts{'h'}));

my %reccolors =
  (
   CNAME => '.2275,.5412,1',
   NS => '.0510,.4196,1',
   root => '.5765,.6902,1',
   default => ".5137,.3804,1"
  );

my %edgeparameters =
  (
#   CNAME => '.2275,.5412,1',
   CNAME => {color => 'green3'},
   NSEC => {color => 'brown', style => 'dashed'},
   NS => {style => 'bold'},
   DS => {color => $seccolor},
   default => {color => "black"},
  );

# must be ordered by priority of importance in the results
my @edgetypes = qw(CNAME NSEC NS DS);
my $edgecount = 1;
my %edgetypes;
map { $edgetypes{$_} = $edgecount++; } @edgetypes;


#
# figure out which record types to ignore
#
my %skiprecords;

if ($opts{'s'}) {
    my @recs = split(/\s*,\s*/,$opts{'s'});
    map { $skiprecords{uc($_)} = 1 } @recs;
} else {
    %skiprecords = ('NSEC' => 1, 'RRSIG' => 1);
}

#
# optionall print specific type data
#
my @labtypes;
if ($opts{'t'}) {
    my @labtypes = split(/\s*,\s*/,$opts{'t'});
    map { $_ = uc($_) } @labtypes;
}


my $g = GraphViz->new(layout => $opts{'l'},
		      node => {'fontsize' => 10},
		      no_overlap => 1,
		     );

while ($#ARGV > -1) {

    $zfile = shift;
    $dname = shift;

    my $rrset = Net::DNS::ZoneFile::Fast::parse(file => $zfile,
						origin => "$dname.",
						soft_errors => 1,
						on_error => \&my_err);

    #
    # collect record types for each node
    #
    foreach my $rr (@$rrset) {
	# collect record types
	$rtypes{$rr->name}{$rr->type} = $rr->string;
    }

    #
    # add the root domain name
    #
    add_once($g, "$dname",
	     style => 'filled', fillcolor => $reccolors{'root'});

    #
    # for each node, add it and any necessary lines
    #
    foreach my $rr (@$rrset) {
#	    print $rr->string, "\n";
#	    print "  ",join(" -> ", $rr->name, $rr->class, $rr->type),"\n";
	next if ($opts{'i'} && $rr->name =~ /$opts{'i'}/);
	next if ($skiprecords{$rr->type});
	my $name = $rr->name;

	#
	# add an edge from either:
	#     - the record name to what it points to if CNAME or NSEC
	#     - else the subdomain to the record name
	#
	if ($rr->type eq 'CNAME') {
	    $from = $name;
	    $to = $rr->cname;
	} elsif ($rr->type eq 'NSEC' && $rr->nxtdname) {
	    $from = $name;
	    $to = $rr->nxtdname;
	    $to =~ s/\.$//;
	} else {
	    $from = $dname;
	    $to = $name;
	}

	#
	# add the FROM node
	#
	add_once($g, $from,
		 label => get_label($from),
		 style => 'filled', fillcolor => get_color($from));

	#
	# create the TO node
	#
	add_once($g, $to, label => get_label($to), style => 'filled',
		 fillcolor => get_color($to));

	#
	# add the edge (line)
	#
	do_edge($from, $to, $rr->type);

	#
	# color edges of signed nodes different
	#
	if ($rr->type eq 'RRSIG') {
	    $g->add_node($to, color => $seccolor);
	}

    }
}

#
# add edges
#
my ($k, $v);
foreach my $e1 (keys(%edges)) {
    foreach my $e2 (keys(%{$edges{$e1}})) {
	my %parms;
	foreach my $et (@{$edges{$e1}{$e2}}) {
	    next if (!$et);
#	    print "$e1 $e2 -> $et\n";
	    while (($k, $v) = each %{$edgeparameters{$et}}) {
		$parms{$k} = $v;
	    }
	}
#	print " ... ", join(",", %parms),"\n";
	$g->add_edge($e1, $e2, %parms);
    }
}

open (O, ">" . $opts{'o'});
print O $g->as_png;
close(O);

sub my_err {
    print "error: ", join(",",@_), "\n";
    #    die join(",",@_);
}

sub add_once {
    my ($g, $node, @opts) = @_;
    if ($opts{'g'}) {
	push @opts, cluster => $dname;
    }
    if (!$nodes{$node}) {
	$g->add_node($node, @opts);
	$nodes{$node} = 1;
    }
}

sub do_edge {
    my ($to, $from, $type) = @_;
    # pick the highest priority edge type
    $edges{$to}{$from}[$edgetypes{$type}] = $type;
}

sub add_edge_once {
    my ($g, $node1, $node2, @opts) = @_;

    add_once($g, $node1);
    add_once($g, $node2);

    if (!$edgesonce{$node1}{$node2}) {
	$g->add_edge($node1, $node2, @opts);
	$edgesonce{$node1}{$node2} = 1;
    }
}

sub get_label {
    my $name = $_[0];
    my $label = $_[0];
    $label =~ s/\.$dname$//;
    if ($opts{'r'}) {
	$label .= "\n" . join(" ",sort keys(%{$rtypes{$name}}));
    }
    if ($#labtypes > -1) {
	foreach my $l (@labtypes) {
	    $label .= $rtypes{$name}{$l};
	}
    }
    return $label;
}

sub get_color {
    my ($name) = @_;
    if ($rtypes{$name}{'CNAME'}) {
	return $reccolors{'CNAME'};
    } elsif ($rtypes{$name}{'NS'}) {
	return $reccolors{'NS'};
    } elsif ($rtypes{$name}{'DS'}) {
	return $reccolors{'NS'};
    } elsif ($rtypes{$name}{'SOA'}) {
	return $reccolors{'root'};
    } else {
	return $reccolors{'default'};
    }
}

sub usage {
    print "
$0 [-h] [-r] [-R] [-o MAP.PNG] [-l (neato|dot|twopi)] [-s SKIPRECORDS]
  [-i IGNOREREGXP] [-t TYPEINFO] ZONEFILE ZONENAME [ZONEFILE ZONENAME...]

";
    exit;
}
