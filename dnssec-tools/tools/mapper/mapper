#!/usr/bin/perl

use Net::DNS::ZoneFile::Fast;
use GraphViz;
use Getopt::Std;
use Data::Dumper;
use strict;

my %opts;
my %nodes;
my %nodesonce;
my %rtypes;
my %edges;
my %edgesonce;
my %edgelabels;
my %extras;
my %opts = ( o => 'map.png', l => 'neato', w => 7*24*60*60);
my ($zfile, $dname, $from, $to, $color);
my $seccolor = "green2";
my %dnames;

my $time = time();

getopts("Rgro:l:s:i:t:hL",\%opts);

usage() if (exists($opts{'h'}));

my %edgeparameters =
  (
#   CNAME => '.2275,.5412,1',
   CNAME => {color => '.9875,.8412,1'},
   NSEC => {color => 'brown', style => 'dashed'},
   NS => {style => 'bold'},
   RRSIG => { color => 'green4' },
   DS => {color => $seccolor},
   default => {color => "black"},
  );

# must be ordered by priority of importance in the results
my @edgetypes = qw(CNAME RRSIG NSEC NS DS);
my $edgecount = 1;
my %edgetypes;
map { $edgetypes{$_} = $edgecount++; } @edgetypes;

my %nodeparameters =
  (
   CNAME => { fillcolor => '.9875,.4,1' },
   NS => { fillcolor => '.0510,.4196,1' },
   RRSIG => { color => $seccolor },
   RRSIGWARN => { color => 'yellow3', style => 'bold' },
   RRSIGERR => { color => 'red', style => 'bold' },
#   RRSIGWARN => { fontcolor => 'yellow3' },
#   RRSIGERR => { fontcolor => 'red' },
   AAAA => { fillcolor => ".2,.4,1" },
   MX => { fillcolor => ".8,.4,1" },
   default => { fillcolor => ".5137,.3804,1" },
   root => { fillcolor => '.5765,.6902,1'},
  );

# must be ordered by priority of importance in the results
my @nodetypes = qw(AAAA MX NS CNAME RRSIG RRSIGWARN RRSIGERR root);
my $nodecount = 1;
my %nodetypes;
map { $nodetypes{$_} = $nodecount++; } @nodetypes;


#
# figure out which record types to ignore
#
my %skiprecords;

if ($opts{'s'}) {
    my @recs = split(/\s*,\s*/,$opts{'s'});
    map { $skiprecords{uc($_)} = 1 } @recs;
} else {
    %skiprecords = ('NSEC' => 1, 'RRSIG' => 1);
}

#
# optionall print specific type data
#
my @labtypes;
if ($opts{'t'}) {
    my @labtypes = split(/\s*,\s*/,$opts{'t'});
    map { $_ = uc($_) } @labtypes;
}


my $g = GraphViz->new(layout => $opts{'l'},
		      node => {'fontsize' => 10},
		      edge => {'fontsize' => 10},
		      no_overlap => 1,
		     );

while ($#ARGV > -1) {

    $zfile = shift;
    $dname = shift;

    print "loading file $zfile\n";

    my $rrset = Net::DNS::ZoneFile::Fast::parse(file => $zfile,
						origin => "$dname.",
						soft_errors => 1,
						on_error => \&my_err);
    print "loaded file $zfile\n";

    #
    # collect record types for each node
    #
    foreach my $rr (@$rrset) {
	# collect record types
	$rtypes{$rr->name}{$rr->type} = $rr->string;
    }

    #
    # add the root domain name
    #
    do_node($dname, 'root');

    #
    # for each node, add it and any necessary lines
    #
    foreach my $rr (@$rrset) {
#	    print $rr->string, "\n";
#	    print "  ",join(" -> ", $rr->name, $rr->class, $rr->type),"\n";
	next if ($opts{'i'} && $rr->name =~ /$opts{'i'}/);
	next if ($skiprecords{$rr->type});
	my $name = $rr->name;

	#
	# add an edge from either:
	#     - the record name to what it points to if CNAME or NSEC
	#     - else the subdomain to the record name
	#
	if ($rr->type eq 'CNAME') {
	    $from = $name;
	    $to = $rr->cname;
	    do_node($from, $rr->type);
	} elsif ($rr->type eq 'MX') {
	    $from = $dname;
	    $to = $rr->exchange;
	    do_node($to, $rr->type);
	} elsif ($rr->type eq 'NSEC' && $rr->nxtdname) {
	    $from = $name;
	    $to = $rr->nxtdname;
	    $to =~ s/\.$//;
	} else {
	    $from = $dname;
	    $to = $name;
	    do_node($to, $rr->type);
	}

	if ($rr->type eq 'RRSIG') {
	    use Date::Parse;
	    my $date = $rr->sigexpiration;
	    $date =~ s/(....)(..)(..)(..)(..)(..)/$2-$3-$1 $4:$5:$6/;
	    my $extime = str2time($date);
	    if ($extime < $time) {
		print "error: $to\n";
		do_node($to, 'RRSIGERR');
	    } elsif ($extime - $time < $opts{'w'}) {
		print "warn: $to\n";
		my $days = int(($extime-$time)/60/60/24);
		my $hours = int(($extime-$time-$days*60*60*24)/60/60);
		do_node($to, 'RRSIGWARN',
			$rr->typecovered . ": ${days}d ${hours}h");
	    }
	}

	if ($rr->type eq 'NS') {
	    do_node($to, $rr->type);
	}

	#
	# add the edge (line)
	#
	do_edge($from, $to, $rr->type);

    }
}

#
# add legend
#
if ($opts{'L'}) {
    do_node('Legend','');
    my @etypes = @edgetypes;
    foreach my $k (@nodetypes, 'default') {
	do_node($k, $k,'','Legend');
	my $etype = shift @etypes;
	do_edge('Legend', $k, $etype, $etype);
    }
}

#
# add nodes and edges
#
my ($k, $v, $parms);
foreach my $e1 (keys(%edges)) {
    add_once($g, $e1);
    foreach my $e2 (keys(%{$edges{$e1}})) {
	add_once($g, $e2);
	$parms = get_parms($edges{$e1}{$e2}, \%edgeparameters);
	my $label = $edgelabels{$e1}{$e2};
	$g->add_edge($e1, $e2, label => $label, %$parms);
    }
}

open (O, ">" . $opts{'o'});
print O $g->as_png;
close(O);

sub get_parms {
    my ($array, $hash) = @_;
    my $parms;

    foreach my $et ('default', @$array) {
	next if (!$et);
	while (($k, $v) = each %{$hash->{$et}}) {
	    $parms->{$k} = $v;
	}
    }
    return $parms;
}

sub my_err {
    print "error: ", join(",",@_), "\n";
    #    die join(",",@_);
}

sub add_once {
    my ($g, $node, @opts) = @_;
    my $parms;

    if ($opts{'g'}) {
	push @opts, cluster => $dname;
    }

    if (!$nodesonce{$node}) {
	my $l = get_label($node);
	$parms = get_parms($nodes{$node}, \%nodeparameters);
	$g->add_node($node, label => $l, style => 'filled', %$parms, @opts);
	$nodesonce{$node} = 1;
    }
}

sub do_edge {
    my ($to, $from, $type, $label) = @_;
    # remember that the edge has this type
    $edges{$to}{$from}[$edgetypes{$type}] = $type;
    $edgelabels{$to}{$from} = $label if ($label);
}

sub do_node {
    my ($name, $type, $extra, $dn) = @_;
    # remember that the node has this type
    $nodes{$name}[$nodetypes{$type}] = $type;
    $dnames{$name} = $dn || $dname;
    push @{$extras{$name}}, $extra if ($extra);
}

sub add_edge_once {
    my ($g, $node1, $node2, @opts) = @_;

    add_once($g, $node1);
    add_once($g, $node2);

    if (!$edgesonce{$node1}{$node2}) {
	$g->add_edge($node1, $node2, @opts);
	$edgesonce{$node1}{$node2} = 1;
    }
}

sub get_label {
    my $name = $_[0];
    my $label = $_[0];
    my $dname = $dnames{$name};
    $label =~ s/\.$dname$//;
    if ($opts{'r'}) {
	$label .= "\n" . join(" ",sort keys(%{$rtypes{$name}}));
    }
    if ($extras{$name}) {
	$label .= "\n" . join("\n", @{$extras{$name}});
    }
    if ($#labtypes > -1) {
	foreach my $l (@labtypes) {
	    $label .= $rtypes{$name}{$l};
	}
    }
    return $label;
}

sub usage {
    print "
$0 [-h] [-r] [-R] [-o MAP.PNG] [-l (neato|dot|twopi)] [-s SKIPRECORDS]
  [-i IGNOREREGXP] [-t TYPEINFO] ZONEFILE ZONENAME [ZONEFILE ZONENAME...]

";
    exit;
}
