#!/usr/bin/perl
# Copyright 2004-2005 SPARTA, Inc.  All rights reserved.
# See the COPYING file included with the DNSSEC-Tools package for details.

use Carp;
use strict;
use IO::File;
use Net::DNS;
use Net::DNS::RR;

my %opts =
  ( 'd' => 'test.dnssec-tools.org',
    'ns' => 'dns1=168.150.236.36,dns2=63.195.146.66',
    'S' => ";\n; %s\n;\n",
    #  Add --genksk --genzsk for new zones
    'a' =>  "--verbose",
# XXX:
# nsec skips the good record
# nsec says type shouldn't be used
# sig doesn't cover type
    'p' => 'good,badsign,nosig,baddata,futuredate,pastdate');

LocalGetOptions(\%opts,
		['o|output-file=s',
		 'Output base DNS zone file to use (default = db.ZONENAME)'],
		['O|output-signed-file=s',
		 'Output base DNS zone file to use (default = OPT-o.zs.signed)'],
		['M|output-modified-file=s',
		 'Output for signed but modified zone file to use (default = OPT-O.modified)'],
		'',
		['d|domain=s', 'domain name to generate records for'],
		['ns|name-servers|n=s',
		 'Comma separated name=addr name-server records'],
		'',
		['p|prefixes','Comma separated list of record prefixes to use'],
		['c|no-cname-records','Don\'t create CNAME records'],
		['s|no-ns-records','Don\'t create sub-zone records'],
		'',
		['g|dont-generate-zone',
		 'Do not generate the zone; use the existing and sign/modify it'],
		['z|dont-run-zonesigner',
		 'Do not run zonesigner to sign the records'],
		['a|zonesigner-arguments=s',
		 'Arguments to pass to zonesigner'],
		['Z|dont-destroy',
		 'Do not destroy the records and leave them properly signed'],
		'',
		['v|verbose','Verbose output'],
		['h|help','Display help message'],
		['noop','Do nothing; bogus argument'],
	       );

$opts{'o'} = "db.$opts{d}" if (!$opts{'o'});
$opts{'O'} = "$opts{o}.zs.signed" if (!$opts{'O'});
croak "-O flag must end in .signed" if ($opts{'O'} !~ /\.signed$/);
$opts{'M'} = "$opts{O}.modified" if (!$opts{'M'});

#
# address definitions
#
my %addrs =
   (A    => '168.150.236.43',
    AAAA => '2001:470:1f00:ffff::af');

#
# data modification functions
#
#   regexp -> function
#
my %destroyFunctions =
  (
   # changes the rrsig signature to insert bogus x's
   '^(badsign[-\w]+).*IN\s+(CNAME|A+)\s+' => \&destroy_signature,
   '^(badsign[-\w]+).*IN\s+NS\s+' => [\&destroy_signature, 'DS'],

   # changes the address/cname record in the data
   '^(baddata[-\w]+).*IN\s+(A+)\s+(.*)' => \&destroy_data,

   # removes the rrsig record
   '^(nosig[-\w]+).*IN\s+(CNAME|A+)\s+' => \&delete_signature,

   # future expiration date = 1 year (365 days) -> 1 year + 30 days
   '^(futuredate[-\w]+).*IN\s+(A+|CNAME)\s+' =>
   [\&make_new_date, 365*24*60*60, 395*24*60*60],

   # past date: 30 days ago to 5 minutes ago
   '^(pastdate[-\w]+).*IN\s+(A+|CNAME)\s+' =>
   [\&make_new_date, -(30*24*60*60), -300],
  );

#
# globals
#
my $name;
my @prefixes = split(/,\s*/,$opts{p});
my $fh;

######################################################################
# do it

generate_records($opts{'o'})           if (!$opts{g});
run_zonesigner($opts{'o'}, $opts{'O'}) if (!$opts{'z'});
modify_records($opts{'O'}, $opts{'M'}) if (!$opts{'Z'});

######################################################################
# Generate records based on inputs
#
sub generate_records {
    my ($file) = @_;
    Verbose("generating $opts{'O'}");
    #
    # open the output file
    #
    $fh = new IO::File (">$file");

    generate_top();

    #
    # for each address, generate records
    #
    print_comment("Main records");
    foreach my $addr (keys(%addrs)) {
	print_comment("$addr records");
	# generate address records
	foreach my $prefix (@prefixes) {
	    print_record("$prefix-$addr", "1D IN", $addr, $addrs{$addr});
	}

	# generate address records
	if (!$opts{'c'}) {
	    print_comment("CNAMEs to $addr records");
	    foreach my $cnameprefix (@prefixes) {
		foreach my $addrprefix (@prefixes) {
		    print_record("${cnameprefix}-cname-to-${addrprefix}-${addr}",
				 "CNAME",
				 "", lc("${addrprefix}${addr}"));
		}
	    }
	}
    }

    # generate address records
    if (!$opts{'s'}) {
	print_comment("NS records to sub zones");
	foreach my $nsprefix (@prefixes) {
	    print_record("${nsprefix}-ns",
			 "1D IN", "NS",
			 lc("ns1.${nsprefix}.$opts{'d'}."));
	}
    }


    $fh->close();
}


######################################################################
# Run zonesigner on the resulting file.
#
sub run_zonesigner {
    my ($infile, $outfile) = @_;
    #
    # Run zonesigner to sign the thing
    #
    my $file = $outfile;
    $file =~ s/\.signed$//;
    Verbose("running zonesigner on $infile to produce $outfile");
    System("zonesigner $opts{'a'} --zone $opts{'d'} $infile $file");
}

######################################################################
# Modifies the records based on the registered functions
#
sub modify_records {
    my ($infile, $outfile) = @_;
    Verbose("modifying records in $opts{'O'} to produce $opts{'M'}");
    open(I,"$infile");
    $fh = new IO::File (">$outfile");
    $_ = <I>;
    my @matches;
    while ($_) {
	my $found;
	foreach my $type (keys(%destroyFunctions)) {
	    if (@matches = /$type/) {
		my @args;
		my $func = $destroyFunctions{$type};
		if (ref($func) eq 'ARRAY') {
		    @args = @$func;
		    $func = shift @args;
		}
		$func->(@matches, @args);
		$found = 1;
		last;
	    }
	}
	if (!$found) {
	    print $fh $_;
	    $_ = <I>;
	}
    }
    close(I);
    $fh->close();
}

######################################################################
# Functions to mess with results
#
sub destroy_signature {
    my ($name, $type) = @_;
    Verbose("  modifying signatures of $name");
    print $fh $_;
    my $inrec = 0;
    while (<I>) {
	last if /^\w/;
	$inrec = 1 if (/RRSIG\s+$type/);
	s/^(\s*)(.*)= \)/$1 . "x" x length($2) . "= )"/e if ($inrec);
	$inrec = 0 if (/\)/);
	print $fh $_;
    }
}

sub destroy_data {
    my ($name, $type, $data) = @_;
    Verbose("  modifying data of $name:$type");
    $_ =~ s/(.)$/($1 eq '0') ? "1" : "0"/e;
    print $fh $_;
    $_ = <I>;
}

sub delete_signature {
    my ($name, $type) = @_;
    Verbose("  deleting signatures of $_[0]");
    print $fh $_;
    my $inrec = 0;
    while (<I>) {
	last if /^\w/;
	$inrec = 1 if (/RRSIG\s+$type/);
	print $fh $_ if (!$inrec);
	$inrec = 0 if (/\)/);
    }
}

sub make_new_date {
    my ($name, $type, $sigin_mod, $sigex_mod) = @_;
    Verbose("  changing time in signatures of $_[0]");

    # print and save the current rr set
    print $fh $_;
    my $currentrr = $_;

    # delete the old signature
    my $inrec = 0;
    my ($keyid, $keyname);
    while (<I>) {
	last if /^\w/;
	if ($inrec == 1) {
	    # get the key id from the current line after the RRSIG line
	    # Note: depends heavily on format of dnssec-signzone output
	    #
	    # XXX: read this in instead into an RR record and get the
	    # keyid from that for better flexible parsing.
	    ($keyid, $keyname) = /^\s*\d+\s+(\d+)\s+([-\.\w]+)/;
	    $inrec = 2;
	}
	$inrec = 1 if (/RRSIG\s+$type/);
	print $fh $_ if (!$inrec);
	$inrec = 0 if (/\)/);
    }

    #
    # create the new signature based on the record/key
    #

    # save the current line since Net::DNS::RR::* messes with it
    my $currentline = $_;

    # the current RRset
    my $rec = Net::DNS::RR->new($currentrr);

    croak "can't read one of keyid ($keyid) or keyname ($keyname) from input RRSIG\n" if (!$keyid || !$keyname);

    # XXX: assumes 005 alg.
    my $keypath = "K${keyname}+005+${keyid}.private";
    croak "can't find needed private key file: $keypath\n" if (!-f $keypath);

    # create the new record
    my $sigrr = Net::DNS::RR::RRSIG->create([$rec], $keypath,
					    sigin => make_date($sigin_mod),
					    sigex => make_date($sigex_mod),
					    ttl => $rec->ttl);

    # print it
    print $fh $sigrr->string,"\n";

    # put the remembered line back
    $_ = $currentline;
}

sub make_date {
    my @timeinfo = localtime(time() + $_[0]);
    return sprintf("%04d%02d%02d%02d%02d%02d", $timeinfo[5]+1900,
		   $timeinfo[4]+1, $timeinfo[3], $timeinfo[2], $timeinfo[1],
		   $timeinfo[0]);
}

######################################################################
# printing-subs
#
sub print_record {
    my @txt = @_;
    $txt[0] = lc($txt[0]);
    printf $fh ("%-30s %-6s %-6s %s\n", @txt);
}

sub print_comment {
    Verbose($_[0]);
    printf $fh ($opts{'S'}, $_[0]);
}

sub generate_top {
    print $fh "; -*- dns -*-\n";
    print_comment "This file was generated by $0";
    print $fh "\$TTL 1D
$opts{'d'}.	600	IN SOA dns.$opts{'d'}. hardaker.$opts{'d'}. (
					" . time() . "
					2H       ; refresh (2 hours)
					1H       ; retry (1 hour)
					1W       ; expire (1 week)
					600        ; minimum (10 minutes)
					)
                        TXT     \"DNSSEC-TOOLS test zone for $opts{'d'}\"
";
    foreach my $ns (split(",",$opts{'ns'})) {
        my ($rec,$addr) = split(/=/,$ns);
        print_record("","NS","",$rec . "." . $opts{'d'} . ".");
    }
    foreach my $ns (split(",",$opts{'ns'})) {
        my ($rec,$addr) = split(/=/,$ns);
        print_record("$rec","1D IN","A",$addr);
    }
}

sub Verbose {
    print @_,"\n" if ($opts{'v'});
}

sub System {
    Verbose("running: ",@_);
    system(@_);
}

######################################################################
# Getopts related functions
#
sub LocalGetOptions {
    if (eval {require Getopt::GUI::Long;}) {
	import Getopt::GUI::Long;
        Getopt::GUI::Long::Configure(qw(display_help no_ignore_case));
	return GetOptions(@_);
    } else {
	require Getopt::Long;
	import Getopt::Long;
    }
    Getopt::Long::Configure(qw(auto_help no_ignore_case));
    GetOptions(LocalOptionsMap(@_));
}

sub LocalOptionsMap {
    my ($st, $cb, @opts) = ((ref($_[0]) eq 'HASH') 
			    ? (1, 1, $_[0]) : (0, 2));
    for (my $i = $st; $i <= $#_; $i += $cb) {
	if ($_[$i]) {
	    next if (ref($_[$i]) eq 'ARRAY' && $_[$i][0] =~ /^GUI:/);
	    push @opts, ((ref($_[$i]) eq 'ARRAY') ? $_[$i][0] : $_[$i]);
	    push @opts, $_[$i+1] if ($cb == 2);
	}
    }
    return @opts;
}

=head1 NAME

generaterecords - generates a test dnssec zone that can be used to DNSSEC

=head1 SYNOPSIS

generaterecords -v -d mytestzone.example.com

=head1 DESCRIPTION

The generaterecords script generates a zone file, given a domain name,
which is then signed and modified to invalidate portions of the data
in particular ways.  Each generated record is named appropriately to
how the security data is modified (the gooda record will contain a A
record with valid DNSSEC data, but the badseca record will contain an
A record where the signature has been modified to invalidate it).

The results of this process can then be served and test secure
validators, applications, and other software can be thrown at it to
see if they properly fail or succeed under the dns security policies
being deployed.

After the files are generated, consider running B<donuts> on them to
see how the data in them has been tampered with to be invalid.

=head1 PRE-REQUISITES

zonesigner from the dnssec-tools project
bind software 9.3.1 or greater

=head1 COPYRIGHT

Copyright 2005 SPARTA, Inc.  All rights reserved.
See the COPYING file included with the DNSSEC-Tools package for details.

=head1 AUTHOR

Wes Hardaker <hardaker@users.sourceforge.net>

=head1 SEE ALSO

B<Net::DNS>

http://dnssec-tools.sourceforge.net

zonesigner(1), donuts(1)

=cut

