#!/usr/bin/perl
# Copyright 2004-2005 Sparta, Inc.  All rights reserved.
# See the COPYING file included with the dnssec-tools package for details.

use Net::SMTP;

my %opts = (z => 60*60*24,
	    t => '/tmp/donutsd',
	    f => $ENV{'USER'} || $ENV{'LOGNAME'},
	    s => 'localhost');

LocalGetOptions(\%opts,
		['a|donuts-arguments=s', 'Arguments to pass to donuts'],
		['z|time-between-checks=s', 'Time between checks'],
		['t|temporary-directory=s', 'Temporary directory to store results in'],
                ['i|input-list=s',           'File containing file/zonename/zonecontact pairings'],
                '',
                ['GUI:separator',   'E-Mail options:'],
		['s|smtp-server=s', 'SMTP server to mail mail through (localhost)'],
                ['f|from-address=s','From address to use when seindng mail'],
                '',
		['v|verbose','Turn on verbose output'],
	       );

if ($opts{'i'}) {
    if (! -f $opts{'i'}) {
	print STDERR "Can't find or read the file: $opts{i}\n";
	exit 1;
    }
    open(I, $opts{'i'});
    while (<I>) {
	next if (/^\s*$/);
	next if (/^\s*#/);
	push @ARGV, split();
    }
    close(I);
}

if ($#ARGV == -1) {
    print STDERR
      "You must specify at least one ZONEFILE ZONENAME ZONECONTACT set\n";
    exit 1;
}

if (($#ARGV+1)%3 != 0) {
    print STDERR
      "Arguments must be passed in triples of: ZONEFILE ZONENAME ZONECONTACT\n";
    exit 1;
}

# creat temporary directory
if (! -d $opts{'t'}) {
    mkdir($opts{'t'});
}

while (1) {
    my @args = @ARGV;
    while ($#args > -1) {
	my $file = shift @args;
	my $zonename = shift @args;
	my $contactaddr = shift @args;

	my $mailit;
	
	verbose("running donuts on $file/$zonename");
	system("donuts $opts{a} $file $zonename > $opts{t}/$zonename.new 2>&1");
	if (-f "$opts{t}/$zonename") {
	    verbose("  comparing results from last run");
	    system("diff $opts{t}/$zonename $opts{t}/$zonename.new > /dev/null 2>&1");
	    $mailit = $?;
	} else {
	    verbose("  there was no data from a previous run");
	    $mailit = 1;
	}
	if ($mailit) {
	    verbose("  output changed; mailing $contactaddr about $file");
	    mailcontact($contactaddr, "$opts{t}/$zonename.new", $zonename);
	}
	if (-f "$opts{t}/$zonename") {
	    unlink("$opts{t}/$zonename");
	}
	verbose("  $opts{t}/$zonename.new => $opts{t}/$zonename");
	rename("$opts{t}/$zonename.new", "$opts{t}/$zonename");
    }
    verbose("sleeping for $opts{z}\n");
    sleep($opts{z});
}

######################################################################
# mailcontact()
#  - emails a contact address with the donuts error output
sub mailcontact {
    my ($contact, $file, $zonename) = @_;

    # set up the SMTP object and required data
    $message = Net::SMTP->new($opts{s});
    $message->mail($opts{f});
    $message->to(split(/,\s*/,$contact));
    $message->data();

    # create headers
    $message->datasend("To: " . $contact . "\n");
    $message->datasend("From: " . $opts{'f'} . "\n");
    $message->datasend("Subject: donuts output for zone: $zonename\n\n");

    # create the body of the message: the warning
    $message->datasend("The donuts dns zone-file syntax checker was run on the \"$zonename\"\n");
    $message->datasend("and there were resulting errors or errors that have changed since the last run.\n");
    $message->datasend("The results of this run of donuts can be found below:\n\n");
    $message->datasend("You will not receive another message until the output from donuts has changed.\n\n");

    # create the body of the message: the donuts results
    # Include the file
    open(IF,"$file");
    while (<IF>) {
        $message->datasend($_);
    }
    close(IF);

    # finish and send the message
    $message->dataend();
    $message->quit;
}


######################################################################
# verbose() routine
#  - passes arguments to print iff $opts{v} is defined (ie, -v was specified)
#
sub verbose {
    if ($opts{'v'}) {
	print STDERR @_;
	if ($_[$#_] !~ /\n$/) {
	    print STDERR "\n";
	}
    }
}

######################################################################
# argument parsing
#
sub LocalGetOptions {
    if ($#ARGV == -1 && eval {require Getopt::Long::GUI;}) {
	import Getopt::Long::GUI;
	return GetOptions(@_);
    } else {
	require Getopt::Long;
	import Getopt::Long;
    }
    GetOptions(LocalOptionsMap(@_));
}

sub LocalOptionsMap {
    my ($st, $cb, @opts) = ((ref($_[0]) eq 'HASH') 
			    ? (1, 1, $_[0]) : (0, 2));
    for (my $i = $st; $i <= $#_; $i += $cb) {
	if ($_[$i]) {
	    next if (ref($_[$i]) eq 'ARRAY' && $_[$i][0] =~ /^GUI:/);
	    push @opts, ((ref($_[$i]) eq 'ARRAY') ? $_[$i][0] : $_[$i]);
	    push @opts, $_[$i+1] if ($cb == 2);
	}
    }
    return @opts;
}
