#!/usr/bin/perl
# Copyright 2004-2005 SPARTA, Inc.  All rights reserved.
# See the COPYING file included with the dnssec-tools package for details.


use Net::DNS;
use Net::DNS::ZoneFile::Fast;
use Net::DNS::SEC::Tools::Donuts::Rule;
use Net::DNS::SEC::Tools::QWPrimitives;
use Data::Dumper;

use strict;

use Config;

my %opts = (l => 5,
	    c => $ENV{'HOME'} . "/.donuts.conf",
	    r => $Config{'siteprefix'} . "/share/donuts/rules/*");

my (@rules, %rules, $rf, $current_zone_file, $current_domain, %nrecs,
    @ignorelist, $netdns, $netdns_error);

LocalGetOptions(\%opts,
		["L|live", "Run live-query test rules"],
		["l|level=i", "The maxmimum rule level to run (default = 5)"],
		["r|rules=s", "glob pattern for rule files to load"],
		["i|ignore=s", "Regular expression for rules to ignore"],
		"",
		["c|config-file=s", "Use an alternate configuration file"],
		["C|no-config","Do not load any configuration files"],
		"",
		["v|verbose", "Verbose output showing extra information"],
		["q|quiet", "Quiet output (Do not print summmary information)"],
		"",
		["h|help", "Show help for command line options"],
		["R|help-rules", 'Show the rules that donuts checks'],
		["H|help-config",
		 'Show configuration tokens supported by the rules'],
	       );

#
# initialize ignore list
#
if ($opts{'i'}) {
    @ignorelist = split(/,\s*/, $opts{'i'});
}

#
# initialize our resolver
#
if ($opts{'L'}) {
    use Net::DNS;
    $netdns = Net::DNS::Resolver->new;
}

#
# load rule files
#   (comma separated list)
#
foreach my $rfexp (split(/,\s*/, $opts{'r'})) {
    my @rfs = glob($rfexp);
    foreach $rf (@rfs) {
	next if (! -f $rf || $rf =~ /.bak$/ || $rf =~ /~$/);
	print STDERR "--- loading rule file $rf\n    rules:" if ($opts{'v'});
	if ($rf =~ /\.pl$/) {
	    do $rf;
	} else {
	    parse_rule_file($rf);
	}
	print STDERR "\n" if ($opts{'v'});
    }
}

#
# load optional user-config file
#
if ($opts{'c'} && !$opts{'C'} && -f $opts{'c'}) {
    parse_user_config($opts{'c'});
}

#
# display config file help
#
if ($opts{'H'}) {
    print STDERR "$0 configuration tokens for loaded rules:\n\n";
    printf STDERR sprintf("%-20s %-15s%s\n",
			  "RULE NAME", "TOKEN", "DESCRIPTION");
    printf STDERR sprintf("%-20s %-15s%s\n", "_" x 19, "_" x 13, 
			  "_" x (80-20-15-2));
    foreach my $rule (@rules) {
	$rule->print_help();
    }
    exit;
}

#
# display a list of rules
#
if ($opts{'R'}) {
    print STDERR "$0 rules:\n\n";
    printf STDERR sprintf("%-40s %-35s\n", "RULE NAME", "DESCRIPTION");
    printf STDERR sprintf("%-40s %-35s\n", "_" x 39, "_" x 34);
    foreach my $rule (@rules) {
	$rule->print_description() if (!$rule->{'internal'});
    }
    exit;
}

#
# must specify at least one zone file
#
exit() if ($opts{'h'} || $#ARGV == -1);

#
# load zone files
#
my $exitcode = 0;
my $parseerror;
my $errcount;

while ($#ARGV > -1) {
    $errcount = 0;
    my $rulecount = 0;
    my ($rulesrun, $errorsfound);
    $current_zone_file = shift;
    $current_domain = shift;
    $current_domain =~ s/\.$//;  # remove potential trailing dot
    %nrecs = ();

    #
    # Parse the file into an array
    #
    $parseerror = 0;
    my $rrset = Net::DNS::ZoneFile::Fast::parse(file => $current_zone_file,
						origin => "$current_domain.",
						soft_errors => 1,
						on_error => \&print_parse_error);
    next if ($parseerror);

    #
    # call each rule on each record
    #
    print STDERR "--- Analyzing individual records in $current_zone_file\n" if ($opts{'v'});
    my $firstrun = 1;
    foreach my $rec (@$rrset) {
	foreach my $r (@rules) {
	    ($rulesrun, $errorsfound) =
	      $r->test_record($rec, $current_zone_file,
			      $opts{'l'}, $opts{'L'}, $opts{'v'});
	    $errcount += $errorsfound;
	    $rulecount += $rulesrun if ($firstrun);
	}
	push @{$nrecs{$rec->name}{$rec->type}}, $rec;
	$firstrun = 0;
    }


    #
    # call each ruletype=name rule on each name set of records
    #
    print STDERR "--- Analyzing records for each name in $current_zone_file\n"  if ($opts{'v'});
    $firstrun = 1;
    foreach my $namerec (keys(%nrecs)) {
	foreach my $r (@rules) {
	    ($rulesrun, $errorsfound) =
	      $r->test_name($nrecs{$namerec}, $namerec,
			    $current_zone_file,
			    $opts{'l'}, $opts{'L'}, $opts{'v'});
	    $errcount += $errorsfound;
	    $rulecount += $rulesrun if ($firstrun);
	}
	$firstrun = 0;
    }

    if ($opts{'v'}) {
	print "results on testing $current_zone_file:\n";
	print "  rules considered:\t" . (1+$#rules) . "\n";
	print "  rules tested:\t\t$rulecount\n";
	print "  records analyzed:\t" . (1+$#$rrset) . "\n";
	my @a = keys(%nrecs);
	print "  names analyzed:\t" . (1+$#a) . "\n";
	print "  errors found:\t\t$errcount\n";
    } else {
	print "$errcount errors found in $current_zone_file\n"
	  if (!$opts{'q'});
    }
    if ($errcount) {
	$exitcode = 1;
    }
}
exit($exitcode);

#######################################################################

sub add_rule {
    my $rule = shift;

    # ignore certain rules
    if ($opts{'i'}) {
	foreach my $i (@ignorelist) {
	    if ($rule->{'name'} =~ /$i/) {
		return;
	    }
	}
    }

    # merge in default values
    my %defaultrule = ( level => 5 );
    foreach my $key (keys(%defaultrule)) {
	$rule->{$key} = $defaultrule{$key} if (!exists($rule->{$key}));
    }

    # check rule validity for required fields
    if (!$rule->{'name'}) {
	warn "no name for a rule in file $rf\n";
    }
    if (!$rule->{'test'}) {
	warn "no test defined for a rule in file $rf\n";
    }

    print STDERR " $rule->{'name'}" if ($opts{'v'});

    # remember the rule
    $rule = new Net::DNS::SEC::Tools::Donuts::Rule($rule);
    push @rules, $rule;
    $rules{$rule->{name}} = $rule;
}

# parses a text based rule file
sub parse_rule_file {
    my $file = $_[0];
    my ($rule, $err);
    open(RF, $file);
    my $nextline;
    my $count;

    $err = 0;
    while (($_ = $nextline) || ($_ = <RF>)) {
	$nextline = undef;
	$count++;
	next if (/^\s*#/);
	if (/(test|init):/) {
	    my $type = $1;

	    # collect code
	    my $code;
	    while (<RF>) {
		# rule code must begin with white space
		$count++;
		last if (!/^\s/ || /^\s*$/);
		$code .= $_;
	    }

	    # add sub wrapper (if not init type)
	    if ($type ne 'init' && $code !~ /^\s*sub\s*{/) {
		$code = "sub { $code }";
	    }

	    # evaluate it
	    if ($type eq 'init') {
		eval("$code");
	    } else {
		$rule->{'test'} = eval("$code");
	    }

	    # if error, mention it
	    if ($@) {
		warn "broken code in $file:$count rule '$rule->{name}': $@";
		print STDERR "IN CODE:\n  $code\n" if ($opts{'v'});
		$err = 1;
	    }
	    if (!/^\s/) {
		$count--;
		$nextline = $_;
	    }
	} elsif (/^\s*help:\s*(\w+):\s*(.*)/) {
	    push @{$rule->{'help'}}, { token => $1, description => $2 };
	} elsif (/^\s*(\w+):\s*(.*\S)\s*$/) {
	    $rule->{$1} = $2;
	} elsif (!/^\s*$/) {
	    print STDERR "illegal rule in $file:$count for rule $rule->{name}";
	}

	# end of rule (can get here from inside a test end too, hence
	# not an else clause above)
	if (/^\s*$/) {
	    if ($rule && !$err) {
		add_rule($rule);
	    }
	    $rule = undef;
	    $err = 0;
	}
    }
    if ($rule && !$err) {
	add_rule($rule);
    }
}

sub parse_user_config {
    my ($file) = @_;
    open(I,$file);
    my $line;
    my $name;
    while (<I>) {
	$line++;
	next if (/^\s*#/);
	if (/^\s*$/) {
	    $name = undef;
	    next;
	}
	if (/^name:\s*(.*)/) {
	    $name = $1;
	    if (!exists($rules{$name})) {
		print STDERR "$file:$line warning: no such rule: $name\n";
	    }
	    next;
	}
	if (!$name) {
	    close(I);
	    print STDERR
	      "Error in $file at line $line: no rule name found yet\n";
	    exit;
	}
	if (/^(test|init):/) {
	    close(I);
	    print STDERR
	      "Error in $file at line $line: Illegal token in config file.\n";
	    exit;
	}
	if (!/^(\w+):\s*(.*)$/) {
	    close(I);
	    print STDERR
	      "Error in $file at line $line: Illegal definition.\n";
	    exit;
	}
	if (exists($rules{$name})) {
	    $rules{$name}->config($1, $2);
	}
    }
}

#
# subroutines for doing live queries on running systems
#

sub get_query {
    my ($name, $type) = @_;
    my $query = $netdns->query($name, $type);
    if ($query) {
	return $query;
    } else {
	$netdns_error = $netdns->errorstring;
	return;
    }
}

sub live_query {
    my $query = get_query(@_);
    if ($query) {
	return $query->answer;
    }
    return ();
}

sub compare_arrays {
    my ($a1, $b1) = @_;
    return -1 if ($#$a1 != $#$b1);
    my @a = sort @$a1;
    my @b = sort @$b1;

    for (my $i = 0; $i <= $#$a1; $i++) {
	if ($a[$i] ne $b[$i]) {
	    return $i;
	}
    }
}
sub compare_RR_arrays {
    my ($a1, $b1, $hashval) = @_;
    return -1 if ($#$a1 != $#$b1);
    my @a = sort @$a1;
    my @b = sort @$b1;

    for (my $i = 0; $i <= $#$a1; $i++) {
	print STDERR "$a[$i]{$hashval} ne $b[$i]{$hashval}\n";
	if ($a[$i]{$hashval} ne $b[$i]{$hashval}) {
	    return $i;
	}
    }
    return;
}

sub print_parse_error {
    my ($line, $err) = @_;
    $errcount++;
    print STDERR "$current_zone_file:$line $err\n";
}

sub LocalGetOptions {
    if (eval {require Getopt::GUI::Long;}) {
	require Getopt::Long;
	import Getopt::GUI::Long;
	Getopt::Long::Configure(qw(auto_help no_ignore_case));
	return GetOptions(@_);
    }
    require Getopt::Long;
    import Getopt::Long;
    Getopt::Long::Configure(qw(auto_help no_ignore_case));
    GetOptions(LocalOptionsMap(@_));
}

sub LocalOptionsMap {
    my ($st, $cb, @opts) = ((ref($_[0]) eq 'HASH') 
			    ? (1, 1, $_[0]) : (0, 2));
    for (my $i = $st; $i <= $#_; $i += $cb) {
	if ($_[$i]) {
	    next if (ref($_[$i]) eq 'ARRAY' && $_[$i][0] =~ /^GUI:/);
	    push @opts, ((ref($_[$i]) eq 'ARRAY') ? $_[$i][0] : $_[$i]);
	    push @opts, $_[$i+1] if ($cb == 2);
	}
    }
    return @opts;
}

=pod

=head1 NAME

DoNutS - analyze DNS zone files for errors and warnings

=head1 SYNOPSIS

./donuts [-h] [-H] [-v] [-l LEVEL] [-r RULEFILES] [-i IGNORELIST]
         [-C] [-c configfile] ZONEFILE DOMAINNAME...

=head1 DESCRIPTION

DoNutS is a DNS Lint application that examines DNS zone files looking
for particular problems.  This is especially important for zones
making use of DNSsec security records, since many subtle problems can
occur.

=head1 OPTIONS

=over

=item -h

Displays a help message.

=item -v

Turns on more verbose output.

=item -q

Turns on more quiet output.

=item -l LEVEL

Sets the level of errors you want to see.  The default is level 5.
The maximum value is level 9, which displays many debugging results.
You probably want to run no higher than level 8.

=item -r RULEFILES

A comma-separated list of rule files to load.  The strings will be
passed to I<glob()> so * wildcards can be used to specify multiple files.

=item -i IGNORELIST

A common separated list of regex patterns which are checked against
rule names to determine if some should be ignored.  Run with I<-v> to
figure out rule names if you're not sure which rule is generating
errors you don't wish to see.

=item -c CONFIGFILE

Parse a configuration file to change constraints specified by rules.
This defaults to B<$HOME/.donuts.conf>.

=item -C

Don't read user configuration files at all (like specified by I<-c> or
the B<$HOME/.donuts.conf> file)

=item -H

Displays the personal configuration file rules and tokens that are
acceptable to be found in a configuration file.  The output will
consist of a rue name, a token and a description of what it means.

Your configuration file (e.g., B<$HOME/.donuts.conf>) may have lines in it
that look like this:

  # change the default minimum number of legal NS records from 2 to 1
  name: DNS_MULTIPLE_NS
  minnsrecords: 1

  # change the level of the following rule from 8 to 5
  name: DNS_REASONABLE_TTLS
  level: 5

This allows you to override certain aspects of how rules are executed.

=item -R

Displays a list of all known rules along with their description (if
available).

=back

=head1 COPYRIGHT

Copyright 2004-2005 SPARTA, Inc.  All rights reserved.
See the COPYING file included with the dnssec-tools package for details.

=head1 AUTHOR

Wes Hardaker <hardaker@users.sourceforge.net>

=head1 SEE ALSO

Net::DNS::SEC::Tools::Donuts::Rule, Net::DNS

http://dnssec-tools.sourceforge.net/

=cut
