# Copyright 2004 Sparta, Inc.  All rights reserved.
# See the COPYING file included with the dnssec-tools package for details.
#
# This file implements rules to check DNSSEC record validity
#

name: DNSSEC_RRSIG_TTL_MATCH_ORGTTL
desc: quote RFC here.
level: 3
type:  RRSIG
test:
  $_[0]->ttl ne $_[0]->orgttl && "RRSIG ORGTTL must match TTL";

#
# memorize things that are only glue records (IE, have NS records
# pointing to them)
#
name: DNSSEC_MEMORIZE_NS_RECORDS
level: 3
type: NS
test:
  if ($_[0]->name eq $current_domain) {
    $DONUTS::DNSSEC::NS{$_[0]->nsdname} = 2;
  } elsif ($DONUTS::DNSSEC::NS{$_[0]->nsdname} != 2) {
    $DONUTS::DNSSEC::NS{$_[0]->nsdname} = 1;
  }
  return;

#
# NSEC is present?
#
name: DNSSEC_MISSING_NSEC_RECORD
level: 3
ruletype: name
test:
  "name $_[2] does not have an NSEC record, which is required for secure domains."
    if (!exists($_[0]->{'NSEC'}) &&
        !exists($DONUTS::DNSSEC::NS{$_[2]}));

#
# RRSIG is present?
#
name: DNSSEC_MISSING_RRSIG_RECORD
level: 3
ruletype: name
test:
  "name $_[2] does not have a RRSIG record, which is required for secure domains."
    if (!exists($_[0]->{'RRSIG'}) &&
        !exists($DONUTS::DNSSEC::NS{$_[2]}));

#
# RRSIG is present but shouldn't be?
#
name: DNSSEC_RRSIG_FOR_NS_GLUE_RECORD
level: 3
ruletype: name
test:
  "name $_[2] is pointed to by an NS record and thus should be a glue record.  But it also has an RRSIG record which should not be present for glue records."
    if (exists($_[0]->{'RRSIG'}) &&
        $current_domain ne $_[2] &&
        exists($DONUTS::DNSSEC::NS{$_[2]}) &&
        $DONUTS::DNSSEC::NS{$_[2]} != 2);

#
# NSEC is present but shouldn't be?
#
name: DNSSEC_NSEC_FOR_NS_GLUE_RECORD
level: 3
ruletype: name
test:
  "name $_[2] is pointed to by an NS record and thus should be a glue record.  But it also has an NSEC record which should not be present for glue records."
    if (exists($_[0]->{'NSEC'}) &&
        exists($DONUTS::DNSSEC::NS{$_[2]}) &&
        $DONUTS::DNSSEC::NS{$_[2]} != 2);

#
# check signature expiration
#
name: DNSSEC_RRSIG_SIGEXP
level: 1
type:  RRSIG
warntime:  604800
init:
  use Date::Parse;
  $donuts::time = time();
test:
  my $date = $_[0]->sigexpiration;
  $date =~ s/(....)(..)(..)(..)(..)(..)/$2-$3-$1 $4:$5:$6/;
  my $extime = str2time($date);
  if ($extime < $donuts::time) {
    return "RRSIG record has expired";
  } elsif ($extime - $donuts::time < $_[1]->{'warntime'}) {
    return "RRSIG is nearing its expiration time";
  }

# Note: this only works if the SOA has already been seen 
# (should have been first anyway)
#
level: 5
name: DNSSEC_NSEC_TTL
desc: RFC3845: The NSEC RR SHOULD have the same TTL value as the SOA minimum TTL field.  This is in the spirit of negative caching [8].
type: NSEC
test:
  $_[0]->ttl ne $nrecs{$current_domain}{'SOA'}[0]->minimum && 
     "NSEC TTL for " . $_[0]->name . " (" . $_[0]->ttl . 
     ") does not match SOA MIN TTL (" . 
     $nrecs{$current_domain}{'SOA'}[0]->minimum . ")";

name: DNSSEC_DNSKEY_MUST_HAVE_SAME_NAME
level: 4
type: DNSKEY
desc: draft-ietf-dnsext-dnssec-records-11.txt section 2.1.1: If bit 7 has value 1, then the DNSKEY record holds a DNS zone key and the DNSKEY RR's owner name MUST be the name of a zone.
test:
  if ($_[0]->flags & 0x100 && $current_domain ne $_[0]->name) {
    return "DNSKEY record found for '$_[0]' in wrong domain: '$current_domain'."
  }

name: DNSSEC_DNSKEY_PROTOCOL_MUST_BE_3
level: 4
type: DNSKEY
desc: draft-ietf-dnsext-dnssec-records-11.txt section 2.1.2: The Protocol Field MUST have value 3 and the DNSKEY RR MUST be treated as invalid during signature verification if found to be some value other than 3.
test:
  if ($_[0]->protocol != 3) {
    return "DNSKEY record found for '$_[0]->{name}' with protocol other than '3'."
  }

name: DNSSEC_BOGUS_NS_MEMORIZE
level: 1
type: NS
test:
  if ($current_domain ne $_[0]->{name}) {
    # remember the name so we can also ignore glue records later
    $DONUTS::gluerecs{$_[0]->{nsdname}} = 1;
  }
  return;

name: DNSSEC_MISSING_RRSIG_RECORD
level: 3
ruletype: name
desc: RRSIG records are required for all records in order for the domain to be secure, with the exception of NS and glue records for children.
test:
  my %rrsigs;
  foreach my $rec (@{$_[0]->{'RRSIG'}}) {
    # memorize RRSIG records
    $rrsigs{$rec->typecovered}{$rec->name} = $rec;
  }
  #
  my @err;
  my %gluerecs;
  # for each record type for a given name
  # reverse sort these so NS records are seen before the glue records
  foreach my $type (sort { $b cmp $a } keys(%{$_[0]})) {
    # RRSIGs themselves (obviously) aren't signed
    next if ($type eq 'RRSIG');
    foreach my $rec (@{$_[0]->{$type}}) {
      # NS records for children aren't signed
      next if ($type eq 'NS' && $current_domain ne $rec->{name});
      # NS glue records for children aren't signed.
      if (!exists($rrsigs{$type}{$rec->name}) &&
          !exists($DONUTS::gluerecs{$rec->name})) {
         push @err, "No RRSIG record found for the record: $type:$rec->{name}";
      }
    }
  }
  return \@err;

name: DNSSEC_RRSIG_TTL_MUST_MATCH_RECORD
level: 3
ruletype: name
desc: draft-ietf-dnsext-dnssec-records-11.txt section 3.0: The TTL value of an RRSIG RR MUST match the TTL value of the RRset it covers. 
test:
  my %rrsigs;
  foreach my $rec (@{$_[0]->{'RRSIG'}}) {
    # memorize RRSIG records
    push @{$rrsigs{$rec->typecovered}{$rec->name}}, $rec;
  }
  #
  my @err;
  my %gluerecs;
  # for each record type for a given name
  # reverse sort these so NS records are seen before the glue records
  foreach my $type (sort { $b cmp $a } keys(%{$_[0]})) {
    # RRSIGs themselves (obviously) aren't signed
    next if ($type eq 'RRSIG');
    foreach my $rec (@{$_[0]->{$type}}) {
      foreach my $rrsig (@{$rrsigs{$type}{$rec->name}}) {
        if ($rrsig->ttl ne $rec->ttl) {
          push @err,"RRSIG's TTL ($rrsig->{ttl}) for $rec->{name}:$type doesn't match original record's TTL ($rec->{ttl})"
        }
      }
    }
  }
  return \@err;

name: DNSSEC_MISSING_NSEC_RECORD
level: 3
ruletype: name
desc: NSEC records are required for all names except child glue records in order for the domain to be secure from denial-of-existence attacks.
test:
  # make sure an nsec record exists
  if (!(exists($_[0]->{'NSEC'}) || $#{$_[0]->{'NSEC'}} == -1) &&
      # ignore glue records
      !exists($DONUTS::gluerecs{$_[2]})) {
    return "NSEC record missing for $_[2]";
  }
  return if (exists($DONUTS::gluerecs{$_[2]}));
  if ($#{$_[0]->{'NSEC'}} != 0) {
    return "odd error with NSEC record for $_[2].  number of records = " . 
           $#{$_[0]->{'NSEC'}};
  }
  my $types = $_[0]->{'NSEC'}[0]->typelist;
  my @types = split(/ /,$types);
  my %types;
  my @err;
  # if it does exist, make sure it doesn't cover types that don't exist
  foreach my $t (@types) {
    if (!exists($_[0]->{$t})) {
      push @err, "NSEC record for $_[0]->{name} has coverage for type $t but the domain doesn't have a correspending record for that type";
    }
    $types{$t} = 1;
  }
  # and that it covers all the types that do
  foreach my $k (keys(%{$_[0]})) {
    if (!exists($types{$k})) {
      push @err,"NSEC record for $_[0]->{name} doesn't cover type $k but there are records for that name of that type";
    }
  }
  return \@err;

name: DNSSEC_RRSIG_SIGNER_NAME_MATCHES
type: RRSIG
desc: draft-ietf-dnsext-dnssec-records-11: section 3.1.7: The Signer's Name field MUST contain the name of the zone of the covered RRset.
test:
  if ($_[0]->signame ne $current_domain . ".") {
    print STDERR Dumper($_[0]);
    return "signer name for $_[0]->{name} is $_[0]->{signame} but it should match the zone name ($current_domain)";
  }


# XXX: nsec next order is proper
# XXX: check all sigs?
#
# XXX: records-11.txt section 3.1.3 talks about labels requirements.  testable?
#
# XXX: check if no RRSIGs exist for the *current* time period (eg,
# start time is later than now)
#
