# Copyright 2004 Sparta, Inc.  All rights reserved.
# See the COPYING file included with the dnssec-tools package for details.
#
# This file implements rules to check DNSSEC record validity
#

name: DNSSEC_RRSIG_TTL_MATCH_ORGTTL
desc: quote RFC here.
level: 3
type:  RRSIG
test:
  $_[0]->ttl ne $_[0]->orgttl && "RRSIG ORGTTL must match TTL";

#
# memorize things that are only glue records (IE, have NS records
# pointing to them)
#
name: DNSSEC_MEMORIZE_NS_RECORDS
level: 3
type: NS
test:
  if ($_[0]->name eq $current_domain) {
    $DONUTS::DNSSEC::NS{$_[0]->nsdname} = 2;
  } elsif ($DONUTS::DNSSEC::NS{$_[0]->nsdname} != 2) {
    $DONUTS::DNSSEC::NS{$_[0]->nsdname} = 1;
  }
  return;

#
# NSEC is present?
#
name: DNSSEC_MISSING_NSEC_RECORD
level: 3
ruletype: name
test:
  "name $_[2] does not have an NSEC record, which is required for secure domains."
    if (!exists($_[0]->{'NSEC'}) &&
        !exists($DONUTS::DNSSEC::NS{$_[2]}));

#
# RRSIG is present?
#
name: DNSSEC_MISSING_RRSIG_RECORD
level: 3
ruletype: name
test:
  "name $_[2] does not have a RRSIG record, which is required for secure domains."
    if (!exists($_[0]->{'RRSIG'}) &&
        !exists($DONUTS::DNSSEC::NS{$_[2]}));

#
# RRSIG is present but shouldn't be?
#
name: DNSSEC_RRSIG_FOR_NS_GLUE_RECORD
level: 3
ruletype: name
test:
  "name $_[2] is pointed to by an NS record and thus should be a glue record.  But it also has an RRSIG record which should not be present for glue records."
    if (exists($_[0]->{'RRSIG'}) &&
        $current_domain ne $_[2] &&
        exists($DONUTS::DNSSEC::NS{$_[2]}) &&
        $DONUTS::DNSSEC::NS{$_[2]} != 2);

#
# NSEC is present but shouldn't be?
#
name: DNSSEC_NSEC_FOR_NS_GLUE_RECORD
level: 3
ruletype: name
test:
  "name $_[2] is pointed to by an NS record and thus should be a glue record.  But it also has an NSEC record which should not be present for glue records."
    if (exists($_[0]->{'NSEC'}) &&
        exists($DONUTS::DNSSEC::NS{$_[2]}) &&
        $DONUTS::DNSSEC::NS{$_[2]} != 2);

#
# check signature expiration
#
name: DNSSEC_RRSIG_SIGEXP
level: 1
type:  RRSIG
warntime:  604800
init:
  use Date::Parse;
  $donuts::time = time();
test:
  my $date = $_[0]->sigexpiration;
  $date =~ s/(....)(..)(..)(..)(..)(..)/$2-$3-$1 $4:$5:$6/;
  my $extime = str2time($date);
  if ($extime < $donuts::time) {
    return "RRSIG record has expired";
  } elsif ($extime - $donuts::time < $_[1]->{'warntime'}) {
    return "RRSIG is nearing its expiration time";
  }

# Note: this only works if the SOA has already been seen 
# (should have been first anyway)
#
level: 5
name: DNSSEC_NSEC_TTL
desc: RFC3845: The NSEC RR SHOULD have the same TTL value as the SOA minimum TTL field.  This is in the spirit of negative caching [8].
type: NSEC
test:
  $_[0]->ttl ne $nrecs{$current_domain}{'SOA'}[0]->minimum && 
     "NSEC TTL for " . $_[0]->name . " (" . $_[0]->ttl . 
     ") does not match SOA MIN TTL (" . 
     $nrecs{$current_domain}{'SOA'}[0]->minimum . ")";

# XXX: check details of all the NSEC records?
#   - every record type exists which was listed in an NSEC
#   - nsec next order is proper

# XXX: check all sigs?
