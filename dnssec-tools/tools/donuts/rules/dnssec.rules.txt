# -*- mmm-classes: donuts-perl -*-
# Copyright 2004 Sparta, Inc.  All rights reserved.
# See the COPYING file included with the dnssec-tools package for details.
#
# This file implements rules to check DNSSEC record validity
#

name: DNSSEC_RRSIG_TTL_MATCH_ORGTTL
desc: quote RFC here.
level: 3
type:  RRSIG
test:
  $_[0]->ttl ne $_[0]->orgttl && "RRSIG ORGTTL must match TTL";

#
# memorize things that are only glue records (IE, have NS records
# pointing to them)
#
name: DNSSEC_MEMORIZE_NS_RECORDS
level: 3
type: NS
test:
  if ($_[0]->name eq $current_domain) {
    $DONUTS::DNSSEC::NS{$_[0]->nsdname} = 2;
  } elsif ($DONUTS::DNSSEC::NS{$_[0]->nsdname} != 2) {
    $DONUTS::DNSSEC::NS{$_[0]->nsdname} = 1;
  }
  return;

#
# NSEC is present?
#
name: DNSSEC_MISSING_NSEC_RECORD
level: 3
ruletype: name
test:
  "name $_[2] does not have an NSEC record, which is required for secure domains."
    if (!exists($_[0]->{'NSEC'}) &&
        !exists($DONUTS::DNSSEC::NS{$_[2]}));

#
# RRSIG is present?
#
name: DNSSEC_MISSING_RRSIG_RECORD
level: 3
ruletype: name
test:
  "name $_[2] does not have a RRSIG record, which is required for secure domains."
    if (!exists($_[0]->{'RRSIG'}) &&
        !exists($DONUTS::DNSSEC::NS{$_[2]}));

#
# RRSIG signs itself???
#
name: DNSSEC_RRSIG_NOT_SIGNING_RRSIG
level: 7
type: RRSIG
desc: draft-ietf-dnsext-dnssec-protocol-09.txt: Section 2.2: An RRSIG RR itself MUST NOT be signed, since signing an RRSIG RR would add no value and would create an infinite loop in the signing process.
test:
  "$_[0]->{name} has an RRSIG that signs an RRSIG"
    if ($_[0]->typecovered eq 'RRSIG');

#
# RRSIG is present but shouldn't be?
#
name: DNSSEC_RRSIG_FOR_NS_GLUE_RECORD
level: 3
ruletype: name
test:
  "name $_[2] is pointed to by an NS record and thus should be a glue record.  But it also has an RRSIG record which should not be present for glue records."
    if (exists($_[0]->{'RRSIG'}) &&
        $current_domain ne $_[2] &&
        exists($DONUTS::DNSSEC::NS{$_[2]}) &&
        $DONUTS::DNSSEC::NS{$_[2]} != 2);

#
# NSEC is present but shouldn't be?
#
name: DNSSEC_NSEC_FOR_NS_GLUE_RECORD
level: 3
ruletype: name
test:
  "name $_[2] is pointed to by an NS record and thus should be a glue record.  But it also has an NSEC record which should not be present for glue records."
    if (exists($_[0]->{'NSEC'}) &&
        exists($DONUTS::DNSSEC::NS{$_[2]}) &&
        $DONUTS::DNSSEC::NS{$_[2]} != 2);

#
# check signature expiration
#
name: DNSSEC_RRSIG_SIGEXP
level: 1
type:  RRSIG
warntime:  604800
init:
  use Date::Parse;
  $donuts::time = time();
test:
  my $date = $_[0]->sigexpiration;
  $date =~ s/(....)(..)(..)(..)(..)(..)/$2-$3-$1 $4:$5:$6/;
  my $extime = str2time($date);
  if ($extime < $donuts::time) {
    return "RRSIG record has expired";
  } elsif ($extime - $donuts::time < $_[1]->{'warntime'}) {
    return "RRSIG is nearing its expiration time";
  }

# Note: this only works if the SOA has already been seen 
# (should have been first anyway)
#
level: 5
name: DNSSEC_NSEC_TTL
desc: RFC3845: The NSEC RR SHOULD have the same TTL value as the SOA minimum TTL field.  This is in the spirit of negative caching [RFC2308].
type: NSEC
test:
  $_[0]->ttl ne $nrecs{$current_domain}{'SOA'}[0]->minimum && 
     "NSEC TTL for " . $_[0]->name . " (" . $_[0]->ttl . 
     ") does not match SOA MIN TTL (" . 
     $nrecs{$current_domain}{'SOA'}[0]->minimum . ")";

name: DNSSEC_DNSKEY_MUST_HAVE_SAME_NAME
level: 4
type: DNSKEY
desc: draft-ietf-dnsext-dnssec-records-11.txt section 2.1.1: If bit 7 has value 1, then the DNSKEY record holds a DNS zone key and the DNSKEY RR's owner name MUST be the name of a zone.
test:
  if ($_[0]->flags & 0x100 && $current_domain ne $_[0]->name) {
    return "DNSKEY record found for '$_[0]' in wrong domain: '$current_domain'."
  }

name: DNSSEC_DNSKEY_PROTOCOL_MUST_BE_3
level: 4
type: DNSKEY
desc: draft-ietf-dnsext-dnssec-records-11.txt section 2.1.2: The Protocol Field MUST have value 3 and the DNSKEY RR MUST be treated as invalid during signature verification if found to be some value other than 3.
test:
  if ($_[0]->protocol != 3) {
    return "DNSKEY record found for '$_[0]->{name}' with protocol other than '3'."
  }

name: DNSSEC_BOGUS_NS_MEMORIZE
level: 1
type: NS
test:
  if ($current_domain ne $_[0]->{name}) {
    # remember the name so we can also ignore glue records later
    $DONUTS::gluerecs{$_[0]->{nsdname}} = $_[0]->{name};
  }
  return;

name: DNSSEC_MISSING_RRSIG_RECORD
level: 3
ruletype: name
desc: RRSIG records signed by the zone's key are required for all records in order for the domain to be secure, with the exception of NS and glue records for children.
test:
  my %rrsigs;
  foreach my $rec (@{$_[0]->{'RRSIG'}}) {
    # memorize RRSIG records
    push @{$rrsigs{$rec->typecovered}{$rec->name}},$rec;
  }
  #
  my @err;
  # for each record type for a given name
  # reverse sort these so NS records are seen before the glue records
  foreach my $type (sort { $b cmp $a } keys(%{$_[0]})) {
    # RRSIGs themselves (obviously) aren't signed
    next if ($type eq 'RRSIG');
    foreach my $rec (@{$_[0]->{$type}}) {
      # NS records for children aren't signed
      if ($type eq 'NS' && $current_domain ne $rec->{name}) {
        if (exists($rrsigs{$type}{$rec->name})) {
          push @err, "$rec->{name} is a child NS record but is signed and shouldn't be";
        }
        next;
      }
      # NS glue records for children aren't signed.
      if (exists($rrsigs{$type}{$rec->name}) &&
          exists($DONUTS::gluerecs{$rec->name}) &&
          # make exception for stuff directly in our zone
          $rec->{name} !~ /^\w+\.$current_domain$/) {
        push @err, "$rec->{name} is a glue record for $DONUTS::gluerecs{$rec->{name}} and is signed and shouldn't be.";
        next;
      }
      if (!exists($rrsigs{$type}{$rec->name}) &&
          !exists($DONUTS::gluerecs{$rec->name})) {
         push @err, "No RRSIG record found for the record: $type:$rec->{name}";
      }
      if (exists($rrsigs{$type}{$rec->name})) {
         my $gotone = 0;
         for(my $i = 0; $i <= $#{$rrsigs{$type}{$rec->name}} && !$gotone; $i++){
           $gotone = 1 if ($rrsigs{$type}{$rec->name}[$i]->signame eq 
                           $current_domain . ".");
         }
         if (!$gotone) {
           push @err, "$type:$rec->{name} is not signed by a key owned by the zone";
         }
      }
    }
  }
  return \@err;

name: DNSSEC_RRSIG_TTL_MUST_MATCH_RECORD
level: 3
ruletype: name
desc: draft-ietf-dnsext-dnssec-records-11.txt section 3.0: The TTL value of an RRSIG RR MUST match the TTL value of the RRset it covers. 
test:
  my %rrsigs;
  foreach my $rec (@{$_[0]->{'RRSIG'}}) {
    # memorize RRSIG records
    push @{$rrsigs{$rec->typecovered}{$rec->name}}, $rec;
  }
  #
  my @err;
  my %gluerecs;
  # for each record type for a given name
  # reverse sort these so NS records are seen before the glue records
  foreach my $type (sort { $b cmp $a } keys(%{$_[0]})) {
    # RRSIGs themselves (obviously) aren't signed
    next if ($type eq 'RRSIG');
    foreach my $rec (@{$_[0]->{$type}}) {
      foreach my $rrsig (@{$rrsigs{$type}{$rec->name}}) {
        if ($rrsig->ttl ne $rec->ttl) {
          push @err,"RRSIG's TTL ($rrsig->{ttl}) for $rec->{name}:$type doesn't match original record's TTL ($rec->{ttl})"
        }
      }
    }
  }
  return \@err;

name: DNSSEC_MISSING_NSEC_RECORD
level: 3
ruletype: name
desc: NSEC records are required for all names except child glue records in order for the domain to be secure from denial-of-existence attacks.
test:
  # make sure an nsec record exists
  if (!(exists($_[0]->{'NSEC'}) || $#{$_[0]->{'NSEC'}} == -1) &&
      # ignore glue records
      !exists($DONUTS::gluerecs{$_[2]})) {
    return "NSEC record missing for $_[2]";
  }
  return if (exists($DONUTS::gluerecs{$_[2]}));
  if ($#{$_[0]->{'NSEC'}} != 0) {
    return "odd error with NSEC record for $_[2].  number of records = " . 
           (1 + $#{$_[0]->{'NSEC'}});
  }
  my $types = $_[0]->{'NSEC'}[0]->typelist;
  my @types = split(/ /,$types);
  my %types;
  my @err;
  # if it does exist, make sure it doesn't cover types that don't exist
  foreach my $t (@types) {
    if (!exists($_[0]->{$t})) {
      push @err, "NSEC record for $_[0]->{name} has coverage for type $t but the domain doesn't have a correspending record for that type";
    }
    $types{$t} = 1;
  }
  # and that it covers all the types that do
  foreach my $k (keys(%{$_[0]})) {
    if (!exists($types{$k})) {
      push @err,"NSEC record for $_[0]->{name} doesn't cover type $k but there are records for that name of that type";
    }
  }
  return \@err;

name: DNSSEC_RRSIG_SIGNER_NAME_MATCHES
type: RRSIG
desc: draft-ietf-dnsext-dnssec-records-11: section 3.1.7: The Signer's Name field MUST contain the name of the zone of the covered RRset.
test:
  if ($_[0]->signame ne $current_domain . ".") {
    print STDERR Dumper($_[0]);
    return "signer name for $_[0]->{name} is $_[0]->{signame} but it should match the zone name ($current_domain)";
  }

name: DNSSEC_NSEC_RRSEC_MUST_NOT_BE_ALONE
ruletype: name
level: 5
desc: draft-ietf-dnsext-dnssec-protocol-09: section 2.3: An NSEC record (and its associated RRSIG RRset) MUST NOT be the only RRset at any particular owner name.
test:
  my @keys = sort keys(%{$_[0]});
  return if ($#keys == 1);
  "$_[0]->{name} only contains NSEC and RRSIG records"
    if ($keys[0] eq 'NSEC' && $keys[1] eq 'RRSIG');

name: DNSSEC_RRSIGS_MUST_NOT_BE_SIGNED
type: RRSIG
desc: draft-ietf-dnsext-dnssec-protocol-09: section 2.2: An RRSIG RR itself MUST NOT be signed, since signing an RRSIG RR would add no value and would create an infinite loop in the signing process.
test:
  "RRSIG records must not be signed but a signature for a RRSIG on $_[0]{name} is."
    if ($_[0]->typecovered eq 'RRSIG');

# XXX: nsec next order is proper
# XXX: check all sigs?
#
# XXX: records-11.txt section 3.1.3 talks about labels requirements.  testable?
#
# XXX: check if no RRSIGs exist for the *current* time period (eg,
# start time is later than now)
#
# XXX: records-11.txt: 3.1.8.1 has a bunch of MUSTs that are sort of
# tested by other rules...
#
# XXX: last sentence of 4.1.2...  hard to test.

# XXX: section 6.3 Paragraph 2 says no identical RR sets should exist.  check for this?

# XXX: protocol:2.2 zone apex NS record MUST be signed
# XXX: protocol 2.2: There MUST be an RRSIG for each RRset using at least one DNSKEY of each algorithm in the zone apex DNSKEY RRset. (currently we don't check each alg must be used)
# XXX: prococol 2.2: The apex DNSKEY RRset itself MUST be signed by each algorithm appearing in the DS RRset located at the delegating parent (if any).

# XXX: check NSEC types to make sure each type at a name is covered (exactly)

# stopped in protocol: 2.3
