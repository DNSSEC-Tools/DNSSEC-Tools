name:  	  DNS_SOA_STATUS
level: 	  2
ruletype: name
class: 	  Status
desc:  	  Outputs details found in the status report
<test>
  if ($recordname eq $current_domain && $#{$records->{'SOA'}} == 0) {
     domain_status("Zone Serial Number", $records->{'SOA'}[0]->serial); 
     domain_status("SOA Contact Address", $records->{'SOA'}[0]->rname); 
  }
</test>

# memorize and report the 
name:  	   DNSSEC_RRSIG_STATUS
level: 	   2
type:  	   RRSIG
warntime:  604800
class:     Status
desc: Reports the signature lifetimes
<init>
  use Date::Parse;
  $donuts::time = time();

  $donuts::sigexpiration = undef;
  $donuts::siginception = undef;

  package main;
  sub rrsig_date_to_epoch {
    my ($incoming) = @_;
    $incoming =~ s/(....)(..)(..)(..)(..)(..)/$2-$3-$1 $4:$5:$6/;
    return str2time($incoming);
  }

</init>
<test>

  # process the expiration time
  my $newtime = rrsig_date_to_epoch($record->sigexpiration);
  
  if (!defined($donuts::sigexpiration)) {
    $donuts::sigexpiration = $newtime
  } elsif ($donuts::sigexpiration != $newtime) {
    donuts_error("warning: signatures in this zone are not time aligned");
    
    # remember the soonest time that the zone might expire
    $donuts::sigexpiration = $donuts::sigexpiration < $newtime
                              ? $donuts::sigexpiration : $newtime;
  } 

  # process the inception time
  my $newtime = rrsig_date_to_epoch($record->siginception);

  if (!defined($donuts::siginception)) {
    $donuts::siginception = $newtime;
  } elsif ($donuts::siginception != $newtime) {
    donuts_error("warning: signatures in this zone are not time aligned");
    
    # remember the latest time that the zone might be valid from
    $donuts::siginception = $donuts::siginception > $newtime
                              ? $donuts::siginception : $newtime;
  } 

  return;
</test>
<end>

  if (defined($donuts::siginception)) {
    domain_status("Zone valid from", scalar localtime($donuts::siginception));
  }

  if (defined($donuts::sigexpiration)) {
    domain_status("Zone valid until", scalar localtime($donuts::sigexpiration));
  } else {
    domain_status("DNSSEC Signed", "No!");
  }

  # clean up for the next run
  $donuts::sigexpiration = undef;
  $donuts::siginception = undef;
</end>
