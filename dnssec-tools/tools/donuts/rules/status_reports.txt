name:  	  DNS_SOA_STATUS
level: 	  2
ruletype: name
class: 	  Status
desc:  	  Outputs details found in the status report
<test>
  if ($recordname eq $current_domain && $#{$records->{'SOA'}} == 0) {
     donuts_status("A SOA record for $current_domain was found");
  }
</test>

# memorize and report the 
name:  	   DNSSEC_RRSIG_STATUS
level: 	   2
type:  	   RRSIG
warntime:  604800
class:     Status
desc: Reports the signature lifetimes
<init>
  use Date::Parse;
  $donuts::time = time();

  $donuts::sigexptime = undef;
</init>
<test>

  # memorize the signature expiration time
  my $date = $record->sigexpiration;
  $date =~ s/(....)(..)(..)(..)(..)(..)/$2-$3-$1 $4:$5:$6/;
  my $extime = str2time($date);

  if (!defined($donuts::sigexpiration)) {
    $donuts::sigexpiration = $record->sigexpiration;
  } elsif ($donuts::sigexpiration != $record->sigexpiration) {
    donuts_error("warning: signatures in this zone are not time aligned");
    
    $donuts::sigexpiration = $donuts::sigexpiration < $record->sigexpiration
                              ? $donuts::sigexpiration : $record->sigexpiration;
  } 

  # memorize the signature inception time
  my $date = $record->siginception;
  $date =~ s/(....)(..)(..)(..)(..)(..)/$2-$3-$1 $4:$5:$6/;
  my $extime = str2time($date);

  if (!defined($donuts::sigexpiration)) {
    $donuts::sigexpiration = $record->siginception;
  } elsif ($donuts::sigexpiration != $record->siginception) {
    donuts_error("warning: signatures in this zone are not time aligned");
    
    $donuts::siginception = $donuts::siginception > $record->sigexpiration
                              ? $donuts::siginception : $record->sigexpiration;
  } 

</test>
<end>
  if (defined($donuts::siginception)) {
    domain_status("Zone valid from", scalar localtime($donuts::siginception));
  }

  if (defined($donuts::sigexpiration)) {
    domain_status("Zone valid until", scalar localtime($donuts::sigexpiration));
  } else {
    domain_status("DNSSEC Signed", "No!");
  }
</end>
