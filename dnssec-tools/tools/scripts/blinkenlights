#!/usr/bin/perl
#
# Copyright 2006 SPARTA, Inc.  All rights reserved.  See the COPYING
# file distributed with this software for details
#
# DNSSEC-Tools:  blinkenlights
#
#	blinkenlights is a display tool for use with the DNSSEC-Tools rollerd
#	program.  As rollerd rolls the zones listed in the rollrec file,
#	blinkenlights will display status information for the file's zones.
#
#	blinkenlights is implemented in Perl/Tk, so both Perl and Perl/Tk must
#	be installed on your system.
#

use strict;

use Getopt::Long;

use Tk;
use Tk::Dialog;
use Tk::Table;

use Net::DNS::SEC::Tools::keyrec;
use Net::DNS::SEC::Tools::rollrec;

#
# Version information.
#
my $NAME   = "blinkenlights";
my $VERS   = "$NAME version: 0.1.1";
my $DTVERS = "DNSSEC-Tools Version: 0.9.1";

#######################################################################
#
# Data required for command line options.
#
my %options = ();			# Filled option array.
my @opts =
(
	"noskip",			# Don't show skipped zones.
	"nomodify",			# Don't allow zones to be modified.

	"Version",			# Display the version number.
	"help",				# Give a usage message and exit.
);

#
# Flags for the options.  Variable/option mapping should obvious.
#
my $noskip;
my $nomodify;

my $version	= 0;			# Display the version number.

#######################################################################

#
# blinkenlight's configuration file.
#
my $CONFIG = "rc.blinkenlights";

#######################################################################
#
# Data involved with display.
#

#
# Row constants.
#
my $STARTROW = 1;		# First row on which zone info will be shown.
my $ROWINCR  = 3;		# Number of rows for each zone.

#
# Font size for output window.
#
my $fontsize = 18;
my $font = "*-*-bold-r-*-*-$fontsize-*-*-*-*-*-*-*";

#
# Background colors for the zones,  cycling through the list for table rows.
#
my $NUMCOLORS = 3;				# Maximum number of colors.
my $colorind = 0;				# Current color index.
my $skipcolor = "grey";				# Color for skip zones.

my @phasecolors =
(
	['blue', 'LightBlue2',  'skyblue1',  'cornflower blue', 'dodger blue'],
	['red',  'pink',        'indianred', 'violetred1',      'orangered1'],
	['green', 'lightgreen', 'seagreen1', 'greenyellow',	'lawngreen'], 
);

#
# Descriptions of the rollover phases.
#
my @phasedescr =
(
	"  normal operation  ",			# phase 0
	"  first cache-expire wait  ",		# phase 1
	"  sign with ZSKCUR and ZSKPUB  ",	# phase 2
	"  second cache-expire wait  ",		# phase 3
	"  sign with ZSKPUB and ZSKNEW  ",	# phase 4
);

#######################################################################
#
# Global Tk widgets.
#

#
# The main window and its frames.
#
my $wm;							# Main window.
my $helpwin;						# Help window.
my $mbar;						# Menubar frame.
my $body;						# Window body frame.
my $zonetab;						# Zone data table.
my $null;						# Empty frame.

my $bodyframe;						# Frame in body.

#
# Menu item widgets.
#
my $fm_quit;						# Quit file item.
my $dm_togl;						# Viewing toggle.
my $hm_help;						# Help item.

#######################################################################
#
# Global shtuff.
#

#
# Flags.
#
my $inhelpwind = 0;					# Showing help window.

#
# Filename variables.
#
my $rrfile = "dummy";					# Our rollrec file.
my $title = "dummy";					# Node for title.

#
# Zone information.
#
my %rollers = ();				# Zones that might roll.
my %zones = ();					# Zones we're watching.
my %zonecolors = ();				# Zone color indices.
my %zonerows = ();				# Zones' starting-row indices.
my @zonenames = ();				# Screen-order list of zones.
my $zonecnt = 1;				# Count of zones we're watching.
my %keyrecs = ();				# Zones' keyrec filenames.

#
# Saved zone data, needed for repaints.
#
my %zonephase = ();				# Zones' phases.
my %zonechron = ();				# Zones' chronoses.

#
# Data for button-selected zones.
#
my $selzone;					# Selected zone name.
my $lastrow = $STARTROW;			# Final row index.

###########################################################################

main();
exit(0);

#---------------------------------------------------------------------------
# Routine:	main()
#
sub main
{
	#
	# Check for options.
	#
	optsandargs();

	#
	# Read our configuration file.
	#
	readconfig();

	#
	# Build the main window.
	#
	buildmainwind();

	#
	# Start the whole shebang rollin'.
	#
	MainLoop;
}

#---------------------------------------------------------------------------
# Routine:	optsandargs()
#
# Purpose:	Parse the command line for options and arguments.
#
sub optsandargs
{
	my $argc = shift;			# Command line argument count.

	#
	# Parse the options.
	#
	GetOptions(\%options,@opts) || usage();

	#
	# Set our option variables based on the parsed options.
	#
	$noskip	  = $options{'noskip'}	 || 0;
	$nomodify = $options{'nomodify'} || 0;
	$version  = $options{'Version'}	 || 0;

	#
	# Show the version number if requested
	#
	version() if(defined($options{'Version'}));

	#
	# Give a usage flag if asked.
	#
	usage() if(defined($options{'help'}));

	$rrfile = $ARGV[0];
}

#---------------------------------------------------------------------------
# Routine:	buildmainwind()
#
sub buildmainwind
{
	my $file;					# File menu.
	my $disp;					# Edit menu.
	my $cmds;					# Commands menu.
	my $help;					# Help menu.

	my $curfile;					# Current keyrec.
	my $nulline;					# Empty line.

	my $zn_entry;					# Zone menu entry.

	#
	# Create the main window.
	#
	$wm = MainWindow->new(-title => "blinkenlights");

	#
	# Create the frames we'll need.
	#
	$mbar = $wm->Frame(-relief => 'raised', -borderwidth => 1);
	$body = $wm->Frame(-relief => 'raised', -borderwidth => 1);
	$null = $wm->Frame(-relief => 'raised', -borderwidth => 1);

	$mbar->pack(-anchor => 'n', -side => 'top', -fill => 'x', -expand => 1);
	$body->pack(-anchor => 'n', -side => 'top', -fill => 'x', -expand => 1);
	$null->pack(-fill => 'x', -expand => 1);

	#
	# Create our menus.
	#
	$file = $mbar->Menubutton(-text	     => 'File',
				  -tearoff   => 0,
				  -underline => 0);
	$disp = $mbar->Menubutton(-text	     => 'Display',
				  -tearoff   => 0,
				  -underline => 0);
	$cmds = $mbar->Menubutton(-text	     => 'Zone Control',
				  -tearoff   => 0,
				  -underline => 0);
	$help = $mbar->Menubutton(-text      => 'Help',
				  -tearoff   => 0,
				  -underline => 0);

	##################################################
	#
	# Add the File menu entries.
	#
	$fm_quit = $file->command(-label => 'Quit',
			          -command => \&file_quit,
			          -accelerator => 'Ctrl+Q',
			          -underline => 0);
	$file->pack(-side => 'left');

	$wm->bind('<Control-Key-Q>',\&file_quit);
	$wm->bind('<Control-Key-q>',\&file_quit);

	##################################################
	#
	# Add the Zone Control menu entries.
	#
	$zn_entry = $cmds->command(-label => 'Roll Selected Zone',
				   -command => [\&zone_rollcmd, "rollzone"]);
	$zn_entry = $cmds->command(-label => 'Roll All Zones',
				   -command => [\&zone_rollcmd, "rollall"]);
	$zn_entry = $cmds->command(-label => 'Run the Queue',
				   -command => [\&zone_rollcmd, "runqueue"]);
	$cmds->separator();

	$zn_entry = $cmds->command(-label => 'Skip Selected Zone',
				   -command => [\&zone_rollcmd, "skipzone"]);
	$zn_entry = $cmds->command(-label => 'Skip All Zones',
				   -command => [\&zone_rollcmd, "skipall"]);
	$cmds->separator();

	$zn_entry = $cmds->command(-label => 'Halt Rollerd',
				   -command => [\&zone_rollcmd, "halt"]);

	$cmds->pack(-side => 'left');

	##################################################
	#
	# Create a line holding the current keyrec filename.
	#
	$curfile = $mbar->Label(-text => "                         Monitoring Rollrec File:  ");
	$curfile->pack(-side => 'left');
	$curfile = $mbar->Label(-textvariable => \$title);
	$curfile->pack(-side => 'left');
	$mbar->pack(-side => 'top', -fill => 'x');

	##################################################
	#
	# Add the Help menu entries.
	#
	$hm_help = $help->command(-label => 'Help',
			          -command => \&help_help,
			          -accelerator => 'Ctrl+H',
			          -underline => 0);
	$help->pack(-side => 'right');

	$wm->bind('<Control-Key-H>',\&help_help);
	$wm->bind('<Control-Key-h>',\&help_help);

	##################################################
	#
	# Add a container and scrollbar to the body.
	#
	$body->grid();
	$zonetab = $body->Table(-rows => 12, -columns => 5,
				-scrollbars  => 'e',
				-relief	     => 'raised',
				-borderwidth => 1,
				-fixedrows => 0,
				-takefocus => 1,
			       );
#	$zonetab->pack(-fill => 'x', -expand => 1);
#	$body->pack(-fill => 'x', -expand => 1);
	$zonetab->pack(-fill => 'both', -expand => 1);
	$body->pack(-fill => 'both', -expand => 1);

	#
	# Get the keyrec file info.
	#
	readrrf($rrfile);

	#
	# Initialize our rollerd-input handler.
	#
	$wm->fileevent('STDIN',readable => \&rollerdcmd);
#	$wm->bind('<Button>',\&selector);
}

##############################################################################
#
# Menu widget interface routines.
#
##############################################################################

#---------------------------------------------------------------------------
# Routine:	file_quit()
#
sub file_quit
{
	exit(0);
}

#---------------------------------------------------------------------------
# Routine:	zone_rollcmd()
#
sub zone_rollcmd
{
	my $rcmd = shift;				# Command to run.

	#
	# These commands need a zone.  We've got to query the user for
	# one, but until then they're unimplemented.
	#
	if(($rcmd eq "rollzone") || ($rcmd eq "skipzone"))
	{
		my $zone;				# Zone to handle.

		$zone = getzone($rcmd);
		return if($zone eq "");
		$rcmd = "$rcmd $zone"
	}

	#
	# Build and execute the command string.
	#
	$rcmd = "rollctl -$rcmd";
	system($rcmd);

	#
	# Wait a short bit and exit if rollerd hasn't killed us.
	#
	if($rcmd eq "halt")
	{
		sleep(5);
		exit(0);
	}
}

##############################################################################
#
# Utility routines
#
##############################################################################

#---------------------------------------------------------------------------
# Routine:	headerstripe()
#
# Purpose:	Puts a header line in the top table row.
#
sub headerstripe
{
	my $lab;

	$lab = $zonetab->Label(-text => 'Zone Name    ',
			       -font => $font, -background => 'tan');
	$zonetab->put(0,0,$lab);

	$lab = $zonetab->Label(-text => 'Rollover Phase    ',
			       -font => $font, -background => 'tan');
	$zonetab->put(0,1,$lab);

	$lab = $zonetab->Label(-text => 'ZSK Type    ',
			       -font => $font, -background => 'tan');
	$zonetab->put(0,2,$lab);

	$lab = $zonetab->Label(-text => 'ZSK Name    ',
			       -font => $font, -background => 'tan');
	$zonetab->put(0,3,$lab);
}

#---------------------------------------------------------------------------
# Routine:	zonestripe()
#
# Purpose:	Puts a line for the specified zone in the table.
#
sub zonestripe
{
	my $zone    = shift;				# Zone to add.
	my $phase   = shift;				# Zone's rollover phase.
	my $chronos = shift || " ";			# Expiration-time data.

	my $bgcolor;					# Background color.
	my $phasecolor;					# Color of phase column.

	my $row0;					# First row in group.
	my $row1;					# Second row in group.
	my $row2;					# Third row in group.

	my $zskcur;					# Current ZSK.
	my $zskpub;					# Published ZSK.
	my $zsknew;					# New ZSK.

	my $blank;					# Blank label.
	my $lab;					# Non-blank label.
	my $zonetxt;					# Zone name.

	#
	# Get this zone's row group and row indices.
	#
	$row0 = $zonerows{$zone};
	return if($row0 == 0);
	$row1 = $row0 + 1;
	$row2 = $row0 + 2;

	#
	# Get this zone's background color.
	#
	$bgcolor    = getcolor($zone,$phase,1);
	$phasecolor = getcolor($zone,$phase,0);

	#
	# Save this zone's data in case we need a repaint.
	#
	$zonephase{$zone} = $phase;
	$zonechron{$zone} = $chronos;

	#
	# Set the zone name's field.  (We're setting this here so it can
	# be modified in a single place.)
	#
	$zonetxt  = "$zone    ";
#	$zonetxt  = "  $zone  ";

	#
	# Handle skipped zones here.  We won't do anything if skipped zones
	# shouldn't be displayed.  Otherwise, we'll just put up a single line.
	#
	#	column 1	column 2	column 3	column 4
	#	zone name	"skipped"	<blank>		<blank>
	#
	if(($rollers{$zone} == 0) || ($phase == -42))
	{
		return if($noskip);

		$lab = $zonetab->Label(-text => $zonetxt, -font => $font,
			       -background => $bgcolor);
#			       -background => $bgcolor, -anchor => 'w');
		$zonetab->put($row0,0,$lab);

		$lab = $zonetab->Label(-text => 'skipping', -font => $font,
				       -background => $bgcolor);
		$zonetab->put($row0,1,$lab);

		$blank = $zonetab->Label(-text => ' ', -background => $bgcolor);
		$zonetab->put($row0,2,$blank);

		$blank = $zonetab->Label(-text => ' ', -background => $bgcolor);
		$zonetab->put($row0,3,$blank);

		#
		# Update the display.
		#
		$zonetab->update();
		return;
	}

	############################################
	#
	# First column:  zone name
	#
	$blank = $zonetab->Label(-text => ' ', -background => $bgcolor);
	$zonetab->put($row0,0,$blank);
	$lab = $zonetab->Label(-text => $zonetxt, -font => $font,
			       -background => $bgcolor);
#			       -background => $bgcolor, -anchor => 'w');

	$zonetab->put($row1,0,$lab);
	$blank = $zonetab->Label(-text => ' ', -font => $font,
				 -background => $bgcolor);
	$zonetab->put($row2,0,$blank);

	###########################################
	#
	# Second column:  zone rollover phase
	#
	$lab = $zonetab->Label(-text => $phase, -font => $font,
			       -background => $phasecolor);
	$zonetab->put($row0,1,$lab);
	$lab = $zonetab->Label(-text => $phasedescr[$phase],
			       -font => $font,
			       -background => $phasecolor);
	$zonetab->put($row1,1,$lab);
	$lab = $zonetab->Label(-text => $chronos, -font => $font,
			       -background => $phasecolor);
	$zonetab->put($row2,1,$lab);

	###########################################
	#
	# Third and fourth columns:  zone keys
	#

	#
	# Get the zone's key names.
	#
	my $krf = $keyrecs{$zone};
	keyrec_read($krf);
	$zskcur = keyrec_recval($zone,'zskcur');
	$zskpub = keyrec_recval($zone,'zskpub');
	$zsknew = keyrec_recval($zone,'zsknew');
	keyrec_close();

	#
	# Add some spacing to the fields.
	#
	$zskcur	 .= "    ";
	$zskpub	 .= "    ";
	$zsknew	 .= "    ";

	#
	# Third column:  key label
	#
	$lab = $zonetab->Label(-text => "Current   ", -font => $font,
			       -background => $bgcolor, -anchor => 'w');
	$zonetab->put($row0,2,$lab);
	$lab = $zonetab->Label(-text => "Published   ", -font => $font,
			       -background => $bgcolor, -anchor => 'w');
	$zonetab->put($row1,2,$lab);
	$lab = $zonetab->Label(-text => "New   ", -font => $font,
			       -background => $bgcolor, -anchor => 'w');
	$zonetab->put($row2,2,$lab);

	#
	# Fourth columns:  key name
	#
	$lab = $zonetab->Label(-text => $zskcur, -font => $font,
			       -background => $bgcolor, -anchor => 'w');
	$zonetab->put($row0,3,$lab);

	$lab = $zonetab->Label(-text => $zskpub, -font => $font,
			       -background => $bgcolor, -anchor => 'w');
	$zonetab->put($row1,3,$lab);

	$lab = $zonetab->Label(-text => $zsknew, -font => $font,
			       -background => $bgcolor, -anchor => 'w');
	$zonetab->put($row2,3,$lab);


	#
	# Update the display.
	#
	$zonetab->update();
}

#---------------------------------------------------------------------------
# Routine:	readrrf()
#
sub readrrf
{
	my $rrf = shift;				# Rollrec to read.
	my $rr;						# Rollrec reference.

	#
	# Initialize some data.
	#
	@zonenames = ();
	headerstripe();

	#
	# Pretty-up the window.
	#
	settitle($rrf);
	headerstripe();

	#
	# Get the rollrec contents and the names of the zones it contains.
	#
	rollrec_read($rrf);
	@zonenames = rollrec_names();

	foreach my $zone (@zonenames)
	{
		my $krf;				# Keyrec file.
		my $kr;					# Keyrec reference.
		my $phase;				# Rollover phase.

		#
		# Read the zone's rollrec record and save the current phase.
		#
		$rr = rollrec_fullrec($zone);
		$phase  = $rr->{'curphase'};

		#
		# Save the zone's index and add it (or don't) to our list
		# of roll-enabled zones.
		#
		$zones{$zone} = $zonecnt++;
		$rollers{$zone} = 1;
		$rollers{$zone} = 0 if($rr->{'rollrec_type'} ne "roll");

		#
		# Read the zone's keyrec and save the filename.
		#
		$krf = $rr->{'keyrec'};
		$keyrecs{$zone} = $krf;

		#
		# Figure out where each zone's stripe starts.
		#
		calcrows();

		#
		# Paint the window with this zone's info.
		#
		zonestripe($zone,$phase);
	}

	rollrec_close();
	$zonetab->update();
}

#---------------------------------------------------------------------------
# Routine:	rollerdcmd()
#
sub rollerdcmd
{
	my $line;					# Input from rollerd.
	my $cmd;					# Command.
	my $zone;					# Command's zone.
	my $phase;					# Command's phase.

	#
	# Get the data from rollerd.
	#
	$line = <STDIN>;
	chomp($line);

	#
	# Break the line into its pieces.
	#
	$line =~ /^([a-z]+)\W+([a-zA-z0-9\.\+\-]+)\W+([0-9]+)/;
	$cmd	= $1;
	$zone	= $2;
	$phase	= $3;

	#
	# Exit if this was an empty line.
	#
	exit(0) if($cmd eq '');

	#
	# Handle the commands from rollerd:
	#
	#	phase		change the specified zone's phase
	#	halt		exit
	#	startroll	start a zone in rollover
	#	stoproll	stop a zone's rollover
	#	expiration	zone will soon expire
	#
	if($cmd eq "phase")
	{
		zonestripe($zone,$phase);
	}
	elsif($cmd eq "halt")
	{
		exit(0);
	}
	elsif($cmd eq "startroll")
	{
		rollrec_read($rrfile);
		$phase = rollrec_recval($zone,'curphase');
		rollrec_close();

		$rollers{$zone} = 1;
		calcrows();

		$zonephase{$zone} = $phase;
		repaint();
	}
	elsif($cmd eq "stoproll")
	{
		$rollers{$zone} = 0;
		calcrows();
		$zonephase{$zone} = -42;
		repaint();
	}
	elsif($cmd eq "expiration")
	{
		my $other;				# Additional data.

		$line =~ /^([a-z]+)\W+([a-zA-z0-9\.\+\-]+)\W+([0-9]+)\W(.*)$/;
		$other	= $4;

		$other = "starting roll in $other" if($phase == 0);
		zonestripe($zone,$phase,$other);
	}

	$zonetab->update();
}

#----------------------------------------------------------------------
#
# Routine:      repaint()
#
# Purpose:      Redisplay the current zone data.
#
sub repaint
{
	foreach my $zone (sort(@zonenames))
	{
		zonestripe($zone,$zonephase{$zone},$zonechron{$zone});
	}
}

#----------------------------------------------------------------------
#
# Routine:      calcrows()
#
# Purpose:      Calculate the starting row for each displayed zone.
#
sub calcrows
{
	my $row = $STARTROW;				# Starting-row index.

	#
	# Zap the zone row index table and zone-colors table.
	#
	%zonerows = ();
	%zonecolors = ();

	#
	# Reset the color index.
	#
	$colorind = 0;

	#
	# Sort the zone-names list and set the zone row index table
	# according to whether or not each zone is displayed.
	#
	foreach my $zn (sort(@zonenames))
	{
		#
		# Save the row index for the zone name and in case this
		# is the last row.
		#
		$zonerows{$zn} = $row;
		$lastrow = $row;

		if($noskip && ($rollers{$zn} == 0))
		{
			$zonerows{$zn} = 0;
			next;
		}

		if($rollers{$zn} == 0)
		{
			$row += 1;
		}
		else
		{
			$row += $ROWINCR;

			$zonecolors{$zn} = $colorind;
			$colorind++;
			$colorind = 0 if($colorind == $NUMCOLORS);
		}
	}

}

#---------------------------------------------------------------------------
# Routine:	getnode()
#
sub getnode
{
	my @pathelts;					# Path elements.
	my $pathnode;					# Last path elements.

	@pathelts = split /\//, $rrfile;
	$pathnode = pop @pathelts;

	return($pathnode);
}

#---------------------------------------------------------------------------
# Routine:	getcolor()
#
sub getcolor
{
	my $zone = shift;		# Zone whose color we're getting.
	my $phase = shift;		# Zone's phase.
	my $base = shift;		# Base-color flag.

	my $band;			# Zone's output band.
	my $color;			# Color to return.

	#
	# Return this skipped-zone color if this zone isn't rolling.
	#
	return($skipcolor) if($rollers{$zone} != 1);

	#
	# Get the background color for this zone in this phase.
	#
	$band = $zonecolors{$zone};

	#
	# Get the background color for this zone in this phase and
	# return the color.
	#
	$color = $phasecolors[$band];
	return($color->[0]) if($base);
	return($color->[$phase]);
}

#---------------------------------------------------------------------------
# Routine:	getzone()
#
# Purpose:	This routine creates a modal dialog box to allow the user
#		to select a zone to be rolled/skipped.  For to-be-rolled
#		zones, only those zones are listed which are currently
#		skipped.  Similarly, for to-be-skipped zones, only those
#		zones are listed which are currently being rolled.
#
sub getzone
{
	my $op = shift;					# Operation for zone.
	my $opflag = 0;					# Operation flag.

	my $dlg;					# Dialog widget.
	my $zlist;					# Zone listbox.

	my $listcnt = 0;				# Count of listed zones.

	my $ret;					# Dialog's return value.
	my @indarr;					# Listbox' select array.
	my $selzone;					# Selected zone.
	my @selzones;					# Selected zones.

my $DLGHEIGHT = 10;
	my $height = $DLGHEIGHT;			# Height of dialog box.
	my $zonecount = @zonenames;			# Number of zones.

	#
	# Set the zone operation flag.
	#
	$opflag = 1 if($op eq "rollzone");

	#
	# Massage the zone operation for the dialog box's title.
	#
	$op =~ s/zone//;
	$op = ucfirst($op);

	#
	# Set the dialog box height.
	#
	$height = $zonecount if($zonecount < $height);

	#
	# Build and configure the dialog box and the widgets it contains.
	#
	$dlg = $wm->Dialog(-title => "Select Zone to $op", -text  => '',
			   -default_button => "Okay",
			   -buttons => ["Okay", "Cancel"]);
	$zlist = $dlg->Listbox(-relief	    => 'raised',
			       -borderwidth => 1,
			       -selectmode  => 'single');
	$dlg->AddScrollbars($zlist);
	$dlg->configure(-scrollbars => 'e');

	#
	# Add the zone names to the dialog's listbox.  However, we'll
	# only add rolling zones to a skip-zone command and we'll
	# only add skipped zones to a roll-zone command.
	#
	foreach my $zone (sort(@zonenames))
	{
		if((!$opflag && ($rollers{$zone} == 1))		||
		   ( $opflag && ($rollers{$zone} == 0)))
		{
			$zlist->insert("end",$zone);
			$listcnt++;
		}
	}

	#
	# If there weren't any zones added, we'll return 'cause there's
	# nothing for us to do.  The pack() is to keep Tk from whining.
	#
	if($listcnt == 0)
	{
		$zlist->pack(-fill => 'x', -expand => 1);
		return;
	}

	#
	# Pack 'er up and display the zone list.
	#
	$zlist->pack(-fill => 'x', -expand => 1);
	$ret = $dlg->Show();

	#
	# Go no further if no zone was selected.
	#
	return("") if($ret eq "Cancel");

	#
	# Dig out the selected zone and return it.
	#
	@indarr = $zlist->curselection;
	return("") if(@indarr == 0);
	@selzones = $zlist->get($indarr[0]);
	$selzone = $selzones[0];
	return($selzone);
}

#----------------------------------------------------------------------
#
# Routine:      settitle()
#
# Purpose:      Set the title for use in the "Monitoring File" line.
#
sub settitle
{
	my $name = shift;				# Name to use.

	$title = getnode($name);
}

#---------------------------------------------------------------------------
# Routine:	error()
#
sub error
{
	my $msg = shift;			# Warning message.
	my $dlg;				# Warning dialog widget.

	$dlg = $wm->Dialog(-title => "$NAME Warning",
			   -text  => $msg,
			   -default_button => "Okay",
			   -buttons => ["Okay"]);
	$dlg->Show();
}

#---------------------------------------------------------------------------
# Routine:      helpbegone()
#
sub helpbegone
{
	$helpwin->destroy();
	$inhelpwind = 0;
}

#---------------------------------------------------------------------------
# Routine:	help_help()
#
sub help_help
{
	my $hframe;					# Help frame.
	my $wdgt;					# General widget.

	my $helpstr;

	$helpstr = "

blinkenlights - DNSSEC-Tools Rollerd Demo
         
SYNOPSIS
         
    blinkenlights <rollrec-file>

DESCRIPTION

blinkenlights is a demo tool for use with the DNSSEC-Tools rollerd
program.  As rollerd rolls the zones listed in the rollrec file,
blinkenlights will display status information for the file's zones.

For ease of reading, each zone's row is a different color.  The rollover
phase column color will change, depending on the current phase.  When the
zone's phase returns to not being in mid-rollover, the color will match that
of the rest of the row.

This is only intended to be started by rollerd.  The -display option must
be given on rollerd's command line in order to have it start blinkenlights.

";

	#
	# If we've already got another help window, we'll give an error and
	# return.  Otherwise, we'll turn on our in-helpwindow flag.
	#
	if($inhelpwind)
	{
		error("Multiple help windows cannot be created\n");
		return;
	}
	$inhelpwind = 1;

	#
	# Create a new window to hold our help info.  Bind up some
	# key accelerators, too.
	#
	$helpwin = MainWindow->new(-relief => 'raised',
				  -title  => 'Help!',
				  -borderwidth => 1);
	$helpwin->bind('<Control-Key-Q>',\&file_quit);
	$helpwin->bind('<Control-Key-q>',\&file_quit);
	$helpwin->bind('<Control-Key-W>',\&helpbegone);
	$helpwin->bind('<Control-Key-w>',\&helpbegone);

	#
	# Now make the containers for the window.
	#
	$hframe = $helpwin->Frame(-relief => 'raised', -borderwidth => 1);

	$hframe->pack(-fill => 'x');

	#
	# Add the help data to the frame.
	#
	$wdgt = $hframe->Label(-text => $helpstr,
			       -justify => 'left');
	$wdgt->pack(-side => 'top');

	#
	# Add a button to dismiss the window.
	#
	$wdgt = $hframe->Button(-text => 'Done',
				-command => \&helpbegone);
	$wdgt->pack(-side => 'top');
}

#---------------------------------------------------------------------------
# Routine:	readconfig()
#
# Purpose:      Read our configuration file.  Config entries are "field value"
#		pairs, with the following fields recognized:
#
#			fontsize	size of demo output font
#			skipcolor	color to use for skip records
#
sub readconfig
{
	my $line;					# Configuration line.
	my $field;					# Field name from line.
	my $value;					# Field value from line.

	#
	# Return if we don't have a configuration file.
	#
	return if(!-e $CONFIG);

	#
	# Complain and return if we can't read our configuration file.
	#
	if(!-r $CONFIG)
	{
		print STDERR "unable to read $CONFIG; continuing...\n";
		return;
	}

	#
	# Read the config file, ignoring comment lines.  Each non-comment
	# line is expected to be in a "field value" pair.  As we read each
	# line, we'll take the appropriate action.
	#
	open(CONF,"<$CONFIG");
	while(<CONF>)
	{
		$line = $_;
		chomp($line);

		#
		# Skip empty and comment lines.
		#
		$line =~ s/^[ \t]+//;
		next if(($line =~ /^\#/) || ($line =~ /^$/));

		#
		# Pull out the field and value from the line.
		#
		$line =~ /([a-zA-Z_\-]+)\W+([a-zA-Z0-9_\-]+)/;
		$field = lc($1);
		$value = $2;

		#
		# Handle the field values appropriately.
		#
		if($field eq "fontsize")
		{
			if($value =~ /[a-zA-Z\_\-]/)
			{
				print STDERR "invalid fontsize \"$value\" in configuration file\n";
				next;
			}
			$fontsize = $value;
		}
		elsif($field eq "skipcolor")
		{
			$skipcolor = $value;
		}
	}

	close(CONF);
}

#----------------------------------------------------------------------
#
# Routine:      version()
#
# Purpose:      Print the version number(s) and exit.
#
sub version
{
	print STDERR "$VERS\n";
	print STDERR "$DTVERS\n";
	exit(0);
}

#---------------------------------------------------------------------------
# Routine:	usage()
#
# Purpose:      Print a usage message and exit.
#
sub usage
{
	print STDERR "usage:  blinkenlights [-Version] <rollrec-file>\n";
	exit(0);
}

1;

#############################################################################

=pod

=head1 NAME

blinkenlights - DNSSEC-Tools Rollerd Demo

=head1 SYNOPSIS

  blinkenlights <rollrec-file>

=head1 DESCRIPTION

B<blinkenlights> is a display tool for use with the DNSSEC-Tools B<rollerd>
program.  As B<rollerd> rolls the zones listed in the I<rollrec> file,
B<blinkenlights> will display status information for the file's zones.

For ease of reading, each zone's row is a different color.  The I<rollover
phase> column color will change, depending on the current phase.  When the
zone's phase returns to not being in mid-rollover, the color will match that
of the rest of the row.

This is only intended to be started by B<rollerd>.  The I<-display>
option must be given on B<rollerd>'s command line in order to have it
start B<blinkenlights>.

=head1 CONFIGURATION FILE

B<blinkenlights> has a configuration file in B<rc.blinkenlights>.  This file
controls several aspects of the output.  This file is B<only> searched for in
the current directory.  This file is in the "field value" format, where
I<field> specifies the output aspect and I<value> defines the value for that
field.  The following are the recognized fields:

    fontsize	The size of the font in the output window
    skipcolor	The background color used for skipped zones.

Empty lines and comments are ignored.  Comment lines are lines that start
with an octothorpe ('#').

Spaces are not allowed in the configuration values.  Choose your skipcolors
carefully...

=head1 REQUIREMENTS

I<blinkenlights> is implemented in Perl/Tk, so both Perl and Perl/Tk must be
installed on your system.

=head1 COPYRIGHT

Copyright 2006 SPARTA, Inc.  All rights reserved.
See the COPYING file included with the DNSSEC-Tools package for details.

=head1 AUTHOR

Wayne Morrison, tewok@users.sourceforge.net

=head1 SEE ALSO

B<rollerd(8)>,
B<zonesigner(8)>

B<Net::DNS::SEC::Tools::keyrec(5)>,
B<Net::DNS::SEC::Tools::rollrec(5)>

=cut

