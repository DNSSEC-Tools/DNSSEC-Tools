#!/usr/bin/perl
#
# Copyright 2006 SPARTA, Inc.  All rights reserved.  See the COPYING
# file distributed with this software for details
#
# DNSSEC-Tools:  blinkenlights
#
#	blinkenlights is a display tool for use with the DNSSEC-Tools rollerd
#	program.  As rollerd rolls the zones listed in the rollrec file,
#	blinkenlights will display status information for the file's zones.
#
#	blinkenlights is implemented in Perl/Tk, so both Perl and Perl/Tk must
#	be installed on your system.
#

use strict;

use Getopt::Long;

use Tk;
use Tk::Dialog;
use Tk::Table;

use Net::DNS::SEC::Tools::keyrec;
use Net::DNS::SEC::Tools::rollrec;
use Net::DNS::SEC::Tools::timetrans;

#
# Version information.
#
my $NAME   = "blinkenlights";
my $VERS   = "$NAME version: 0.1.1";
my $DTVERS = "DNSSEC-Tools Version: 0.9.1";

#######################################################################
#
# Data required for command line options.
#
my %options = ();			# Filled option array.
my @opts =
(
	"noskip",			# Don't show skipped zones.
	"nomodify",			# Don't allow zones to be modified.
	"noshading",			# Don't change colors in column 2.

	"Version",			# Display the version number.
	"help",				# Give a usage message and exit.
);

#
# Flags for the options.  Variable/option mapping should obvious.
#
my $nomodify;
my $noshading;
my $noskip;

my $version	= 0;			# Display the version number.

#######################################################################

#
# blinkenlight's configuration file.
#
my $CONFIG = "rc.blinkenlights";

#######################################################################
#
# Data involved with display.
#

#
# Row constants.
#
my $INFOROW  = 0;		# Row on which columns titles will be shown.
my $TITLEROW = 1;		# Row on which columns titles will be shown.
my $STARTROW = 2;		# First row on which zone info will be shown.
my $ROWINCR  = 3;		# Number of rows for each zone.

#
# Column constants.
#
my $RRFCOL	= 0;		# Infostripe column holding rollrec filename.
my $ROLLCNTCOL	= 1;		# Infostripe column holding rolled zones count.
my $SKIPCNTCOL	= 2;		# Infostripe column holding skipped zones count.
my $OTHERCOL	= 3;		# Infostripe column holding something else.

my $PAINTMAX	= 100;		# Maximum screen paints before screen rebuild.
my $paintcount	= -1;		# Count of screen paints.

my $DLGHEIGHT = 10;		# Height of the dialog box.

#
# Font size for output window.
#
my $fontsize = 18;
my $font = "*-*-bold-r-*-*-$fontsize-*-*-*-*-*-*-*";

#
# Foreground colors for zones.
#
my $NORMALFG	= 'black';			# Normal foreground color.
my $SELECTEDFG	= 'white';			# Selected foreground color.

#
# Background colors for the zones, cycling through the list for table rows.
#
my $NUMCOLORS = 3;				# Maximum number of colors.
my $INFOBG = "white";				# Color for the info row.

my $colorind = 0;				# Current color index.
my $skipcolor = "grey";				# Color for skip zones.

my @phasecolors =
(
	['blue', 'LightBlue2',  'skyblue1',  'cornflower blue', 'dodger blue'],
	['red',  'pink',        'indianred', 'violetred1',      'orangered1'],
	['green', 'lightgreen', 'seagreen1', 'greenyellow',	'lawngreen'], 
);

#
# Descriptions of the rollover phases.
#
my @phasedescr =
(
	"  normal operation  ",			# phase 0
	"  first cache-expire wait  ",		# phase 1
	"  sign with ZSKCUR and ZSKPUB  ",	# phase 2
	"  second cache-expire wait  ",		# phase 3
	"  sign with ZSKPUB and ZSKNEW  ",	# phase 4
);

#######################################################################
#
# Global Tk widgets.
#

#
# The main window and its frames.
#
my $wm;							# Main window.
my $mbar;						# Menubar frame.
my $helpwin;						# Help window.
my $body;						# Window body frame.
my $zonetab;						# Zone data table.
my $null;						# Empty frame.

my $file;						# File menu.
my $disp;						# Edit menu.
my $cmds;						# Commands menu.
my $help;						# Help menu.

#
# Menu item widgets.
#
my $fm_quit;						# Quit file item.
my $op_mdfy;						# Modify toggle.
my $op_shad;						# Shading toggle.
my $op_skip;						# Skip toggle.
my $hm_help;						# Help item.

#
# Messages for the Display menu.
#
my $ALLOWCMDS	 = "Allow Commands";
my $DISALLOWCMDS = "Disallow Commands";

my $SHADING	 = "Shade Status Column";
my $NOSHADING	 = "Don't Shade Status Column";

my $SHOWSKIP	 = "Display Skipped Zones";
my $NOSKIP	 = "Hide Skipped Zones";

my $shademsg;						# Message about shading.

#######################################################################
#
# Global shtuff.
#

#
# Flags.
#
my $inhelpwind = 0;				# Flag for showing help window.

#
# Filename variables.
#
my $rrfile = "dummy";				# Rollrec file being watched.
my $title = "dummy";				# File node for title.

#
# Zone information.
#
my %rollers = ();				# Zones that might roll.
my %zones = ();					# Zones we're watching.
my %zonecolors = ();				# Zone color indices.
my %zonerows = ();				# Zones' starting-row indices.
my @zonenames = ();				# Screen-order list of zones.
my $zonecnt = 1;				# Count of zones we're watching.
my %keyrecs = ();				# Zones' keyrec filenames.

#
# Saved zone data, needed for repaints.
#
my %zonephase = ();				# Zones' phases.
my %zonechron = ();				# Zones' chronoses.

#
# Data for the info stripe.
#
my $rollcntmsg = ' ';				# Count of rolled zones.
my $skipcntmsg = ' ';				# Count of skipped zones.

#
# Data for button-selected zones.
#
my $selzone;					# Selected zone name.
my $selwidget;					# Selected zone's widget.
my $lastrow = $STARTROW;			# Final row index.

###########################################################################

main();
exit(0);

#---------------------------------------------------------------------------
# Routine:	main()
#
# Purpose:	Do shtuff.
#
sub main
{
	$| = 1;

	#
	# Check for options.
	#
	optsandargs();

	#
	# Read our configuration file.
	#
	readconfig();

	#
	# Build the main window.
	#
	buildmainwind();

	#
	# Start the whole shebang rollin'.
	#
	MainLoop;
}

#---------------------------------------------------------------------------
# Routine:	optsandargs()
#
# Purpose:	Parse the command line for options and arguments.
#
sub optsandargs
{
	my $argc = shift;			# Command line argument count.

	#
	# Parse the options.
	#
	GetOptions(\%options,@opts) || usage();

	#
	# Set our option variables based on the parsed options.
	#
	$noskip	   = $options{'noskip'}	   || 0;
	$nomodify  = $options{'nomodify'}  || 0;
	$noshading = $options{'noshading'} || 0;
	$version   = $options{'Version'}   || 0;

	#
	# Show the version number if requested
	#
	version() if(defined($options{'Version'}));

	#
	# Give a usage flag if asked.
	#
	usage() if(defined($options{'help'}));

	$rrfile = $ARGV[0];
}

#---------------------------------------------------------------------------
# Routine:	buildmainwind()
#
# Purpose:	Build the main window.
#
sub buildmainwind
{
	my $curfile;					# Current keyrec.
	my $nulline;					# Empty line.

	my $zn_entry;					# Zone menu entry.
	my $modmsg;					# Modify menu message.
	my $skipmsg;					# Skip menu message.

	#
	# Create the main window.
	#
	$wm = MainWindow->new(-title => "blinkenlights");

	#
	# Create the frames we'll need.
	#
	$mbar = $wm->Frame(-relief => 'raised', -borderwidth => 1);
	$body = $wm->Frame(-relief => 'raised', -borderwidth => 1);
	$null = $wm->Frame(-relief => 'raised', -borderwidth => 1);

	$mbar->pack(-anchor => 'n', -side => 'top', -fill => 'x', -expand => 1);
	$body->pack(-anchor => 'n', -side => 'top', -fill => 'x', -expand => 1);
	$null->pack(-fill => 'x', -expand => 1);

	#
	# Create our menus.
	#
	$file = $mbar->Menubutton(-text	     => 'File',
				  -tearoff   => 0,
				  -underline => 0);
	$disp = $mbar->Menubutton(-text	     => 'Options',
				  -tearoff   => 0,
				  -underline => 0);
	$cmds = $mbar->Menubutton(-text	     => 'Zone Control',
				  -tearoff   => 1,
				  -underline => 0);
	$help = $mbar->Menubutton(-text      => 'Help',
				  -tearoff   => 0,
				  -underline => 0);
	$mbar->pack(-side => 'top', -fill => 'x');

	##################################################
	#
	# Add the File menu entries.
	#
	$fm_quit = $file->command(-label => 'Quit',
			          -command => \&file_quit,
			          -accelerator => 'Ctrl+Q',
			          -underline => 0);
	$file->pack(-side => 'left');

	$wm->bind('<Control-Key-Q>',\&file_quit);
	$wm->bind('<Control-Key-q>',\&file_quit);

	##################################################
	#
	# Add the Options menu entries.
	#
	$shademsg = $NOSHADING;
	$shademsg = $SHADING if($noshading);
	$op_shad = $disp->command(-label => $shademsg,-command => \&disp_shade);
	$disp->pack(-side => 'left');

	$skipmsg = $NOSKIP;
	$skipmsg = $SHOWSKIP if($noskip);
	$op_skip = $disp->command(-label => $skipmsg, -command => \&disp_skip);
	$disp->pack(-side => 'left');

	$modmsg = $DISALLOWCMDS;
	$modmsg = $ALLOWCMDS if($nomodify);
	$op_mdfy = $disp->command(-label => $modmsg, -command => \&disp_modify);
	$disp->pack(-side => 'left');

	##################################################
	#
	# Add the Zone Control menu entries.
	#
	$zn_entry = $cmds->command(-label => 'Roll Selected Zone',
				   -command => [\&zone_rollcmd, "rollzone"],
			           -accelerator => 'Ctrl+R');
	$zn_entry = $cmds->command(-label => 'Roll All Zones',
				   -command => [\&zone_rollcmd, "rollall"]);
	$zn_entry = $cmds->command(-label => 'Run the Queue',
				   -command => [\&zone_rollcmd, "runqueue"]);
	$cmds->separator();

	$zn_entry = $cmds->command(-label => 'Skip Selected Zone',
				   -command => [\&zone_rollcmd, "skipzone"],
			           -accelerator => 'Ctrl+S');
	$zn_entry = $cmds->command(-label => 'Skip All Zones',
				   -command => [\&zone_rollcmd, "skipall"]);
	$cmds->separator();

	$zn_entry = $cmds->command(-label => 'Halt Rollerd',
				   -command => [\&zone_rollcmd, "halt"]);

	$cmds->pack(-side => 'left');

	$wm->bind('<Control-Key-R>', \&zone_rollzone);
	$wm->bind('<Control-Key-r>', \&zone_rollzone);
	$wm->bind('<Control-Key-S>', \&zone_skipzone);
	$wm->bind('<Control-Key-s>', \&zone_skipzone);

	if($nomodify)
	{
		$cmds->configure(-state => 'disabled');
	}

	##################################################
	#
	# Add the Help menu entries.
	#
	$hm_help = $help->command(-label => 'Help',
			          -command => \&help_help,
			          -accelerator => 'Ctrl+H',
			          -underline => 0);
	$help->pack(-side => 'right');

	$wm->bind('<Control-Key-H>',\&help_help);
	$wm->bind('<Control-Key-h>',\&help_help);

	##################################################
	#
	# Add the big ol' zone-status widget.
	#
	$zonetab = $body->Table(-rows => 12, -columns => 4,
				-scrollbars  => 'e',
				-relief	     => 'raised',
				-borderwidth => 1,
				-fixedrows => 0,
				-takefocus => 1,
			       );
	$zonetab->pack(-fill => 'both', -expand => 1);
	$body->pack(-fill => 'both', -expand => 1);

	#
	# Get the keyrec file info.
	#
	readrrf($rrfile,0);

	#
	# Initialize our rollerd-input handler.
	#
	$wm->fileevent('STDIN',readable => \&rollerdcmd);
	$wm->bind('<Button>',\&selector);
}

##############################################################################
#
# Menu widget interface routines.
#
##############################################################################

#---------------------------------------------------------------------------
# Routine:	file_quit()
#
# Purpose:	Handle the quit menu command.
#
sub file_quit
{
	exit(0);
}

#---------------------------------------------------------------------------
# Routine:	disp_modify()
#
# Purpose:	Handle the Modify menu toggle.
#
sub disp_modify
{
	if($nomodify)
	{
		$op_mdfy->configure(-label => $DISALLOWCMDS);
		$cmds->configure(-state => 'normal');
		$nomodify = 0;
	}
	else
	{
		$op_mdfy->configure(-label => $ALLOWCMDS);
		$cmds->configure(-state => 'disabled');
		$nomodify = 1;
	}
}

#---------------------------------------------------------------------------
# Routine:	disp_shad()
#
# Purpose:	Handle the Shading menu toggle.
#
sub disp_shade
{
	if($noshading)
	{
		$op_shad->configure(-label => $NOSHADING);
		$noshading = 0;
	}
	else
	{
		$op_shad->configure(-label => $SHADING);
		$noshading = 1;
	}

	calcrows();
	repaint();
}

#---------------------------------------------------------------------------
# Routine:	disp_skip()
#
# Purpose:	Handle the Skip menu toggle.
#
sub disp_skip
{
	if($noskip)
	{
		$op_skip->configure(-label => $NOSKIP);
		$noskip = 0;
	}
	else
	{
		$op_skip->configure(-label => $SHOWSKIP);
		$noskip = 1;
	}

	calcrows();
	repaint();
}

#---------------------------------------------------------------------------
# Routine:	zone_rollzone()
#
# Purpose:	Handle the Roll Zone menu command.
#
sub zone_rollzone
{
	return if($rollers{$selzone});
	zone_rollcmd("rollzone");
}

#---------------------------------------------------------------------------
# Routine:	zone_skipzone()
#
# Purpose:	Handle the Skip Zone menu command.
#
sub zone_skipzone
{
	return if(!$rollers{$selzone});
	zone_rollcmd("skipzone");
}

#---------------------------------------------------------------------------
# Routine:	zone_rollcmd()
#
# Purpose:	Handle the Zone Command menu commands.
#
sub zone_rollcmd
{
	my $rcmd = shift;				# Command to run.

	#
	# Don't allow commands if -nomodify was given.
	#
	return if($nomodify);

	#
	# These commands need a zone.  We've got to query the user for
	# one, but until then they're unimplemented.
	#
	if(($rcmd eq "rollzone") || ($rcmd eq "skipzone"))
	{
		my $zone;				# Zone to handle.

		#
		# If a zone has been selected, we'll use it.  If not,
		# we'll prompt the user for the zone.
		#
		if($selzone ne '')
		{
			$rcmd = "$rcmd $selzone";
		}
		else
		{
			$zone = getzone($rcmd);
			return if($zone eq "");
			$rcmd = "$rcmd $zone";
		}
	}

	#
	# Build and execute the command string.
	#
	$rcmd = "rollctl -q -$rcmd";
	system($rcmd);

	#
	# Wait a short bit and exit if rollerd hasn't killed us.
	#
	if($rcmd eq "halt")
	{
		sleep(5);
		exit(0);
	}
}

##############################################################################
#
# Utility routines
#
##############################################################################

#---------------------------------------------------------------------------
# Routine:	paintcnt()
#
# Purpose:	Adjust the screen-painting count as needed.  If we've hit
#		a maximum value, destroy and rebuild the zone table.
#
sub paintcnt
{
	#
	# Set the paint-count to a user-specified value, or increment
	# the current value if one wasn't given.
	#
	if(@_ > 0)
	{
		$paintcount = shift;
	}
	else
	{
		$paintcount++;
	}

	#
	# If we've exceeded our maximum, reset the paint-count and rebuild
	# the zone's table.
	#
	if($paintcount > $PAINTMAX)
	{
		$paintcount = 0;
		buildtable();
	}
}

#---------------------------------------------------------------------------
# Routine:	buildtable()
#
# Purpose:	Rebuild the zone status table.  This also re-reads the
#		current rollrec file, so the zones listed may increase
#		or shrink depending on the state of that file..
#
sub buildtable
{
	#
	# Destroy the zone table's widgets.
	#
	if($zonetab)
	{
		$zonetab->clear;
		$zonetab->destroy;
	}

	#
	# Create a brand new table.
	#
	$zonetab = $body->Table(-rows => 12, -columns => 4,
				-scrollbars  => 'e',
				-relief	     => 'raised',
				-borderwidth => 1,
				-fixedrows   => 0,
				-takefocus   => 1,
			       );

	#
	# Re-populate and update the table.
	#
	readrrf($rrfile,1);
	$zonetab->update();

	#
	# Pack it all up.
	#
	$zonetab->pack(-fill => 'both', -expand => 1);
	$body->pack(-fill => 'both', -expand => 1);
}

#---------------------------------------------------------------------------
# Routine:	readrrf()
#
# Purpose:	Read a rollrec file and put the info on the screen.
#
sub readrrf
{
	my $rrf = shift;			# Rollrec to read.
	my $timeflag = shift;			# Flag for using current time.
	my $rr;					# Rollrec reference.

	#
	# Initialize some data.
	#
	@zonenames = ();

	#
	# Pretty-up the window.
	#
	settitle($rrf);
	infostripe();
	headerstripe();

	#
	# Get the rollrec contents and the names of the zones it contains.
	#
	rollrec_read($rrf);
	@zonenames = rollrec_names();

	foreach my $zone (@zonenames)
	{
		my $krf;				# Keyrec file.
		my $kr;					# Keyrec reference.
		my $phase;				# Rollover phase.

		#
		# Read the zone's rollrec record and save the current phase.
		#
		$rr = rollrec_fullrec($zone);
		$phase  = $rr->{'curphase'};

		#
		# Save the zone's index and add it (or don't) to our list
		# of roll-enabled zones.
		#
		$zones{$zone} = $zonecnt++;
		if($rr->{'rollrec_type'} eq "roll")
		{
			$rollers{$zone} = 1;
		}
		else
		{
			$rollers{$zone} = 0;
		}

		#
		# Read the zone's keyrec and save the filename.
		#
		$krf = $rr->{'keyrec'};
		$keyrecs{$zone} = $krf;

		#
		# Figure out where each zone's stripe starts.
		#
		calcrows();

		#
		# Paint the window with this zone's info.
		#
		if($timeflag)
		{
			zonestripe($zone,$phase,$zonechron{$zone});
		}
		else
		{
			zonestripe($zone,$phase);
		}
	}

	#
	# Housekeeping before returning.
	#
	infostripe();
	rollrec_close();
	$zonetab->update();
}

#---------------------------------------------------------------------------
# Routine:	infostripe()
#
# Purpose:	Puts an information line in the top table row.
#
sub infostripe
{
	my $lab;
	my $rollmsg;				# Message about rolled zones.
	my $skipmsg;				# Message about skipped zones.

	setcounts();

	$lab = $zonetab->Label(-text => $title,
			       -font => $font, -background => $INFOBG);
	$zonetab->put($INFOROW,$RRFCOL,$lab);

	$lab = $zonetab->Label(-text => $rollcntmsg,
			       -font => $font, -background => $INFOBG);
	$zonetab->put($INFOROW,$ROLLCNTCOL,$lab);

	$lab = $zonetab->Label(-text => $skipcntmsg,
			       -font => $font, -background => $INFOBG);
	$zonetab->put($INFOROW,$SKIPCNTCOL,$lab);

	$lab = $zonetab->Label(-text => ' ',
			       -font => $font, -background => $INFOBG);
	$zonetab->put($INFOROW,$OTHERCOL,$lab);

	paintcnt();
}

#---------------------------------------------------------------------------
# Routine:	headerstripe()
#
# Purpose:	Puts a column header line in the top table row.
#
sub headerstripe
{
	my $lab;

	$lab = $zonetab->Label(-text => 'Zone Name    ',
			       -font => $font, -background => 'tan');
	$zonetab->put($TITLEROW,0,$lab);

	$lab = $zonetab->Label(-text => 'Status',
			       -font => $font, -background => 'tan');
	$zonetab->put($TITLEROW,1,$lab);

	$lab = $zonetab->Label(-text => 'ZSK Type    ',
			       -font => $font, -background => 'tan');
	$zonetab->put($TITLEROW,2,$lab);

	$lab = $zonetab->Label(-text => 'ZSK Name    ',
			       -font => $font, -background => 'tan');
	$zonetab->put($TITLEROW,3,$lab);
}

#---------------------------------------------------------------------------
# Routine:	zonestripe()
#
# Purpose:	Puts a line for the specified zone in the table.
#
sub zonestripe
{
	my $zone    = shift;				# Zone to add.
	my $phase   = shift;				# Zone's rollover phase.
	my $chronos = shift || " ";			# Expiration-time data.

	my $fgcolor = $NORMALFG;			# Foreground color.
	my $bgcolor;					# Background color.
	my $phasecolor;					# Color of phase column.
	my $phasestr;					# Phase description.

	my $row0;					# First row in group.
	my $row1;					# Second row in group.
	my $row2;					# Third row in group.

	my $zskcur;					# Current ZSK.
	my $zskpub;					# Published ZSK.
	my $zsknew;					# New ZSK.

	my $blank;					# Blank label.
	my $lab;					# Non-blank label.
	my $zonetxt;					# Zone name.

	#
	# Get this zone's row group and row indices.
	#
	$row0 = $zonerows{$zone};
	return if($row0 == 0);
	$row1 = $row0 + 1;
	$row2 = $row0 + 2;

	#
	# Get this zone's background color.
	#
	$bgcolor    = getcolor($zone,$phase,1);
	$phasecolor = getcolor($zone,$phase,0);

	#
	# Get this zone's foreground color.
	#
	$fgcolor = $SELECTEDFG if($zone eq $selzone);

	#
	# Save this zone's data in case we need a repaint.
	#
	$zonephase{$zone} = $phase;
	$zonechron{$zone} = $chronos;

	#
	# Set the zone name's field.  (We're setting this here so it can
	# be modified in a single place.)
	#
	$zonetxt  = "$zone    ";
#	$zonetxt  = "  $zone  ";

	#
	# Handle skipped zones here.  We won't do anything if skipped zones
	# shouldn't be displayed.  Otherwise, we'll just put up a single line.
	#
	#	column 1	column 2	column 3	column 4
	#	zone name	"skipped"	<blank>		<blank>
	#
	if(($rollers{$zone} == 0) || ($phase == -42))
	{
		return if($noskip);

		$lab = $zonetab->Label(-text => $zonetxt, -font => $font,
				       -foreground => $fgcolor,
				       -background => $bgcolor);
#				       -background => $bgcolor, -anchor => 'w');
		$zonetab->put($row0,0,$lab);

		$lab = $zonetab->Label(-text => 'skipping', -font => $font,
				       -foreground => $NORMALFG,
				       -background => $bgcolor);
		$zonetab->put($row0,1,$lab);

		$blank = $zonetab->Label(-text => ' ', -background => $bgcolor);
		$zonetab->put($row0,2,$blank);

		$blank = $zonetab->Label(-text => ' ', -background => $bgcolor);
		$zonetab->put($row0,3,$blank);

		#
		# Update the display.
		#
		$zonetab->update();
		return;
	}

	############################################
	#
	# First column:  zone name
	#
	$blank = $zonetab->Label(-text => ' ', -background => $bgcolor);
	$zonetab->put($row0,0,$blank);
	$lab = $zonetab->Label(-text => $zonetxt, -font => $font,
			       -foreground => $fgcolor,
			       -background => $bgcolor);
#			       -background => $bgcolor, -anchor => 'w');

	$zonetab->put($row1,0,$lab);
	$blank = $zonetab->Label(-text => ' ', -font => $font,
				 -background => $bgcolor);
	$zonetab->put($row2,0,$blank);

	###########################################
	#
	# Second column:  zone rollover phase
	#
	$phasestr = "phase $phase";
	$phasestr = " " if($phase == 0);
	$lab = $zonetab->Label(-text => $phasestr, -font => $font,
			       -foreground => $NORMALFG,
			       -background => $phasecolor);
	$zonetab->put($row0,1,$lab);
	$lab = $zonetab->Label(-text => $phasedescr[$phase],
			       -font => $font,
			       -foreground => $NORMALFG,
			       -background => $phasecolor);
	$zonetab->put($row1,1,$lab);
	$lab = $zonetab->Label(-text => $chronos, -font => $font,
			       -foreground => $NORMALFG,
			       -background => $phasecolor);
	$zonetab->put($row2,1,$lab);

	###########################################
	#
	# Third and fourth columns:  zone keys
	#

	#
	# Get the zone's key names.
	#
	my $krf = $keyrecs{$zone};
	keyrec_read($krf);
	$zskcur = keyrec_recval($zone,'zskcur');
	$zskpub = keyrec_recval($zone,'zskpub');
	$zsknew = keyrec_recval($zone,'zsknew');
	keyrec_close();

	#
	# Add some spacing to the fields.
	#
	$zskcur	 .= "    ";
	$zskpub	 .= "    ";
	$zsknew	 .= "    ";

	#
	# Third column:  key label
	#
	$lab = $zonetab->Label(-text => "Current   ", -font => $font,
			       -foreground => $NORMALFG,
			       -background => $bgcolor, -anchor => 'w');
	$zonetab->put($row0,2,$lab);
	$lab = $zonetab->Label(-text => "Published   ", -font => $font,
			       -foreground => $NORMALFG,
			       -background => $bgcolor, -anchor => 'w');
	$zonetab->put($row1,2,$lab);
	$lab = $zonetab->Label(-text => "New   ", -font => $font,
			       -foreground => $NORMALFG,
			       -background => $bgcolor, -anchor => 'w');
	$zonetab->put($row2,2,$lab);

	#
	# Fourth columns:  key name
	#
	$lab = $zonetab->Label(-text => $zskcur, -font => $font,
			       -foreground => $NORMALFG,
			       -background => $bgcolor, -anchor => 'w');
	$zonetab->put($row0,3,$lab);

	$lab = $zonetab->Label(-text => $zskpub, -font => $font,
			       -foreground => $NORMALFG,
			       -background => $bgcolor, -anchor => 'w');
	$zonetab->put($row1,3,$lab);

	$lab = $zonetab->Label(-text => $zsknew, -font => $font,
			       -foreground => $NORMALFG,
			       -background => $bgcolor, -anchor => 'w');
	$zonetab->put($row2,3,$lab);


	#
	# Update the display.
	#
	$zonetab->update();
}

#---------------------------------------------------------------------------
# Routine:	rollerdcmd()
#
# Purpose:	Handle commands from rollerd.
#
sub rollerdcmd
{
	my $line;					# Input from rollerd.
	my $cmd;					# Command.
	my $zone;					# Command's zone.
	my $phase;					# Command's phase.

	#
	# Get the data from rollerd.
	#
	$line = <STDIN>;
	chomp($line);

	#
	# Break the line into its pieces.
	#
	$line =~ /^([a-z]+)\W+([a-zA-z0-9\.\+\-]+)\W+([0-9]+)/;
	$cmd	= $1;
	$zone	= $2;
	$phase	= $3;

	#
	# Exit if this was an empty line.
	#
	exit(0) if($cmd eq '');

	#
	# Handle the commands from rollerd:
	#
	#	phase		change the specified zone's phase
	#	halt		exit
	#	startroll	start a zone in rollover
	#	stoproll	stop a zone's rollover
	#	expiration	zone will soon expire
	#
	if($cmd eq "phase")
	{
		zonestripe($zone,$phase);
	}
	elsif($cmd eq "halt")
	{
		exit(0);
	}
	elsif($cmd eq "startroll")
	{
		rollrec_read($rrfile);
		$phase = rollrec_recval($zone,'curphase');
		rollrec_close();

		$rollers{$zone} = 1;
		calcrows();

		infostripe();

		$zonephase{$zone} = $phase;
		repaint();
	}
	elsif($cmd eq "stoproll")
	{
		$rollers{$zone} = 0;
		calcrows();
		$zonephase{$zone} = -42;

		infostripe();

		repaint();
	}
	elsif($cmd eq "expiration")
	{
		my $secs;				# Additional data.
		my $timestr;				# Translated time.

		$line =~ /^([a-z]+)\W+([a-zA-z0-9\.\+\-]+)\W+([0-9]+)\W(.*)$/;

		$secs	= $4;
		$timestr = fuzzytimetrans($secs);
		$timestr =~ s/\.0//;

		$timestr = "starting roll in $timestr" if($phase == 0);
		zonestripe($zone,$phase,$timestr);
	}

	#
	# Increment the screen-paint count and update the zone table.
	#
	paintcnt();
	$zonetab->update();
}

#----------------------------------------------------------------------
# Routine:      repaint()
#
# Purpose:      Redisplay the current zone data.
#
sub repaint
{
	foreach my $zone (sort(@zonenames))
	{
		zonestripe($zone,$zonephase{$zone},$zonechron{$zone});
	}
}

#----------------------------------------------------------------------
# Routine:      calcrows()
#
# Purpose:      Calculate the starting row for each displayed zone.
#
sub calcrows
{
	my $row = $STARTROW;				# Starting-row index.

	#
	# Zap the zone row index table and zone-colors table.
	#
	%zonerows = ();
	%zonecolors = ();

	#
	# Reset the color index.
	#
	$colorind = 0;

	#
	# Sort the zone-names list and set the zone row index table
	# according to whether or not each zone is displayed.
	#
	foreach my $zn (sort(@zonenames))
	{
		#
		# Save the row index for the zone name.
		#
		$zonerows{$zn} = $row;

		#
		# Skip this zone if we aren't showing skipped zones.
		#
		if($noskip && ($rollers{$zn} == 0))
		{
			$zonerows{$zn} = 0;
			next;
		}

		#
		# Bump the row count by the appropriate amount, depending
		# on if it's a rolled or skipped zone.  Rolled zones also
		# get color information.
		#
		if($rollers{$zn} == 0)
		{
			$row += 1;
		}
		else
		{
			$row += $ROWINCR;

			$zonecolors{$zn} = $colorind;
			$colorind++;
			$colorind = 0 if($colorind == $NUMCOLORS);
		}

		#
		# Save the row index in case this is the last row.
		#
		$lastrow = $row;
	}

	#
	# Set the table to the new row size.
	#
	$zonetab->configure(-rows => $lastrow);
}

#---------------------------------------------------------------------------
# Routine:	getcolor()
#
# Purpose:	Figure out what color this zone's stripe needs.
#
sub getcolor
{
	my $zone = shift;		# Zone whose color we're getting.
	my $phase = shift;		# Zone's phase.
	my $base = shift;		# Base-color flag.

	my $band;			# Zone's output band.
	my $color;			# Color to return.

	#
	# Return this skipped-zone color if this zone isn't rolling.
	#
	return($skipcolor) if($rollers{$zone} != 1);

	#
	# Get the background color for this zone in this phase.
	#
	$band = $zonecolors{$zone};

	#
	# Get the background color for this zone in this phase and
	# return the color.
	#
	$color = $phasecolors[$band];
	return($color->[0]) if($base || $noshading);
	return($color->[$phase]);
}

#---------------------------------------------------------------------------
# Routine:	getnode()
#
# Purpose:	Return the last element in a path.
#
sub getnode
{
	my @pathelts;					# Path elements.
	my $pathnode;					# Last path elements.

	@pathelts = split /\//, $rrfile;
	$pathnode = pop @pathelts;

	return($pathnode);
}

#---------------------------------------------------------------------------
# Routine:	getzone()
#
# Purpose:	This routine creates a modal dialog box to allow the user
#		to select a zone to be rolled/skipped.  For to-be-rolled
#		zones, only those zones are listed which are currently
#		skipped.  Similarly, for to-be-skipped zones, only those
#		zones are listed which are currently being rolled.
#
sub getzone
{
	my $op = shift;					# Operation for zone.
	my $opflag = 0;					# Operation flag.

	my $dlg;					# Dialog widget.
	my $zlist;					# Zone listbox.

	my $listcnt = 0;				# Count of listed zones.

	my $ret;					# Dialog's return value.
	my @indarr;					# Listbox' select array.
	my $selzone;					# Selected zone.
	my @selzones;					# Selected zones.

	my $height = $DLGHEIGHT;			# Height of dialog box.
	my $zonecount = @zonenames;			# Number of zones.

	#
	# Set the zone operation flag.
	#
	$opflag = 1 if($op eq "rollzone");

	#
	# Massage the zone operation for the dialog box's title.
	#
	$op =~ s/zone//;
	$op = ucfirst($op);

	#
	# Set the dialog box height.
	#
	$height = $zonecount if($zonecount < $height);

	#
	# Build and configure the dialog box and the widgets it contains.
	#
	$dlg = $wm->Dialog(-title => "Select Zone to $op", -text  => '',
			   -default_button => "Okay",
			   -buttons => ["Okay", "Cancel"]);
	$zlist = $dlg->Listbox(-relief	    => 'raised',
			       -borderwidth => 1,
			       -selectmode  => 'single');
	$dlg->AddScrollbars($zlist);
	$dlg->configure(-scrollbars => 'e');

	#
	# Add the zone names to the dialog's listbox.  However, we'll
	# only add rolling zones to a skip-zone command and we'll
	# only add skipped zones to a roll-zone command.
	#
	foreach my $zone (sort(@zonenames))
	{
		if((!$opflag && ($rollers{$zone} == 1))		||
		   ( $opflag && ($rollers{$zone} == 0)))
		{
			$zlist->insert("end",$zone);
			$listcnt++;
		}
	}

	#
	# If there weren't any zones added, we'll return 'cause there's
	# nothing for us to do.  The pack() is to keep Tk from whining.
	#
	if($listcnt == 0)
	{
		$zlist->pack(-fill => 'x', -expand => 1);
		return;
	}

	#
	# Pack 'er up and display the zone list.
	#
	$zlist->pack(-fill => 'x', -expand => 1);
	$ret = $dlg->Show();

	#
	# Go no further if no zone was selected.
	#
	return("") if($ret eq "Cancel");

	#
	# Dig out the selected zone and return it.
	#
	@indarr = $zlist->curselection;
	return("") if(@indarr == 0);
	@selzones = $zlist->get($indarr[0]);
	$selzone = $selzones[0];
	return($selzone);
}

#----------------------------------------------------------------------
# Routine:      selector()
#
# Purpose:      Register a mouse-selected zone name.
#
sub selector
{
	my $argv = shift;				# Argument reference.
	my %argv = %$argv;				# Argument hash.

	my $wijname;					# Event's widget.
	my @pieces;					# Pieces of array.

	my $found = 0;					# Found-row flag.
	my $selx;					# Selection x-coord.
	my $wij;					# Selection's widget.

	my @zonearr = ();				# Temp. zone/row array.

	#
	# Make sure we're clicking in our table and not in a menu
	# or frame.
	#
	#	(This ugly bit of coding depends on our only
	#	ever making a single table.)
	#
	$wijname = $argv{'_TkValue_'};
	@pieces = split /\./, $wijname;

	#
	# If the selected widget isn't a table, we'll unselect the
	# currently selected widget.
	#
	if($pieces[2] ne "table")
	{
		if($selwidget && ($pieces[2] !~ /menubutton/))
		{
			$selwidget->configure(-foreground => $NORMALFG);
			$selzone = '';
			$selwidget = undef;

		}
		return;
	}

	#
	# Find the widget that has the same name as the event window.
	#
	for(my $xind=0; $xind < $lastrow; $xind++)
	{
		for(my $yind=0; $yind < 4; $yind++)
		{
			my $pn;				# Widget's pathname.

			#
			# Get this x,y widget and its name.
			#
			$wij = $zonetab->get($xind,$yind);
			$pn = $wij->PathName;

			#
			# Go to the next widget if this isn't it.
			#
			next if($pn ne $wijname);

			#
			# Save the index and drop out.
			#
			$selx = $xind;
			$found = 1;
			last;
		}

		last if($found);
	}

	#
	# Nothing gets selected if the user didn't select anything.
	# Obviously.
	#
	return if(!$found);

	#
	# Clear the selection and return if the click came in the
	# information row or the title row.
	#
	if(($selx == $INFOROW) || ($selx == $TITLEROW))
	{
		$selwidget->configure(-foreground => $NORMALFG) if($selwidget);
		$selwidget = undef;

		$selzone = '';
		return;
	}

	#
	# Build an array of zone-names, indexed by the zone's first row.
	#
	foreach my $zone (keys(%zonerows))
	{
		$zonearr[$zonerows{$zone}] = $zone;
	}

	#
	# Mark the proper zone name (row N, column 0) with a highlighted
	# marking.  All others will be unhighlighted.  We'll work backwards
	# in our newly constructed zone-name array and find the zone's name
	# in the array by working backwards from the index.
	#
	for(my $i=$selx; $i > 0; $i--)
	{
		#
		# Skip any blank widgets.
		#
		next if($zonearr[$i] eq '');

		#
		# Get the zone string's widget and set the selection
		# color for each zone in the zone column.
		#
		for(my $rind=0; $rind < $lastrow; $rind++)
		{
			my $wij;			# Zone's widget.
			my $zstr;			# Widget's zone.

			#
			# Get this row's column-zero widget.  Go to the
			# next if there isn't a zone in it.
			#
			$wij = $zonetab->get($rind,0);
			$zstr = $wij->cget('-text');
			$zstr =~ s/[ ]*$//;
			next if($zstr eq '');

			#
			# If this is our selected zone, mark the zone
			# string as highlighted.  All others go to the
			# normal unhighlighted look.
			#
			if($zstr eq $zonearr[$i])
			{
				$wij->configure(-foreground => $SELECTEDFG);
				$selwidget = $wij;
			}
			else
			{
				$wij->configure(-foreground => $NORMALFG);
			}
		}

		#
		# Select this zone.
		#
		$selzone = $zonearr[$i];
		last;
	}

}

#---------------------------------------------------------------------------
# Routine:	readconfig()
#
# Purpose:      Read our configuration file.  Config entries are "field value"
#		pairs, with the following fields recognized:
#
#			fontsize	size of demo output font
#			skipcolor	color to use for skip records
#
sub readconfig
{
	my $line;					# Configuration line.
	my $field;					# Field name from line.
	my $value;					# Field value from line.

	#
	# Return if we don't have a configuration file.
	#
	return if(!-e $CONFIG);

	#
	# Complain and return if we can't read our configuration file.
	#
	if(!-r $CONFIG)
	{
		print STDERR "unable to read $CONFIG; continuing...\n";
		return;
	}

	#
	# Read the config file, ignoring comment lines.  Each non-comment
	# line is expected to be in a "field value" pair.  As we read each
	# line, we'll take the appropriate action.
	#
	open(CONF,"<$CONFIG");
	while(<CONF>)
	{
		$line = $_;
		chomp($line);

		#
		# Skip empty and comment lines.
		#
		$line =~ s/^[ \t]+//;
		next if(($line =~ /^\#/) || ($line =~ /^$/));

		#
		# Pull out the field and value from the line.
		#
		$line =~ /([a-zA-Z_\-]+)\W+([a-zA-Z0-9_\-]+)/;
		$field = lc($1);
		$value = $2;

		#
		# Handle the field values appropriately.
		#
		if($field eq "fontsize")
		{
			if($value =~ /[a-zA-Z\_\-]/)
			{
				print STDERR "invalid fontsize \"$value\" in configuration file\n";
				next;
			}
			$fontsize = $value;
		}
		elsif($field eq "skipcolor")
		{
			$skipcolor = $value;
		}
	}

	close(CONF);
}

#----------------------------------------------------------------------
# Routine:      setcounts()
#
# Purpose:      Set the rolled zone and skipped zone messages with the
#		current counts.
#
sub setcounts
{
	my $total = 0;					# Total zone count.
	my $rollcnt = 0;				# Rolled zone count.
	my $skipcnt = 0;				# Skipped zone count.

	#
	# Calculate the number of rolled and skipped zones.
	#
	$total = keys(%rollers);
	foreach my $zn (keys(%rollers))
	{
		$rollcnt++ if($rollers{$zn});
	}

	$skipcnt = $total - $rollcnt;

	#
	# Set the messages, in a grammatically anal-retentive manner.
	#
	if($rollcnt != 0)
	{
		if($rollcnt == 1)
		{
			$rollcntmsg = "$rollcnt Rolling Zone";
		}
		else
		{
			$rollcntmsg = "$rollcnt Rolling Zones";
		}
	}
	else
	{
		$rollcntmsg = "0 Rolling Zones";
	}

	if($skipcnt != 0)
	{
		if($skipcnt == 1)
		{
			$skipcntmsg = "$skipcnt Skipped Zone";
		}
		else
		{
			$skipcntmsg = "$skipcnt Skipped Zones";
		}
	}
	else
	{
		$skipcntmsg = "0 Skipped Zones";
	}
}

#----------------------------------------------------------------------
# Routine:      settitle()
#
# Purpose:      Set the title for use in the "Monitoring File" line.
#
sub settitle
{
	my $name = shift;				# Name to use.

	$title = getnode($name);
}

#---------------------------------------------------------------------------
# Routine:	error()
#
# Purpose:	Give an error dialog box.
#
sub error
{
	my $msg = shift;			# Warning message.
	my $dlg;				# Warning dialog widget.

	$dlg = $wm->Dialog(-title => "$NAME Warning",
			   -text  => $msg,
			   -default_button => "Okay",
			   -buttons => ["Okay"]);
	$dlg->Show();
}

#---------------------------------------------------------------------------
# Routine:      helpbegone()
#
# Purpose:	Dismiss the help window.
#
sub helpbegone
{
	$helpwin->destroy();
	$inhelpwind = 0;
}

#---------------------------------------------------------------------------
# Routine:	help_help()
#
# Purpose:	Display the help window.
#
sub help_help
{
	my $hframe;					# Help frame.
	my $wdgt;					# General widget.

	my $helpstr;

	$helpstr = "

blinkenlights - DNSSEC-Tools Rollerd Demo
         
SYNOPSIS
         
    blinkenlights <rollrec-file>

DESCRIPTION

blinkenlights is a demo tool for use with the DNSSEC-Tools rollerd
program.  As rollerd rolls the zones listed in the rollrec file,
blinkenlights will display status information for the file's zones.

For ease of reading, each zone's row is a different color.  The rollover
phase column color will change, depending on the current phase.  When the
zone's phase returns to not being in mid-rollover, the color will match that
of the rest of the row.

This is only intended to be started by rollerd.  The -display option must
be given on rollerd's command line in order to have it start blinkenlights.

";

	#
	# If we've already got another help window, we'll give an error and
	# return.  Otherwise, we'll turn on our in-helpwindow flag.
	#
	if($inhelpwind)
	{
		error("Multiple help windows cannot be created\n");
		return;
	}
	$inhelpwind = 1;

	#
	# Create a new window to hold our help info.  Bind up some
	# key accelerators, too.
	#
	$helpwin = MainWindow->new(-relief => 'raised',
				  -title  => 'Help!',
				  -borderwidth => 1);
	$helpwin->bind('<Control-Key-Q>',\&file_quit);
	$helpwin->bind('<Control-Key-q>',\&file_quit);
	$helpwin->bind('<Control-Key-W>',\&helpbegone);
	$helpwin->bind('<Control-Key-w>',\&helpbegone);

	#
	# Now make the containers for the window.
	#
	$hframe = $helpwin->Frame(-relief => 'raised', -borderwidth => 1);

	$hframe->pack(-fill => 'x');

	#
	# Add the help data to the frame.
	#
	$wdgt = $hframe->Label(-text => $helpstr,
			       -justify => 'left');
	$wdgt->pack(-side => 'top');

	#
	# Add a button to dismiss the window.
	#
	$wdgt = $hframe->Button(-text => 'Done',
				-command => \&helpbegone);
	$wdgt->pack(-side => 'top');
}

#----------------------------------------------------------------------
# Routine:      version()
#
# Purpose:      Print the version number(s) and exit.
#
sub version
{
	print STDERR "$VERS\n";
	print STDERR "$DTVERS\n";
	exit(0);
}

#---------------------------------------------------------------------------
# Routine:	usage()
#
# Purpose:      Print a usage message and exit.
#
sub usage
{
	print STDERR "usage:  blinkenlights [-Version] <rollrec-file>\n";
	exit(0);
}

1;

#############################################################################

=pod

=head1 NAME

blinkenlights - DNSSEC-Tools Rollerd Demo

=head1 SYNOPSIS

  blinkenlights <rollrec-file>

=head1 DESCRIPTION

B<blinkenlights> is a display tool for use with the DNSSEC-Tools B<rollerd>
program.  As B<rollerd> rolls the zones listed in the I<rollrec> file,
B<blinkenlights> will display status information for the file's zones.

For ease of reading, each zone's row is a different color.  The I<rollover
phase> column color will change, depending on the current phase.  When the
zone's phase returns to not being in mid-rollover, the color will match that
of the rest of the row.

This is only intended to be started by B<rollerd>.  The I<-display>
option must be given on B<rollerd>'s command line in order to have it
start B<blinkenlights>.

=head1 LAYOUT AND SCREEN COLORS

things to include:

=over 4

=item *

zone stripe definition

=item *

colors are row-positional and B<not> attached to specific zones

=item *

color of column two changes as rollover proceeds

=back

=head1 CONFIGURATION FILE

B<blinkenlights> has a configuration file in B<rc.blinkenlights>.  This file
controls several aspects of the output.  This file is B<only> searched for in
the current directory.  This file is in the "field value" format, where
I<field> specifies the output aspect and I<value> defines the value for that
field.  The following are the recognized fields:

    fontsize	The size of the font in the output window
    skipcolor	The background color used for skipped zones.

Empty lines and comments are ignored.  Comment lines are lines that start
with an octothorpe ('#').

Spaces are not allowed in the configuration values.  Choose your skipcolors
carefully...

=head1 REQUIREMENTS

I<blinkenlights> is implemented in Perl/Tk, so both Perl and Perl/Tk must be
installed on your system.

=head1 WARNINGS

B<blinkenlights> has several potential problems that must be taken into
account.

=over 4

=item development environment

B<blinkenlights> was developed and tested on a single-user system
running X11.  While it works fine in this environment, it has not been
run on a system with many users or in a situation where the system
console hasn't been in use by the B<blinkenlights> user.

=item long-term performance issues

In early tests, the longer B<blinkenlights> runs, the slower the
updates become.  This is I<probably> a result of the Tk implementation
or the way Tk interfaces with X11.  This is pure supposition, though.

This performance impact is affected by a number of things, such as the
number of zones managed by B<rollerd> and the length of B<rollerd>'s
sleep interval.  Large numbers of zones or very short sleep intervals
will increase the possibility of B<blinkenlights>' performance
degrading.

For this reason, B<blinkenlights> is most likely to have its greatest
utility as a short-term interface and monitoring tool to B<rollerd>.
The length of "short term" is dependent on above-mentioned factors.

=back 4

=head1 COPYRIGHT

Copyright 2006 SPARTA, Inc.  All rights reserved.
See the COPYING file included with the DNSSEC-Tools package for details.

=head1 AUTHOR

Wayne Morrison, tewok@users.sourceforge.net

=head1 SEE ALSO

B<rollerd(8)>,
B<zonesigner(8)>

B<Net::DNS::SEC::Tools::keyrec(5)>,
B<Net::DNS::SEC::Tools::rollrec(5)>,
B<Net::DNS::SEC::Tools::timetrans(5)>

=cut

