#!/usr/bin/perl
#
# Copyright 2004-2006 SPARTA, Inc.  All rights reserved.  See the COPYING
# file distributed with this software for details
#
#
# confchk
#
#	This script performs sanity checks on a DNSSEC-Tools
#	configuration file.
#

use strict;

use Getopt::Long;

use Net::DNS::SEC::Tools::conf;
use Net::DNS::SEC::Tools::defaults;

#######################################################################

#
# Data required for command line options.
#
my %options = ();			# Filled option array.
my @opts =
(
	"expert",			# Expert mode.
	"quiet",			# Give no output.
	"summary",			# Give only a summary output line.
	"verbose",			# Give verbose output.
	"version",			# Display the version nmuber .
	"help",				# Give a usage message and exit.
);

#######################################################################

#
# List of valid encryption algorithms and length ranges.
# (These values are taken from the dnssec-keygen man page.)
#
my @algorithms = ("rsasha1", "rsamd5", "dsa", "dh", "hmac-md5");

my %length_low =
(
	"rsasha1"  => 512,
	"rsamd5"   => 512,
	"dsa"	   => 512,
	"dh"	   => 128,
	"hmac-md5" => 1
);

my %length_high =
(
	"rsasha1"  => 2048,
	"rsamd5"   => 2048,
	"dsa"	   => 1024,
	"dh"	   => 4096,
	"hmac-md5" => 512
);

my $MINEND = ((60*60) * 2);			# Minimum endtime (two hours.)

my $MINSLEEP = 60;				# Minimum realistic sleeptime.

#######################################################################

my $expert	= 0;			# Don't do non-expert checks.
my $quiet	= 0;			# Give no output.
my $summary	= 0;			# Give only a summary output line.
my $verbose	= 0;			# Give lotsa output.
my $version	= 0;			# Display the version number.

my $errs	= 0;			# Error count.

my %dtconf;				# Config file contents.

main();
exit($errs);

#-----------------------------------------------------------------------------
#
# Routine:	main()
#
# Purpose:	Staging area.
#
sub main()
{
	my $conffile;			# The config file to check.

	#
	# Get our options.
	#
	doopts();

	#
	# Get the config filename to check.
	#
	if($ARGV[0] ne "")
	{
		$conffile = $ARGV[0];
	}
	else
	{
		$conffile = "/usr/local/etc/dnssec/dnssec-tools.conf";
	}

	#
	# Maybe print the name of the config file we're checking.
	#
	if($verbose && !$quiet && !$summary)
	{
		print "checking config file \"$conffile\"\n";
	}

	#
	# Read the config file.
	#
	%dtconf = parseconfig($conffile);
	if(!defined(%dtconf))
	{
		err("config file \"$conffile\" not parsed\n");
		exit(-1);
	}

	#
	# Check the key-related records.
	#
	keygen_checks();

	#
	# Check the signzone-related records.
	#
	signzone_checks();

	#
	# Check the file-specific records.
	#
	check_files();

	#
	# Check the rollerd records.
	#
	check_rollerd();

	#
	# Check the miscellaneous records.
	#
	check_misc();

	#
	# Give an exit message that depends on the error count.
	#
	if($errs == 0)
	{
		sqprint("$conffile is valid\n");
	}
	else
	{
		sqprint("$conffile is invalid:  $errs errors\n") if($errs > 1);
		sqprint("$conffile is invalid:  $errs error\n")  if($errs == 1);
	}
}

#-----------------------------------------------------------------------------
#
# Routine:	doopts()
#
# Purpose:	This routine deals with the command's options.
#
sub doopts
{
	#
	# Check our options.
	#
	GetOptions(\%options,@opts);
	$expert	 = $options{'expert'};
	$verbose = $options{'verbose'};
	$version = $options{'version'};
	$summary = $options{'summary'};
	$quiet	 = $options{'quiet'};

	#
	# Show the version number if requested
	#
	show_version() if(defined($options{'version'}));
	usage() if(defined($options{'help'}));
}

#-----------------------------------------------------------------------------
#
# Routine:	keygen_checks()
#
# Purpose:	Check the algorithm and key length fields.
#
sub keygen_checks
{
	my $algorithm;				# Encryption algorithm.
	my $ksklen;				# KSK length.
	my $zsklen;				# ZSK length.
	my $found = 0;				# Algorithm-found flag.

	my $lowval;				# Low key length.
	my $highval;				# High key length.

	my $ksklife;				# Lifespan of KSK.
	my $zsklife;				# Lifespan of ZSK.
	my $lifemax = dnssec_tools_defaults('lifespan-max');	# Max. key life.
	my $lifemin = dnssec_tools_defaults('lifespan-min');	# Min. key life.

	#
	# Get the key-related config entries.
	#
	$algorithm = lc($dtconf{'algorithm'});
	$ksklen	   = $dtconf{'ksklen'};
	$zsklen	   = $dtconf{'zsklen'};
	$ksklife   = $dtconf{'ksklife'};
	$zsklife   = $dtconf{'zsklife'};

	#
	# If the key's encryption algorithm isn't defined here, then we
	# can't check it or any of the encryption lengths.
	#
	if(!defined($algorithm))
	{
		prt(0,"algorithm not defined; can't check length values");
		$errs++;
	}
	else
	{
		#
		# Search the algorithm list for this key's algorithm.  If we
		# find it, we'll mark that it's good.
		#
		if(defined($algorithm))
		{
			foreach my $alg (@algorithms)
			{
				if($alg eq $algorithm)
				{
					$found = 1;
					last;
				}
			}
		}

		#
		# If the key's encryption algorithm is bad, we'll give an error
		# message.  If it's okay, we'll make sure the length is in the
		# range of valid lengths for the key type.
		#
		if(!$found)
		{
			prt(0,"invalid algorithm:  \"$algorithm\"; can't check key-length values");
			$errs++;
		}
		else
		{
			prt(1,"valid algorithm is $algorithm");

			#
			# Get the key length range for this algorithm.
			#
			$lowval  = $length_low{$algorithm};
			$highval = $length_high{$algorithm};

			#
			# Ensure the ZSK length is in algorithm's value range.
			#
			if(!defined($dtconf{'ksklen'}))
			{
				prt(1,"ksklength not defined");
				$errs++;
			}
			else
			{
				prt(1,"ksklength is $ksklen");

				#
				# Ensure the KSK length is greater than the
				# algorithm's low value.
				#
				if($ksklen < $lowval)
				{
					prt(0,"invalid ksklength:  length ($ksklen) < minimum ($lowval) for $algorithm");
					$errs++;
				}

				#
				# Ensure the KSK length is greater than the
				# algorithm's high value.
				#
				if($ksklen > $highval)
				{
					prt(0,"invalid ksklength:  length ($ksklen) > maximum ($highval) for $algorithm");
					$errs++;
				}
			}

			#
			# Ensure the ZSK length is in algorithm's value range.
			#
			if(!defined($dtconf{'zsklen'}))
			{
				prt(1,"zsklength not defined");
				$errs++;
			}
			else
			{
				prt(1,"zsklength is $zsklen");

				#
				# Ensure the ZSK length is greater than the
				# algorithm's low value.
				#
				if($zsklen < $lowval)
				{
					prt(0,"invalid zsklength:  length ($zsklen) < minimum ($lowval) for $algorithm");
					$errs++;
				}

				#
				# Ensure the ZSK length is greater than the
				# algorithm's high value.
				#
				if($zsklen > $highval)
				{
					prt(0,"invalid zsklength:  length ($zsklen) > maximum ($highval) for $algorithm");
					$errs++;
				}
			}
		}
	}

	#
	# Ensure the KSK life is in a lifespan value range.  This set of
	# checks is only performed if the -expert mode wasn't given.
	#
	if(!$expert)
	{
		if(!defined($ksklife))
		{
			prt(1,"ksklife not defined");
			$errs++;
		}
		else
		{
			prt(1,"ksklife is $ksklife");

			#
			# Ensure the KSK lifespan is greater than the suggested
			# minimum lifespan.
			#
			if($ksklife < $lifemin)
			{
				prt(0,"invalid ksklife:  lifespan ($ksklife) < minimum lifespan ($lifemin)");
				$errs++;
			}

			#
			# Ensure the KSK lifespan is less than the suggested
			# maximum lifespan.
			#
			if($ksklife > $lifemax)
			{
				prt(0,"invalid ksklife:  lifespan ($ksklife) > maximum lifespan ($lifemax)");
				$errs++;
			}
		}
	}

	#
	# Ensure the ZSK life is in a lifespan value range.  This set of
	# checks is only performed if the -expert mode wasn't given.
	#
	if(!$expert)
	{
		if(!defined($zsklife))
		{
			prt(1,"zsklife not defined");
			$errs++;
		}
		else
		{
			prt(1,"zsklife is $zsklife");

			#
			# Ensure the ZSK lifespan is greater than the suggested
			# minimum lifespan.
			#
			if($zsklife < $lifemin)
			{
				prt(0,"invalid zsklife:  lifespan ($zsklife) < minimum lifespan ($lifemin)");
				$errs++;
			}

			#
			# Ensure the ZSK lifespan is less than the suggested
			# maximum lifespan.
			#
			if($zsklife > $lifemax)
			{
				prt(0,"invalid zsklife:  lifespan ($zsklife) > maximum lifespan ($lifemax)");
				$errs++;
			}
		}
	}

}

#-----------------------------------------------------------------------------
#
# Routine:	signzone_checks()
#
# Purpose:	Check the signzone-related fields.
#
sub signzone_checks
{
	my $endtime;				# Zone end-time.
	my $etcnt;				# Count of seconds in endtime.

	#
	# Get the zone-related configuration entries.
	#
	$endtime = $dtconf{'endtime'};

	#
	# Check i the endtime isn't defined here.
	#
	if(!defined($endtime))
	{
		prt(0,"endtime not defined");
		return;
	}

	#
	# Get the endtime seconds from the endtime.
	#
	$endtime =~ /\+([0-9]+)/;
	$etcnt = $1;

	#
	# Give the appropriate message, depending on if the encryption
	# time is acceptable or not.
	#
	if($etcnt < $MINEND)
	{
		prt(0,"endtime ($endtime) < minimum realistic endtime ($MINEND)");
		$errs++;
	}
	else
	{
		prt(1,"endtime ($endtime) acceptable");
	}
}

#-----------------------------------------------------------------------------
#
# Routine:	check_rollerd()
#
# Purpose:	Check the file configuration fields.
#
sub check_rollerd
{
	my $logfile;				# Logfile for rollerd.
	my $loglevel;				# Log level for rollerd.
	my $sleep;				# Sleep time for rollerd.

	$logfile  = $dtconf{"roll_logfile"};
	$loglevel = $dtconf{"roll_loglevel"};
	$sleep	  = $dtconf{"roll_sleeptime"};

	#
	# Ensure rollerd's logfile (if it exists) is a regular file.
	#
	if(-e $logfile)
	{
		if(! -f $logfile)
		{
			prt(0,"invalid file type for logfile ($logfile)");
			$errs++;
		}
		else
		{
			prt(1,"existing roll-over logfile ($logfile) acceptable");
		}
	}
	else
	{
		prt(1,"nonexistent roll-over logfile ($logfile) acceptable");
	}

	#
	# Give the appropriate message, depending on if rollerd's log-
	# level is acceptable or not.
	#
	if(($loglevel =~ /^tmi$/i)	|| ($loglevel == 1)	||
	   ($loglevel =~ /^info$/i)	|| ($loglevel == 3)	||
	   ($loglevel =~ /^curphase$/i)	|| ($loglevel == 5)	||
	   ($loglevel =~ /^err$/i)	|| ($loglevel == 7)	||
	   ($loglevel =~ /^fatal$/i)	|| ($loglevel == 9))
	{
		prt(1,"roll-over loglevel ($loglevel) acceptable");
	}
	else
	{
		prt(0,"invalid roll-over loglevel ($loglevel)");
		$errs++;
	}

	#
	# Give the appropriate message, depending on if rollerd's sleep-
	# time is acceptable or not.
	#
	if($sleep < $MINSLEEP)
	{
		prt(0,"roll-over sleeptime ($sleep) < minimum realistic sleeptime ($MINSLEEP)");
		$errs++;
	}
	else
	{
		prt(1,"roll-over sleeptime ($sleep) acceptable");
	}

}

#-----------------------------------------------------------------------------
#
# Routine:	check_files()
#
# Purpose:	Check the file configuration fields.
#
sub check_files
{
	file_check("random","c");
	file_check("checkzone","x");
	file_check("keygen","x");
	file_check("signzone","x");
	file_check("viewimage","x");
}

#-----------------------------------------------------------------------------
#
# Routine:	check_misc()
#
# Purpose:	Check several miscellaneous fields.
#
sub check_misc
{
	my $savekeys;					# Save-old-keys flag.

	#
	# Check some boolean flags.
	#
	bool_check('entropy_msg');
	bool_check('savekeys');
	bool_check('usegui');

	#
	# If savekeys is on, check that archdir is set to a directory.
	#
	$savekeys = $dtconf{'savekeys'};
	if($savekeys eq "1")
	{
		my $archdir = $dtconf{'archivedir'};

		if(defined($archdir) && ($archdir ne ""))
		{
#			$archdir = $dtconf{'archivedir'};
			if(-d $archdir)
			{
				prt(1,"$archdir is an existing directory");
			}
			elsif (-e $archdir)
			{
				prt(0,"archivedir $archdir exists, but is not a directory");
				$errs++;
			}
                        else
                        {
                                prt(0,"archivedir $archdir does not exist");
                                $errs++;
                        }
		}
		else
		{
			prt(0,"savekeys is set on, but no archive directory is specified");
			$errs++;
		}
	}
}

#-----------------------------------------------------------------------------
#
# Routine:	file_check()
#
# Purpose:	Check the file fields:  ensure that the file exists and check
#		some basic file-specific data.
#
sub file_check
{
	my $field = shift;			# Field to check.
	my $ftype = shift;			# Type of file.
	my $fname;				# Name of file to check.

	$fname	= $dtconf{"$field"};

	#
	# If the field isn't defined, we'll return.
	#
	if(!defined($fname))
	{
		prt(1,"$field not defined");
		return;
	}

	#
	# If the filename isn't an absolute path, then we'll stop
	# checking here.
	#
	if($fname !~ /^\//)
	{
		prt(1,"no further checks for $field file $fname");
		return;
	}

	#
	# Ensure the file exists.
	#
	if(! -e $fname)
	{
		prt(0,"$field file $fname does not exist");
		$errs++;
		return;
	}

	#
	# Check some data about this file:
	#
	#	f - regular file
	#	x - regular file that must be executable
	#	c - character device file that must be readable
	#
	if($ftype eq "f")
	{
		if(-f $fname)
		{
			prt(1,"$field file $fname is a regular file");
		}
		else
		{
			prt(0,"$field file $fname is not a regular file");
			$errs++;
		}
	}
	elsif($ftype eq "x")
	{
		if(-f $fname)
		{
			prt(1,"$field file $fname is a regular file");
		}
		else
		{
			prt(0,"$field file $fname is not a regular file");
			$errs++;
		}
		if(-x $fname)
		{
			prt(1,"$field file $fname is an executable file");
		}
		else
		{
			prt(0,"$field file $fname is not an executable file");
			$errs++;
		}
	}
	elsif($ftype eq "c")
	{
		if(-c $fname)
		{
			prt(1,"$field file $fname is a character device file");
		}
		else
		{
			prt(0,"$field file $fname is not a character device file");
			$errs++;
		}
		if(-r $fname)
		{
			prt(1,"$field file $fname is a readable file");
		}
		else
		{
			prt(0,"$field file $fname is not a readable file");
			$errs++;
		}
	}

}

#-----------------------------------------------------------------------------
#
# Routine:	bool_check()
#
# Purpose:	Checks a boolean for good values (0 or 1.)
#
sub bool_check
{
	my $label = shift;				# Label to check.
	my $val;					# Value of label.

	$val = $dtconf{$label};
	if(($val ne "0") && ($val ne "1"))
	{
		prt(0,"$label flag has unrecognized value  ($val)");
		$errs++;
	}
	else
	{
		prt(1,"$label ($val) acceptable");
	}
}

#-----------------------------------------------------------------------------
#
# Routine:	sqprint()
#
# Purpose:	Prints a line of output if -quiet wasn't given or if
#		-summary was given.
#
#		This is intended to be used only by the final summarizing
#		output lines of dtconfchk.
#
sub sqprint
{
	my $line = shift;

	print $line if(!$quiet || $summary);
}

#-----------------------------------------------------------------------------
#
# Routine:	prt()
#
# Purpose:	Prints a line of output if -verbose was given.
#
sub prt
{
	my $good = shift;		# Flag indicating success/failure.
	my $line = shift;		# Text to be printed.
	my $prefix = "";		# Success/failure prefix (for verbose.)

	#
	# If -quiet or -summary was given, we won't print anything.
	#
	return if($quiet || $summary);

	#
	# Don't print if this was a success message and -verbose wasn't given.
	#
	return if($good && !$verbose);

	#
	# Set a prefix if we're in verbose mode.  Otherwise, we're in normal
	# mode and have gotten an error.  Since only errors will be printed,
	# we don't need the prefix.
	#
	if($verbose)
	{
		$prefix = $good ? '+ ' : '- ';
	}

	print "$prefix$line\n";
}

#-----------------------------------------------------------------------------
#
# Routine:	err()
#
# Purpose:	Prints a line of output if -quiet wasn't given.
#
sub err
{
	my $line = shift;

	print STDERR $line if(!$quiet);
}

#----------------------------------------------------------------------
#
# Routine:	show_version()
#
# Purpose:	Print the version number(s) and exit.
#
sub show_version
{
	print STDERR "Version: 0.9.1\n";
	print STDERR "DNSSEC-Tools Version: 0.9.1\n";
	exit(1);
}

#-----------------------------------------------------------------------------
#
# Routine:	usage()
#
sub usage
{
	print STDERR "usage:  confchk [options] <config file>\n";
	print STDERR "\toptions:\n";
	print STDERR "\t\t-expert\n";
	print STDERR "\t\t-quiet\n";
	print STDERR "\t\t-status\n";
	print STDERR "\t\t-verbose\n";
	print STDERR "\t\t-version\n";
	print STDERR "\t\t-help\n";
	exit(0);
}

1;

##############################################################################
#

=pod

=head1 NAME

confchk - Check a DNSSEC-Tools configuration file for sanity.

=head1 SYNOPSIS

  confchk [options] [config_file]

=head1 DESCRIPTION

I<confchk> checks a DNSSEC-Tools configuration file to determine if the
entries are valid.

The I<default_keyrec> configuration entry is not checked.  This entry
specifies the default I<keyrec> file name and isn't necessarily expected
to exist in any particular place.

=head2 Key-related Checks

The following key-related checks are performed:

=over 8

=item I<algorithm>

Ensure the I<algorithm> field is valid.  The acceptable values may be found
in the I<dnssec-keygen> man page.

=item I<ksklength>

Ensure the I<ksklength> field is valid.  The acceptable values may be found
in the I<dnssec-keygen> man page.

=item I<ksklife>

Ensure the I<ksklife> field is valid.  The acceptable values may be found
in the B<Net::DNS::SEC::Tools::defaults.pm(3)> man page.

=item I<zsklength>

Ensure the I<zsklength> field is valid.  The acceptable values may be found
in the I<dnssec-keygen> man page.

=item I<zsklife>

Ensure the I<zsklife> field is valid.  The acceptable values may be found
in the B<Net::DNS::SEC::Tools::defaults.pm(3)> man page.

=item I<random>

Ensure the I<random> field is valid.  This file must be a character
device file.

=back

=head2 Zone-related Checks

The following zone-related checks are performed:

=over 8

=item I<endtime>

Ensure the I<endtime> field is valid.  This value is assumed to be in the
"+NNNNNN" format.  There is a lower limit of two hours.  (This is an
artificial limit under which it may not make sense to have an endtime.)

=back

=head2 Path Checks

The following path checks are performed:

=over 8

=item I<checkzone>

Ensure the I<checkzone> field is valid.  If the filename starts with a '/',
the file must be a regular executable file.

=item I<keygen>

Ensure the I<keygen> field is valid.  If the filename starts with a '/',
the file must be a regular executable file.

=item I<signzone>

Ensure the I<signzone> field is valid.  If the filename starts with a '/',
the file must be a regular executable file.

=item I<viewimage>

Ensure the I<viewimage> field is valid.  If the filename starts with a '/',
the file must be a regular executable file.

=back

=head2 Roll-over Daemon Checks

The following checks are performed for I<rollerd> values:

=over 8

=item I<roll_logfile>

Ensure that the log file for the roll-over daemon is valid.  If the file
exists, it must be a regular file.

=item I<roll_loglevel>

Ensure that the logging level for the roll-over daemon is reasonable.  The
log level must be one of the following text or numeric values:

    tmi        1       (Overly verbose informational messages.)
    info       3       (Informational messages.)
    curphase   5       (Current state of zone.)
    err        7       (Error messages.)
    fatal      9       (Fatal errors.)

Specifying a particular log level will causes messages of a higher numeric
value to also be displayed.

=item I<roll_sleeptime>

Ensure that the roll-over daemon's sleep-time is reasonable.
The daemon's sleep-time must be at least one minute.

=back

=head2 Miscellaneous Checks

The following miscellaneous checks are performed:

=over 8

=item I<archivedir>

Ensure that the I<archivedir> directory is actually a directory.
This check is only performed if the I<savekeys> flag is set on.

=item I<entropy_msg>

Ensure that the I<entropy_msg> flag is either 0 or 1.

=item I<savekeys>

Ensure that the I<savekeys> flag is either 0 or 1.
If this flag is set to 1, then the I<archivedir> field will also be checked.

=item I<usegui>

Ensure that the I<usegui> flag is either 0 or 1.

=back

=head1 OPTIONS

=over 4

=item -expert

Only non-expert checks will be performed.  Currently, this option will prevent
the key lifespan checks from being run.

=item -quiet

No output will be given.
The number of errors will be used as the exit code.

=item -summary

A final summary of success or failure will be printed.
The number of errors will be used as the exit code.

=item -verbose

Success or failure status of each check will be given.
A B<+> or B<-> prefix will be given for each valid and invalid entry.
The number of errors will be used as the exit code.

=item -help

Display a usage message.

=back

=head1 COPYRIGHT

Copyright 2004-2006 SPARTA, Inc.  All rights reserved.
See the COPYING file included with the DNSSEC-Tools package for details.

=head1 AUTHOR

Wayne Morrison, tewok@users.sourceforge.net

=head1 SEE ALSO

B<Net::DNS::SEC::Tools::conf.pm(3)>,
B<Net::DNS::SEC::Tools::defaults.pm(3)>

B<dtdefs(8)>,
B<rollerd(8)>,
B<zonesigner(8)>

=cut
