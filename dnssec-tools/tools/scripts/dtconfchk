#!/usr/bin/perl
#
# Copyright 2004-2006 SPARTA, Inc.  All rights reserved.  See the COPYING
# file distributed with this software for details
#
#
# confchk
#
#	This script performs sanity checks on a DNSSEC-Tools
#	configuration file.
#

use strict;

use Getopt::Long;

use Net::DNS::SEC::Tools::conf;
use Net::DNS::SEC::Tools::defaults;

#######################################################################

#
# Data required for command line options.
#
my %options = ();			# Filled option array.
my @opts =
(
	"expert",			# Expert mode.
	"quiet",			# Give no output.
	"summary",			# Give only a summary output line.
	"verbose",			# Give verbose output.
	"help",				# Give a usage message and exit.
);

#######################################################################

#
# List of valid encryption algorithms and length ranges.
# (These values are taken from the dnssec-keygen man page.)
#
my @algorithms = ("rsasha1", "rsamd5", "dsa", "dh", "hmac-md5");

my %length_low =
(
	"rsasha1"  => 512,
	"rsamd5"   => 512,
	"dsa"	   => 512,
	"dh"	   => 128,
	"hmac-md5" => 1
);

my %length_high =
(
	"rsasha1"  => 2048,
	"rsamd5"   => 2048,
	"dsa"	   => 1024,
	"dh"	   => 4096,
	"hmac-md5" => 512
);

my $MINEND = ((60*60) * 2);			# Minimum endtime (two hours.)

#######################################################################

my $expert	= 0;			# Don't do non-expert checks.
my $quiet	= 0;			# Give no output.
my $summary	= 0;			# Give only a summary output line.
my $verbose	= 0;			# Give lotsa output.

my $errs	= 0;			# Error count.

my %dtconf;				# Config file contents.

main();
exit($errs);

#-----------------------------------------------------------------------------
#
# Routine:	main()
#
# Purpose:	Staging area.
#
sub main()
{
	my $conffile;			# The config file to check.

	#
	# Get our options.
	#
	doopts();

	#
	# Get the config filename to check.
	#
	if($ARGV[0] ne "")
	{
		$conffile = $ARGV[0];
	}
	else
	{
		$conffile = "/usr/local/etc/dnssec/dnssec-tools.conf";
	}
	vprint("checking config file \"$conffile\"\n");

	#
	# Read the config file.
	#
	%dtconf = parseconfig($conffile);
	if(!defined(%dtconf))
	{
		qprint("config file \"$conffile\" not parsed\n");
		exit(1);
	}

	#
	# Check the key-related records.
	#
	keygen_checks();

	#
	# Check the signzone-related records.
	#
	signzone_checks();

	#
	# Check the file-specific records.
	#
	check_files();

	#
	# Check the miscellaneous records.
	#
	check_misc();

	#
	# Give an exit message that depends on the error count.
	#
	if($errs == 0)
	{
		sqprint("$conffile is valid\n");
	}
	else
	{
		sqprint("$conffile is invalid:  $errs errors\n") if($errs > 1);
		sqprint("$conffile is invalid:  $errs error\n")  if($errs == 1);
	}
}

#-----------------------------------------------------------------------------
#
# Routine:	doopts()
#
# Purpose:	This routine deals with the command's options.
#
sub doopts
{
	#
	# Check our options.
	#
	GetOptions(\%options,@opts);
	$expert	 = $options{'expert'};
	$verbose = $options{'verbose'};
	$summary = $options{'summary'};
	$quiet	 = $options{'quiet'};

	usage() if(defined($options{'help'}));
}

#-----------------------------------------------------------------------------
#
# Routine:	keygen_checks()
#
# Purpose:	Check the algorithm and key length fields.
#
sub keygen_checks
{
	my $algorithm;				# Encryption algorithm.
	my $ksklen;				# KSK length.
	my $zsklen;				# ZSK length.
	my $found = 0;				# Algorithm-found flag.

	my $lowval;				# Low key length.
	my $highval;				# High key length.

	my $ksklife;				# Lifespan of KSK.
	my $zsklife;				# Lifespan of ZSK.
	my $lifemax = dnssec_tools_defaults('lifespan-max');	# Max. key life.
	my $lifemin = dnssec_tools_defaults('lifespan-min');	# Min. key life.

print "\n\tmust examine returns in this routine -- when they should and shouldn't happen\n\n";

	#
	# Get the key-related config entries.
	#
	$algorithm = lc($dtconf{'algorithm'});
	$ksklen	   = $dtconf{'ksklen'};
	$zsklen	   = $dtconf{'zsklen'};
	$ksklife   = $dtconf{'ksklife'};
	$zsklife   = $dtconf{'zsklife'};

	#
	# If the key's encryption algorithm isn't defined here, then we
	# can't check it or any of the encryption lengths.
	#
	if(!defined($algorithm))
	{
		qprint("algorithm not defined; can't check length values\n");
		$errs++;
		return;
	}
	vprint("algorithm is $algorithm\n");

	#
	# Search the algorithm list for this key's algorithm.  If we find
	# it, we'll mark that it's good.
	#
	if(defined($algorithm))
	{
		foreach my $alg (@algorithms)
		{
			if($alg eq $algorithm)
			{
				$found = 1;
				last;
			}
		}
	}

	#
	# If the key's encryption algorithm is bad, we'll give an error
	# message.  If it's okay, we'll make sure the length is in the
	# range of valid lengths for the key type.
	#
	if(!$found)
	{
		qprint("invalid algorithm:  \"$algorithm\"; can't check length values\n");
		$errs++;
		return;
	}

	#
	# Get the key length range for this algorithm.
	#
	$lowval  = $length_low{$algorithm};
	$highval = $length_high{$algorithm};

	#
	# Ensure the ZSK length is in the algorithm's value range.
	#
	if(!defined($dtconf{'ksklen'}))
	{
		vprint("ksklength not defined\n");
		$errs++;
	}
	else
	{
		vprint("ksklength is $ksklen\n");

		#
		# Ensure the KSK length is greater than the algorithm's
		# low value.
		#
		if($ksklen < $lowval)
		{
			qprint("invalid ksklength:  length ($ksklen) < minimum ($lowval) for $algorithm\n");
			$errs++;
		}

		#
		# Ensure the KSK length is greater than the algorithm's
		# high value.
		#
		if($ksklen > $highval)
		{
			qprint("invalid ksklength:  length ($ksklen) > maximum ($highval) for $algorithm\n");
			$errs++;
		}
	}

	#
	# Ensure the ZSK length is in the algorithm's value range.
	#
	if(!defined($dtconf{'zsklen'}))
	{
		vprint("zsklength not defined\n");
		$errs++;
	}
	else
	{
		vprint("zsklength is $zsklen\n");

		#
		# Ensure the ZSK length is greater than the algorithm's
		# low value.
		#
		if($zsklen < $lowval)
		{
			qprint("invalid zsklength:  length ($zsklen) < minimum ($lowval) for $algorithm\n");
			$errs++;
		}

		#
		# Ensure the ZSK length is greater than the algorithm's
		# high value.
		#
		if($zsklen > $highval)
		{
			qprint("invalid zsklength:  length ($zsklen) > maximum ($highval) for $algorithm\n");
			$errs++;
		}
	}

	#
	# Ensure the KSK life is in a lifespan value range.  This set of
	# checks is only performed if the -expert mode wasn't given.
	#
	if(!$expert)
	{
		if(!defined($ksklife))
		{
			vprint("ksklife not defined\n");
			$errs++;
		}
		else
		{
			vprint("ksklife is $ksklife\n");

			#
			# Ensure the KSK lifespan is greater than the suggested
			# minimum lifespan.
			#
			if($ksklife < $lifemin)
			{
				qprint("invalid ksklife:  lifespan ($ksklife) < minimum lifespan ($lifemin)\n");
				$errs++;
			}

			#
			# Ensure the KSK lifespan is less than the suggested
			# maximum lifespan.
			#
			if($ksklife > $lifemax)
			{
				qprint("invalid ksklife:  lifespan ($ksklife) > maximum lifespan ($lifemax)\n");
				$errs++;
			}
		}
	}

	#
	# Ensure the ZSK life is in a lifespan value range.  This set of
	# checks is only performed if the -expert mode wasn't given.
	#
	if(!$expert)
	{
		if(!defined($zsklife))
		{
			vprint("zsklife not defined\n");
			$errs++;
		}
		else
		{
			vprint("zsklife is $zsklife\n");

			#
			# Ensure the ZSK lifespan is greater than the suggested
			# minimum lifespan.
			#
			if($zsklife < $lifemin)
			{
				qprint("invalid zsklife:  lifespan ($zsklife) < minimum lifespan ($lifemin)\n");
				$errs++;
			}

			#
			# Ensure the ZSK lifespan is less than the suggested
			# maximum lifespan.
			#
			if($zsklife > $lifemax)
			{
				qprint("invalid zsklife:  lifespan ($zsklife) > maximum lifespan ($lifemax)\n");
				$errs++;
			}
		}
	}

}

#-----------------------------------------------------------------------------
#
# Routine:	signzone_checks()
#
# Purpose:	Check the signzone-related fields.
#
sub signzone_checks
{
	my $endtime;				# Zone end-time.
	my $etcnt;				# Count of seconds in endtime.

	#
	# Get the zone-related configuration entries.
	#
	$endtime = $dtconf{'endtime'};

	#
	# Check i the endtime isn't defined here.
	#
	if(!defined($endtime))
	{
		qprint("endtime not defined\n");
		return;
	}

	#
	# Get the endtime seconds from the endtime.
	#
	$endtime =~ /\+([0-9]+)/;
	$etcnt = $1;

	#
	# Give the appropriate message, depending on if the encryption
	# time is acceptable or not.
	#
	if($etcnt < $MINEND)
	{
		qprint("endtime ($endtime) < minimum realistic endtime ($MINEND)\n");
		$errs++;
	}
	else
	{
		vprint("endtime ($endtime) acceptable\n");
	}
}

#-----------------------------------------------------------------------------
#
# Routine:	check_file()
#
# Purpose:	Check the file configuration fields.
#
sub check_files
{
	file_check("random","c");
	file_check("checkzone","x");
	file_check("keygen","x");
	file_check("signzone","x");
	file_check("viewimage","x");
}

#-----------------------------------------------------------------------------
#
# Routine:	check_misc()
#
# Purpose:	Check several miscellaneous fields.
#
sub check_misc
{
	my $savekeys;					# Save-old-keys flag.

	#
	# Check some boolean flags.
	#
	bool_check('entropy_msg');
	bool_check('savekeys');
	bool_check('usegui');

	#
	# If savekeys is on, check that archdir is set to a directory.
	#
	$savekeys = $dtconf{'savekeys'};
	if($savekeys eq "1")
	{
		my $archdir = $dtconf{'archivedir'};

		if(defined($archdir) && ($archdir ne ""))
		{
			$archdir = $dtconf{'archivedir'};
			if(-d $archdir)
			{
				vprint("$archdir is an existing directory\n");
			}
			else
			{
				qprint("archivedir $archdir exists, but is not a directory\n");
				$errs++;
			}
		}
		else
		{
			qprint("savekeys is set on, but no archive directory is specified\n");
			$errs++;
		}
	}
}

#-----------------------------------------------------------------------------
#
# Routine:	file_check()
#
# Purpose:	Check the file fields:  ensure that the file exists and check
#		some basic file-specific data.
#
sub file_check
{
	my $field = shift;			# Field to check.
	my $ftype = shift;			# Type of file.
	my $fname;				# Name of file to check.

	$fname	= $dtconf{"$field"};

	#
	# If the field isn't defined, we'll return.
	#
	if(!defined($fname))
	{
		vprint("$field not defined\n");
		return;
	}

	#
	# If the filename isn't an absolute path, then we'll stop
	# checking here.
	#
	if($fname !~ /^\//)
	{
		qprint("no further checks for $field file $fname\n");
		return;
	}

	#
	# Ensure the file exists.
	#
	if(! -e $fname)
	{
		qprint("$field file $fname does not exist\n");
		$errs++;
		return;
	}

	#
	# Check some data about this file:
	#
	#	f - regular file
	#	x - regular file that must be executable
	#	c - character device file that must be readable
	#
	if($ftype eq "f")
	{
		if(-f $fname)
		{
			vprint("$field file $fname is a regular file\n");
		}
		else
		{
			qprint("$field file $fname is not a regular file\n");
			$errs++;
		}
	}
	elsif($ftype eq "x")
	{
		if(-f $fname)
		{
			vprint("$field file $fname is a regular file\n");
		}
		else
		{
			qprint("$field file $fname is not a regular file\n");
			$errs++;
		}
		if(-x $fname)
		{
			vprint("$field file $fname is an executable file\n");
		}
		else
		{
			qprint("$field file $fname is not an executable file\n");
			$errs++;
		}
	}
	elsif($ftype eq "c")
	{
		if(-c $fname)
		{
			vprint("$field file $fname is a character device file\n");
		}
		else
		{
			qprint("$field file $fname is not a character device file\n");
			$errs++;
		}
		if(-r $fname)
		{
			vprint("$field file $fname is a readable file\n");
		}
		else
		{
			qprint("$field file $fname is not a readable file\n");
			$errs++;
		}
	}

}

#-----------------------------------------------------------------------------
#
# Routine:	bool_check()
#
# Purpose:	Checks a boolean for good values (0 or 1.)
#
sub bool_check
{
	my $label = shift;				# Label to check.
	my $val;					# Value of label.

	$val = $dtconf{$label};
	if(($val ne "0") && ($val ne "1"))
	{
		qprint("$label flag has unrecognized value  ($val)\n");
		$errs++;
	}
	else
	{
		vprint("$label ($val) acceptable\n");
	}
}

#-----------------------------------------------------------------------------
#
# Routine:	qprint()
#
# Purpose:	Prints a line of output if -quiet and -summary weren't given.
#
sub qprint
{
	my $line = shift;

	print $line if(!$quiet && !$summary);
}

#-----------------------------------------------------------------------------
#
# Routine:	sqprint()
#
# Purpose:	Prints a line of output if -quiet wasn't given or if
#		-summary was given.
#
#		This is intended to be used only by the final summarizing
#		output lines of dtconfchk.
#
sub sqprint
{
	my $line = shift;

	print $line if(!$quiet || $summary);
}

#-----------------------------------------------------------------------------
#
# Routine:	vprint()
#
# Purpose:	Prints a line of output if -verbose was given.
#
sub vprint
{
	my $line = shift;

	qprint($line) if($verbose);
}

#-----------------------------------------------------------------------------
#
# Routine:	usage()
#
sub usage
{
	print STDERR "usage:  confchk [options] <config file>\n";
	print STDERR "\toptions:\n";
	print STDERR "\t\t-expert\n";
	print STDERR "\t\t-quiet\n";
	print STDERR "\t\t-status\n";
	print STDERR "\t\t-verbose\n";
	print STDERR "\t\t-help\n";
	exit(0);
}

1;

##############################################################################
#

=pod

=head1 NAME

confchk - Check a DNSSEC-Tools configuration file for sanity.

=head1 SYNOPSIS

  confchk [options] [config_file]

=head1 DESCRIPTION

I<confchk> checks a DNSSEC-Tools configuration file to determine if the
entries are valid.

The I<default_keyrec> configuration entry is not checked.  This entry
specifies the default I<keyrec> file name and isn't necessarily expected
to exist in any particular place.

=head2 Key-related Checks

The following key-related checks are performed:

=over 8

=item I<algorithm>

Ensure the I<algorithm> field is valid.  The acceptable values may be found
in the I<dnssec-keygen> man page.

=item I<ksklength>

Ensure the I<ksklength> field is valid.  The acceptable values may be found
in the I<dnssec-keygen> man page.

=item I<ksklife>

Ensure the I<ksklife> field is valid.  The acceptable values may be found
in the B<Net::DNS::SEC::Tools::defaults.pm(3)> man page.

=item I<zsklength>

Ensure the I<zsklength> field is valid.  The acceptable values may be found
in the I<dnssec-keygen> man page.

=item I<zsklife>

Ensure the I<zsklife> field is valid.  The acceptable values may be found
in the B<Net::DNS::SEC::Tools::defaults.pm(3)> man page.

=item I<random>

Ensure the I<random> field is valid.  This file must be a character
device file.

=back

=head2 Zone-related Checks

The following zone-related checks are performed:

=over 8

=item I<endtime>

Ensure the I<endtime> field is valid.  This value is assumed to be in the
"+NNNNNN" format.  There is a lower limit of two hours.  (This is an
artificial limit under which it may not make sense to have an endtime.)

=back

=head2 Path Checks

The following path checks are performed:

=over 8

=item I<checkzone>

Ensure the I<checkzone> field is valid.  If the filename starts with a '/',
the file must be a regular executable file.

=item I<keygen>

Ensure the I<keygen> field is valid.  If the filename starts with a '/',
the file must be a regular executable file.

=item I<signzone>

Ensure the I<signzone> field is valid.  If the filename starts with a '/',
the file must be a regular executable file.

=item I<viewimage>

Ensure the I<viewimage> field is valid.  If the filename starts with a '/',
the file must be a regular executable file.

=back

=head2 Miscellaneous Checks

The following miscellaneous checks are performed:

=over 8

=item I<archivedir>

Ensure that the I<archivedir> directory is actually a directory.
This check is only performed if the I<savekeys> flag is set on.

=item I<entropy_msg>

Ensure that the I<entropy_msg> flag is either 0 or 1.

=item I<savekeys>

Ensure that the I<savekeys> flag is either 0 or 1.
If this flag is set to 1, then the I<archivedir> field will also be checked.

=item I<usegui>

Ensure that the I<usegui> flag is either 0 or 1.

=back

=head1 OPTIONS

=over 4

=item -expert

Only non-expert checks will be performed.  Currently, this option will prevent
the key lifespan checks from being run.

=item -quiet

No output will be given, but the number of errors will be used as the
exit code.

=item -summary

A final summary of success or failure will be printed.
The number of errors will be used as the exit code.

=item -verbose

Success or failure status of each check will be given.
The number of errors will be used as the exit code.

=item -help

Display a usage message.

=back

=head1 COPYRIGHT

Copyright 2004-2006 SPARTA, Inc.  All rights reserved.
See the COPYING file included with the DNSSEC-Tools package for details.

=head1 AUTHOR

Wayne Morrison, tewok@users.sourceforge.net

=head1 SEE ALSO

B<Net::DNS::SEC::Tools::conf.pm(3)>,
B<Net::DNS::SEC::Tools::defaults.pm(3)>

=cut
