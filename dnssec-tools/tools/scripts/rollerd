#!/usr/bin/perl
#
# Copyright 2005-2006 SPARTA, Inc.  All rights reserved.  See the COPYING
# file distributed with this software for details
#
#
# rollerd
#
#	This script manages the key rollover process.
#
#	ZSK rollover takes place in four phases:
#		- wait until it's time to perform a ZSK rollover
#		- sign the zone with the KSK and Published ZSK
#		- wait for old zone data to expire from caches
#		- sign the zone with the new Current ZSK key
#

use strict;

use Cwd;
use Getopt::Long;

use Net::DNS::SEC::Tools::conf;
use Net::DNS::SEC::Tools::defaults;
use Net::DNS::SEC::Tools::keyrec;
use Net::DNS::SEC::Tools::rollmgr;
use Net::DNS::SEC::Tools::rollrec;
use Net::DNS::SEC::Tools::timetrans;
use Net::DNS::SEC::Tools::tooloptions;
use Net::DNS::SEC::Tools::BootStrap;

use Net::DNS::ZoneFile::Fast;

use POSIX qw(setsid);

#
# Version information.
#
my $NAME   = "rollerd";
my $VERS   = "$NAME version: 0.1";
my $DTVERS = "DNSSEC-Tools Version: 0.9.1";

#######################################################################

my $ME		= "rollerd";

#
# Some path variables to be set from the config file.
#
my $rndc;
my $rrchk;

my $DEFAULT_NAP	= 60;

##########################################
#
# Data required for command line options.
#
my $rollrecfile;			# Rollrec file to be managed.

my %dtconf;				# DNSSEC-Tools config file.
my $DT_LOGFILE	= "roll_logfile";
my $DT_LOGLEVEL	= "roll_loglevel";
my $DT_SLEEP	= "roll_sleeptime";

my $OPT_HELP	 = "help";
my $OPT_DIR	 = "directory";
my $OPT_DISPLAY	 = "display";
my $OPT_LOGFILE	 = "logfile";
my $OPT_LOGLEVEL = "loglevel";
my $OPT_PARAMS	 = "parameters";
my $OPT_RRFILE	 = "rrfile";
my $OPT_SLEEP	 = "sleep";
my $OPT_VERBOSE	 = "verbose";
my $OPT_VERSION	 = "Version";

my %opts = ();			# Filled option array.
my @opts =
(
	"rrfile=s",			# Rollrec file.
	"directory=s",			# Execution directory.
	"display",			# Use output GUI.
	"logfile=s",			# Log file.
	"loglevel=s",			# Logging level.
	"sleep=i",			# Sleep amount (in seconds.)
	"parameters",			# Display the parameters and exit.
	"help",				# Give a usage message and exit.
	"verbose",			# Verbose output.
	"Version",			# Display the version number.
);

#
# Flag values for the various options.  Variable/option connection should
# be obvious.
#
my $logfile;				# Log file.
my $loglevel;				# Logging level.
my $sleeptime;				# Sleep interval in seconds.
my $sleepcnt;				# Time we've slept so far.
my $verbose = 0;			# Verbose option.


my $display = 0;			# Do display processing.

my $boottime = gmtime();		# Timestamp of rollerd's start time.
my $version  = 0;			# Display the version number.

my $MIN_SLEEP = 10;			# Minimum time rollerd will sleep.


#######################################################################

my $ret;				# Return code from main().

#
# Detect required Perl modules.
#
dnssec_tools_load_mods('Date::Parse'	=> "",
		       'Date::Format'	=> "",);

#
# Do Everything.
#
$ret = main();
exit($ret);

#-----------------------------------------------------------------------------
# Routine:	main()
#
# Purpose:	Do Everything.
#
#			 steps:
#				while rollrec file is not empty
#					read rollrec file
#
#					for each rollrec in the rollrec file
#						handle according to its phase
#
sub main
{
	my $argc;			# Number of command line arguments.

	my $errors = 0;			# Total error count.

	#
	# Check our options and arguments.
	#
	%dtconf = parseconfig();
	optsandargs();
	getprogs();

	#
	# Daemonize ourself.
	#
	exit(0) if(fork());
	POSIX::setsid();

	#
	# Ensure we're the only rollerd running and drop a pid file.
	#
	if(rollmgr_dropid() == 0)
	{
		print STDERR "another rollerd is already running\n";
		rollmgr_log(LOG_ALWAYS,"","another rollerd tried to start");
		cleanup();
	}

	#
	# Tell the log we're up.
	#
	bootmsg(1);

	#
	# Set up the command channel.
	#
	rollmgr_channel(1);

	#
	# Main event loop.  If the rollrec file is okay, we'll read it,
	# check its zones -- rolling 'em if need be -- and saving its state.
	# We'll always check for user commands and then sleep a bit.
	#
	while(42)
	{
# rollmgr_log(LOG_ALWAYS,"","looping ------------------------------------------");

		#
		# Turn off signal handlers so they don't interrupt us
		# while we're running the queue.
		#
		controllers(0);

		#
		# If we have a valid rollrec file, we'll read its contents
		# and handle for expired ZSKs.
		#
		if(rrfchk($rollrecfile))
		{
			my $kronos1;			# Check's start time.
			my $kronos2;			# Check's end time.
			my $kronodiff;			# Difference of times.
			my $kronos;			# difference string.

			#
			# Get the contents of the rollrec file and check
			# for expired ZSKs.
			#
			rollrec_lock();
			if(rollrec_read($rollrecfile) > 0)
			{
				#
				# Check the zones for expired ZSKs.  We'll also
				# keep track of how long it takes to check the
				# ZSKs.
				#
				$kronos1 = time;
				zsk_check();
				$kronos2 = time;
				$kronodiff = $kronos2 - $kronos1;
				$kronos = timetrans($kronodiff);
				rollmgr_log(LOG_TMI,"<timer>","ZSKs checked in $kronos");

				#
				# Save the current rollrec file state.
				#
				rollrec_close();
			}
			rollrec_unlock();
		}

		#
		# Check for user commands.
		#
		commander();

		#
		# Turn our signal handlers and then take a nap.
		#
		controllers(1);
		sleeper($sleeptime);

	}
}

###############################################################################

#-----------------------------------------------------------------------------
# Routine:	zsk_check()
#
# Purpose:	Go through the zones in the rollrec file and start rolling
#		those which have expired.
#
sub zsk_check
{
	my @rrfstats;			# Stats for rollrec file.

	foreach my $rname (rollrec_names())
	{
		my $rrr;		# Reference to rollrec.
		my %rr;			# Rollrec hash.
		my $phase;		# Rollrec's phase.

		#
		# Get the rollrec for this name.  If it doesn't have one,
		# whinge and continue to the next.
		# (This should never happen, but...)
		#
		$rrr = rollrec_fullrec($rname);
		if(!defined($rrr))
		{
			rollmgr_log(LOG_ERR,$rname,"no rollrec defined for zone");
			next;
		}
		%rr = %$rrr;

		#
		# Don't do anything with skip records.
		#
		if($rr{'rollrec_type'} eq "skip")
		{
			rollmgr_log(LOG_TMI,$rname,"is a skip rollrec");
			next;
		}

		#
		# Do basic set-up for brand new records.
		#
		if($rr{'curphase'} == -1)
		{
			rollmgr_log(LOG_CURPHASE,$rname,"new rollrec");
			newphase($rname,$rrr,0)
		}

		#
		# If this zone's current ZSK has expired, we'll get it rolling.
		# 
		if(zsk_expired($rname,$rrr,"zskcur"))
		{
			rollmgr_log(LOG_CURPHASE,$rname,"current ZSK has expired\n") if($rr{'curphase'} == 0);

			zsk_phaser($rname,$rrr);
		}
		else
		{
			rollmgr_log(LOG_TMI,$rname,"current ZSK still valid");
		}
	}
}

#-----------------------------------------------------------------------------
# Routine:	zsk_phaser()
#
# Purpose:	Move the specified zone through the appropriate phases.
#
sub zsk_phaser
{
	my $rname = shift;		# Zone name.
	my $rrr = shift;		# Reference to rollrec.

	my %rr;				# Rollrec hash.
	my $phase;			# Zone's current rollover phase.

	#
	# Get this rollrec record's current phase.
	#
	%rr = %$rrr;
	$phase = $rr{'curphase'};

	#
	# Work on this rollrec's phase.
	#
	$phase = newphase($rname,$rrr,1)	if($phase == 0);
	$phase = zsk_phasewait($rname,$rrr,1)	if($phase == 1);
	$phase = zsk_phase2($rname,$rrr)     	if($phase == 2);
	$phase = zsk_phasewait($rname,$rrr,3)	if($phase == 3);
	$phase = zsk_phase4($rname,$rrr)     	if($phase == 4);

}

#-----------------------------------------------------------------------------
# Routine:	zsk_phasewait()
#
# Purpose:	Check if this zone's rollover-wait phase is over.
#		The zone's phase number -- current or new -- is returned.
#
sub zsk_phasewait
{
	my $rname = shift;			# Name of rollrec.
	my $rrr	  = shift;			# Reference to rollrec.
	my $phase = shift;			# Rollover phase.

	my %rr;					# Rollrec hash.

	#
	# Get the rollrec.
	#
	$rrr = rollrec_fullrec($rname);
	%rr = %$rrr;

	#
	# Check if we can go to the next rollover phase.  If not, we'll
	# go to the next rollrec entry and return to this later.
	#
	if(!ttlexpire($rname,$rrr,$phase))
	{
		return($phase);
	}

	#
	# Bump this rollrec's phase number and return the new phase.
	#
	$phase++;
	newphase($rname,$rrr,$phase);
	return($phase);
}

#-----------------------------------------------------------------------------
# Routine:	zsk_phase2()
#
# Purpose:	Perform the phase 2 steps of the rollover.  These are:
#
#			- sign the zone with the KSK and published ZSK
#			- reload the zone
#			- wait for old zone data to expire
#
sub zsk_phase2
{
	my $rname = shift;		# Name of rollrec.
	my $rrr = shift;		# Reference to rollrec.

	my %rr = %$rrr;			# Rollrec hash.

	my $krf;			# Rollrec's keyrec name.
	my %krf;			# Keyrec hash.
	my $krr;			# Keyrec reference.

	my $ret;			# Result from command executions.

	#
	# Get the rollrec's associated keyrec file and ensure that it
	# exists.
	#
	$krf = $rr{'keyrec'};
	if(!$krf  || ($krf eq ""))
	{
		rollmgr_log(LOG_ERR,$rname,"phase 2:  no keyrec for zone specified");
		return;
	}
	if(! -e $krf)
	{
		rollmgr_log(LOG_ERR,$rname,"phase 2:  keyrec \"$krf\" for zone does not exist");
		return;
	}

	#
	# Get the keyrec.
	#
	$krr = opts_zonekr($krf,$rname);
	%krf = %$krr;

	#
	# Sign the zone with the published ZSK.
	#
	$ret = signer($rname,"-usepub",$krr);
	if($ret eq "")
	{
		rollmgr_log(LOG_ERR,$rname,"phase 2:  unable to sign zone with the published ZSK");
	}

	#
	# Update the timestamp in the zone's keyrec.
	#
	keyrec_settime("zone",$rname);
	keyrec_write();

	#
	# Reload the zone.
	#
	$ret = rollmgr_loadzone($rndc,$rname);
	if($ret != 0)
	{
#		rollmgr_log(LOG_ERR,$zone,"unable to reload zone, rc - $ret");
	}

	#
	# Bump this rollrec's phase number and return the new phase.
	#
	newphase($rname,$rrr,3);
	return(3);

}

#-----------------------------------------------------------------------------
# Routine:	zsk_phase4()
#
# Purpose:	Perform the phase 4 steps of the rollover.  These are:
#
#			- juggle the ZSKs in the zone's keyrec
#			- sign the zone with the KSK and new current ZSK
#			- reload the zone
#			- return the zone to the pre-rollover state
#
sub zsk_phase4
{
	my $rname = shift;		# Name of rollrec.
	my $rrr = shift;		# Reference to rollrec.

	my %rr = %$rrr;			# Rollrec hash.

	my $krf;			# Rollrec's keyrec name.
	my %krf;			# Keyrec hash.
	my $krr;			# Keyrec reference.

	my $ret;			# Result from command executions.

	#
	# Get the rollrec's associated keyrec file and ensure that it
	# exists.
	#
	$krf = $rr{'keyrec'};
	if(!$krf  || ($krf eq ""))
	{
		rollmgr_log(LOG_ERR,$rname,"phase 4:  no keyrec for zone specified");
		return;
	}
	if(! -e $krf)
	{
		rollmgr_log(LOG_ERR,$rname,"phase 4:  keyrec \"$krf\" for zone does not exist");
		return;
	}

	#
	# Get the keyrec.
	#
	rollmgr_log(LOG_TMI,$rname,"keyrec file is $krf");
	$krr = opts_zonekr($krf,$rname);
	%krf = %$krr;

	#
	# Adjust ZSKs in the zone's keyrec.
	#
	$ret = signer($rname,"-forceroll",$krr);
	if($ret eq "")
	{
		rollmgr_log(LOG_ERR,$rname,"phase 4:  unable to adjust ZSK keyrec");
	}

	#
	# Sign the zone with the current ZSK.
	#
	$ret = signer($rname,"",$krr);
	if($ret eq "")
	{
		rollmgr_log(LOG_ERR,$rname,"phase 4:  unable to sign zone with the current ZSK");
	}

	#
	# Reload the zone.
	#
	$ret = rollmgr_loadzone($rndc,$rname);
	if($ret != 0)
	{
#		rollmgr_log(LOG_ERR,$zone,"unable to reload zone, rc - $ret");
	}

	#
	# Put ourselves back in the pre-roll state.
	#
	newphase($rname,$rrr,0);
	return(0);
}

###############################################################################

#-----------------------------------------------------------------------------
# Routine:	zsk_expired()
#
# Purpose:	This routine returns a boolean indicating if the specified
#		zone has an expired ZSK key of the given type.
#
#		The zone's keyrec file name is taken from the given rollrec
#		entry.  The keyrec file is read and the zone's entry found.
#		The key keyrec of the specified key type (currently, just
#		"zskcur") is pulled from the keyrec file.  Each key in the
#		named signing set will be checked.
#		
#		Key expiration is determined by comparing the key keyrec's
#		gensecs field to the current time.  The key hasn't expired
#		if the current time is less than the gensecs; the key has
#		expired if the current time is greater than the gensecs.
#
sub zsk_expired
{
	my $rname = shift;			# Name of rollrec rec.
	my $rrr = shift;			# Reference to rollrec.
	my $key = shift;			# Key to check.

	my %rr;					# Rollrec hash.

	my $krname;				# Name of keyrec.
	my $krec;				# Keyrec reference.
	my %set;				# Keyrec hash.

	my @signset;				# Key's signing set.

	my $expired = 0;			# Expired-zone flag.

	#
	# If this zone is in the middle of rollover processing, we'll
	# immediately assume the key has expired.
	#
	%rr = %$rrr;
	return(1) if($rr{'curphase'} > 0);

	#
	# Get the rollin' key's keyrec for our zone.
	#
	$krname = $rr{'keyrec'};
	$krec = zonekeykr($rname,$krname,$key);
	if($krec == 0)
	{
		rollmgr_log(LOG_ERR,$rname,"unable to find a keyrec for \"$key\" is \"$krname\"");
		return(0);
	}
	%set   = %$krec;

	#
	# Make sure we've got an actual set keyrec and keys.
	#
	if($set{'keyrec_type'} ne 'set')
	{
		rollmgr_log(LOG_ERR,$rname,"\"$key\"'s keyrec is not a set keyrec");
		return(0);
	}
	if(!defined($set{'keys'}) || ($set{'keys'} eq ""))
	{
		rollmgr_log(LOG_ERR,$rname,"\"$krname\" has no keys; unable to check expiration");
		return(0);
	}

	#
	# Check each key in the signing set to see if one has expired.
	# If any have, we'll start rollover.
	#
	@signset = split / /, $set{'keys'};
	foreach my $keyname (@signset)
	{
		my $khr;				# Ref to key's hash.
		my %kh;					# Key's hash.

		my $life;				# Name of keylife field.
		my $cronus;				# Current time.
		my $gentime;				# Key's generation date.
		my $exptime;				# Key's lifespan.
		my $krsecs;				# Key's expiration date.
		my $waitsecs;				# Time to expiration.
		my $chronostr;				# Text expiration time.

		#
		# Get the key's keyrec hash.
		#
		$khr = keyrec_fullrec($keyname);
		%kh = %$khr;

		#
		# Ensure that required keyrec fields exist.
		#
		if(!defined($kh{"keyrec_gensecs"}))
		{
			rollmgr_log(LOG_ERR,$rname,"keyrec does not contain a keyrec_gensecs record");
			return(0);
		}
		$life = $kh{"keyrec_type"};
		$life = substr($life,0,3) . "life";
		if(!defined($kh{$life}))
		{
			rollmgr_log(LOG_ERR,$rname,"keyrec does not contain a $life record");
			return(0);
		}

		#
		# Get the key's generation time and the current time.
		#
		$gentime = $kh{"keyrec_gensecs"};
		$cronus	 = time;

		#
		# Calculate the key's expiration time.
		#
		$exptime = $kh{$life};
		$krsecs = $gentime + $exptime;

		#
		# Calculate the log message we should give.
		#
		$waitsecs = $krsecs - $cronus;
		if($waitsecs >= 0)
		{
			$chronostr = timetrans($waitsecs);
			rollmgr_log(LOG_EXPIRE,$rname,"        expiration in $chronostr\n");
			display("expiration $rname 0 $waitsecs");
		}
		else
		{
			$waitsecs = $cronus - $krsecs;
			$chronostr = timetrans($waitsecs);
			rollmgr_log(LOG_EXPIRE,$rname,"        expired $chronostr ago\n");
			display("phase $rname 0");
		}

		#
		# The key has expired if the current time has passed the
		# key's lifespan.
		# The key has not expired if the key's lifespan has yet
		# to reach the current time.
		#
		$expired = 1 if($cronus > $krsecs);

	}

	#
	# Return the success/failure indication.
	#
	return($expired);
}

#-----------------------------------------------------------------------------
# Routine:	maxttl()
#
# Purpose:	Calculate the zone's maximum TTL value, based on the largest
#		TTL in its zone file.
#
sub maxttl
{
	my $signdb = shift;		# Signed zone's db filename.

	my $rrsref;			# Reference to zone's resource records.
	my @rrs;			# Zone's resource records.
	my $numrrs;			# Number of resource records in zone.
	my $rrref;			# Reference to a resource record.
	my %rr;				# A resource record to examine.
	my $maxttl = -1;		# Zone's maximum time-to-live value.
	my $ttl;			# Time-to-live value from a record.

	#
	# Ensure the zone file exists.
	#
	if(! -e $signdb)
	{
		rollmgr_log(LOG_ERR,$signdb,"zone file does not exist");
		return(-1);
	}

	#
	# Get the zone's resource record collection.
	#
	$rrsref = Net::DNS::ZoneFile::Fast::parse(file => $signdb);

	#
	# Get the number of resource records in the zone.
	#
	@rrs = @$rrsref;
	$numrrs = @rrs;

	#
	# Look at each resource record and save the largest value.
	#
	for(my $ind=0;$ind<$numrrs;$ind++)
	{
		$rrref = $rrs[$ind];
		%rr = %$rrref;

		$ttl = $rr{'ttl'};
		$maxttl = $ttl if($ttl > $maxttl);
	}

	#
	# Return the zone's maximum TTL value to our caller.
	#
	return($maxttl);
}

#-----------------------------------------------------------------------------
# Routine:	ttlexpire()
#
# Purpose:	Returns a boolean indicating if we can move to the next phase
#		of rollover.  This is calculated by adding twice the TTL
#		length to the time we entered this phase.  If this is greater
#		than the current time, then we must wait a bit longer.  If
#		this is less than the current time, then we can proceed to
#		the next rollover phase.
#
# Return Values:
#		0 - Zone's expiry date has not passed.
#		1 - Zone's expiry date has passed.
#
sub ttlexpire
{
	my $rname = shift;			# Name of rollrec.
	my $rrr	  = shift;			# Reference to rollrec.
	my $phase = shift;			# Zone's current phase.

	my %rr;					# Rollrec hash.

	my $zonefile;				# Zone file.
	my $maxttl;				# Zone's maximum TTL value.
	my $phstart;				# Start of zone's phase.

	my $curtime;				# Current time string.
	my $curtempus;				# Current time in seconds.
	my $endtempus;				# End-date in seconds.

	my $timediff;				# Time until expiration.
	my $tdstr;				# String of timediff.

	#
	# Get a few fields from the rollrec.
	#
	%rr = %$rrr;
	$zonefile = $rr{'zonefile'};
	$phstart  = $rr{'phasestart'};

	#
	# Get the signed zonefile's maximum TTL and save it into the
	# rollrec.  We'll then double it as a safety margin.
	#
	$maxttl	= maxttl($zonefile);
	rollrec_setval($rname,"maxttl",$maxttl);
	$maxttl	*= 2;

	#
	# Get the current time in seconds.
	#
	$curtime = gmtime;
	$curtempus = str2time($curtime);

	#
	# Get the end-time (in seconds) and add the TTL.
	#
	$endtempus = str2time($phstart);
	$endtempus += $maxttl;

	#
	# Give any desired verbose output.
	#
	if($verbose)
	{
		my $endtime;				# End-date string.

		$endtime = ctime($endtempus);
		chomp $endtime;

		rollmgr_log(LOG_TMI,$rname,"rollover TTL check");
		rollmgr_log(LOG_TMI,$rname,"endtime\t$endtime");
		rollmgr_log(LOG_TMI,$rname,"curtime\t$curtime");
	}

	#
	# Return success if we've passed the zone's adjusted end-date.
	# Return failure (not expired) if the zone's adjusted end-date
	# is in the future.
	#
# rollmgr_log(LOG_INFO,$rname,"phase $phase; pre-return ($curtempus) ($endtempus)");
	return(1) if($curtempus >= $endtempus);

	$timediff = $endtempus - $curtempus;
	$tdstr = timetrans($timediff);
	rollmgr_log(LOG_INFO,$rname,"phase $phase; cache expires in $tdstr");
	display("expiration $rname $phase $timediff");

	return(0)
}

#-----------------------------------------------------------------------------
# Routine:	newphase()
#
# Purpose:	Moves a rollrec into the next phase, setting both the
#		phase number and the phase start time.
#
sub newphase
{
	my $rname = shift;				# Name of rollrec.
	my $rrr	  = shift;				# Rollrec reference.
	my $phase = shift;				# New phase.

	my %rr = %$rrr;					# Rollrec hash.

	my $krname;					# Name of key's rollrec.
	my $krec;					# Key's keyrec.

	my $setrec;					# Set's keyrec.
	my $setlist;					# Set's key list.

	my $exptime;					# Key's time to expiry.
	my $chronostr;					# Pretty rollover time.

	if($phase == 1)
	{
		rollmgr_log(LOG_TMI,$rname,"starting rollover");
	}
	else
	{
		rollmgr_log(LOG_TMI,$rname,"moving to phase $phase");
	}

	rollmgr_log(LOG_CURPHASE,$rname,"phase $phase");

	$rr{'curphase'} = $phase;
	rollrec_setval($rname,"curphase",$phase);
	rollrec_settime($rname);
	rollrec_write();

	display("phase $rname $phase");

	#
	# If we're at the start of a rollover, we'll log the expiration time.
	#
	return if($phase != 0);

	#
	# Get the rollin' key's keyrec for our zone.
	#
	$krname = $rr{'keyrec'};
	$setrec = zonekeykr($rname,$krname,"zskcur");
	if($setrec == 0)
	{
		rollmgr_log(LOG_ERR,$rname,"unable to find a keyrec for the zskcur signing set in \"$krname\"");
		return(0);
	}

	#
	# Make sure we've got an actual set keyrec and keys.
	#
	if($setrec->{'keyrec_type'} ne 'set')
	{
		rollmgr_log(LOG_ERR,$rname,"\"$krname\"'s keyrec is not a set keyrec; unable to move to phase $phase");
		return(0);
	}
	if(!defined($setrec->{'keys'}) || ($setrec->{'keys'} eq ""))
	{
		rollmgr_log(LOG_ERR,$rname,"\"$krname\" has no keys; unable to move to phase $phase");
		return(0);
	}

	#
	# Find the key with the shortest lifetime.
	#
	$setlist = $setrec->{'keys'};
	foreach my $key (split / /, $setlist)
	{
		my $lifetime = keyrec_recval($key,'zsklife');
		if(($exptime == 0) || ($lifetime < $exptime))
		{
			$exptime = $lifetime;
		}
	}

	#
	# Tell the log when the zone will expire, based on the lifespan.
	#
	$chronostr = timetrans($exptime);
	rollmgr_log(LOG_INFO,$rname,"    expiration in $chronostr\n");
}

#-----------------------------------------------------------------------------
# Routine:	signer()
#
# Purpose:	Signs a zone with a specified ZSK.
#
#		On success, the return value of the zone-signing command
#			is returned.
#		On failure, "" is returned.
#
sub signer
{
	my $rname  = shift;			# Name of rollrec.
	my $zsflag = shift;			# Flag for key generation.
	my $rrr	   = shift;			# Reference to rollrec.

	my %rr;					# Rollrec hash.

	my $zonefile;				# Zone file from keyrec.
	my $zonesigned;				# Signed zone file from keyrec.
	my $cmdstr;				# Command to be executed.

	#
	# Dig a few data out of the zone's keyrec file.
	#
	$zonefile = getkrval($rname,$rrr,"zonefile");
	return("") if($zonefile eq "");

	$zonesigned = getkrval($rname,$rrr,"signedzone");
	return("") if($zonesigned eq "");

	#
	# Have zonesigner sign the zone for us.
	#
	$cmdstr = "zonesigner $zsflag $zonefile $zonesigned";
	rollmgr_log(LOG_INFO,$rname,"executing \"$cmdstr\"");

	$ret = `$cmdstr`;

	return($ret);
}

#-----------------------------------------------------------------------------
# Routine:	zonekeykr()
#
# Purpose:	This routine returns the specified key's keyrec from the
#		specified zone from the specified keyrec file.
#		This routine is big on specified things.
#
sub zonekeykr
{
	my $rname = shift;			# Name of rollrec rec.
	my $krname = shift;			# Name of keyrec.
	my $key = shift;			# Key to check.

	my $krec;				# Keyrec reference.
	my %kh;					# Keyrec hash.

	#
	# Get the keyrec file's name and then read the file.
	#
	keyrec_read($krname);

	#
	# Get the zone's keyrec and complain if it doesn't exist.
	#
	$krec = keyrec_fullrec($rname);
	if(!defined($krec))
	{
		rollmgr_log(LOG_ERR,$rname,"keyrec file \"$krname\" does not contain a keyrec for zone \"$rname\"");
		return(0);
	}
	%kh   = %$krec;

	#
	# Get the key's keyrec and complain if it doesn't exist.
	#
	$key = $kh{$key};
	$krec = keyrec_fullrec($key);
	if(!defined($krec))
	{
		rollmgr_log(LOG_ERR,$rname,"keyrec file \"$krname\" does not contain a keyrec for key");
		return(0);
	}

	return($krec);
}

#-----------------------------------------------------------------------------
# Routine:	getkrval()
#
# Purpose:	This routine returns the value of a specified field in a
#		keyrec.  Error checking is performed to ensure that the
#		field exists in the keyrec and that it doesn't have an
#		empty value.
#
sub getkrval
{
	my $name = shift;				# Owner's name.
	my $krr	  = shift;				# Keyrec reference.
	my $field = shift;				# Keyrec's field.

	my %kh = %$krr;					# Keyrec hash.
	my $val;					# Field's value.

	#
	# Ensure that the requested field exists.
	#
	if(!defined($kh{$field}))
	{
		rollmgr_log(LOG_ERR,$name,"keyrec has no entry for \"$field\"");
		return("");
	}

	#
	# Get the field from the keyrec.
	#
	$val = $kh{$field};

	#
	# Give an error if the value is empty.
	#
	if($val eq "")
	{
		rollmgr_log(LOG_ERR,$name,"keyrec has an empty entry for \"$field\"");
	}

	return($val);
}

##############################################################################

#-----------------------------------------------------------------------------
# Routine:	optsandargs()
#
# Purpose:	Parse our options and arguments.
#
sub optsandargs
{
	my $argc = @ARGV;				# Number of arguments.
	my $dir;					# Execution directory.

	#
	# Check our options.
	#
	GetOptions(\%opts,@opts);
	$version   = $opts{$OPT_VERSION};
	$verbose   = $opts{$OPT_VERBOSE};
	$logfile   = $opts{$OPT_LOGFILE}  || $dtconf{$DT_LOGFILE};
	$loglevel  = $opts{$OPT_LOGLEVEL} || $dtconf{$DT_LOGLEVEL} || LOG_DEFAULT;
	$sleeptime = $opts{$OPT_SLEEP}	  || $dtconf{$DT_SLEEP}    || $DEFAULT_NAP;

	$display = $opts{$OPT_DISPLAY}	  || 0;

	#
	# Show the version number if requested
	#
	usage() if(defined($opts{$OPT_HELP}));
	version() if(defined($opts{$OPT_VERSION}));

	#
	# Check for a rollrec file name.
	#
	$rollrecfile = $opts{$OPT_RRFILE} || rollrec_default();

	#
	# Move into our execution directory.
	#
	$dir = $opts{$OPT_DIR} || getconfdir();
	if(!defined($dir))
	{
		print STDERR "rollerd:  no execution directory defined\n";
		exit(1);
	}
	if(! -e $dir)
	{
		print STDERR "rollerd:  execution directory \"$dir\" does not exist\n";
		exit(1);
	}
	if(! -d $dir)
	{
		print STDERR "rollerd:  execution directory \"$dir\" is not a directory\n";
		exit(1);
	}
	chdir($dir);

	#
	# Complain and die if a log file wasn't given on the command line
	# or in the config file.
	#
	if(!defined($logfile))
	{
		print STDERR "rollerd:  no logfile specified on command line or in dnssec-tools.conf\n";
		exit(1);
	}

	#
	# Set the logging level and file.
	#
	rollmgr_loglevel($loglevel,1);
	rollmgr_logfile($logfile,1);

	#
	# If the user only wants the parameters, print 'em and exit.
	#
	if($opts{$OPT_PARAMS})
	{
		print "$ME parameters:\n";
		print "	rollrec file	\"$rollrecfile\"\n";
		print "	directory	\"$dir\"\n";
		print "	logfile		\"$logfile\"\n";
		print "	loglevel	\"$loglevel\"\n";
		print "	sleeptime	\"$sleeptime\"\n";
		exit(0)
	}

	#
	# Start up our display program if -display was given.
	#
	displayer($display);

}

#-----------------------------------------------------------------------------
# Routine:	getprogs()
#
# Purpose:	Get some program paths.
#
sub getprogs
{
	#
	# Get the paths to the external commands.  If they aren't defined,
	# use the default command names.
	#
	$rndc 	= $dtconf{'rndc'}	 || dnssec_tools_defaults("bind_rndc");
	$rrchk	= $dtconf{'rollrec_chk'} || dnssec_tools_defaults("rollrec_check");
}

#-----------------------------------------------------------------------------
# Routine:	bootmsg()
#
# Purpose:	Write a start-up message to the log.
#
sub bootmsg
{
	my $bootflag = shift;				# Boot flag.

	if($bootflag)
	{
		rollmgr_log(LOG_ALWAYS,"","$ME starting " . ("-" x 40));
	}
	else
	{
		rollmgr_log(LOG_ALWAYS,"","$ME changing logfiles " . ("-" x 31));
	}

	rollmgr_log(LOG_ALWAYS,"","$ME parameters:");
	rollmgr_log(LOG_ALWAYS,"","		rollrec file	\"$rollrecfile\"");
	rollmgr_log(LOG_ALWAYS,"","		logfile		\"$logfile\"");
	rollmgr_log(LOG_ALWAYS,"","		loglevel	\"$loglevel\"");
	rollmgr_log(LOG_ALWAYS,"","		sleeptime	\"$sleeptime\"");
	rollmgr_log(LOG_ALWAYS,""," ");
}

#-----------------------------------------------------------------------------
# Routine:	rrfchk()
#
# Purpose:	This routine performs initial checking of the rollrec file.
#		It checks each roll rollrec to ensure its zonefile and keyrec
#		file exist.  If one or both don't exist, the rollrec's type
#		will be changed into a skip rollrec.  This prevents lots of
#		unnecessary repeated log messages of an invalid rollrec.
#
sub rrfchk
{
	my $rrf	 = shift;				# Rollrec file.
	my $modified = 0;				# Modified flag.

	#
	# Return failure if the rollrec file is bad.
	# 
	if(!rrfokay($rrf,""))
	{
		return(0);
	}

	#
	# Get the current contents of the rollrec file.
	#
	rollrec_lock();
	rollrec_read($rollrecfile);

	#
	# For each roll rollrec, check if its zonefile and keyrec file exist.
	# If not, we'll change it to being a skip rollrec.
	#
	foreach my $rname (rollrec_names())
	{
		my $rrr;		# Reference to rollrec.
		my %rr;			# Rollrec hash.
		my $phase;		# Rollrec's phase.

		my $errs = 0;		# Missing file errors.
		my $zonefile;		# Zone's filename.
		my $keyrec;		# Keyrec's filename.

		#
		# Get the rollrec for this name.  If it doesn't have one,
		# whinge and continue to the next.
		#
		$rrr = rollrec_fullrec($rname);
		if(!defined($rrr))
		{
			rollmgr_log(LOG_ERR,$rname,"no rollrec defined for zone");
			next;
		}
		%rr = %$rrr;

		#
		# Don't look at skip records.
		#
		next if($rr{'rollrec_type'} eq "skip");

		#
		# Get our important files.
		#
		$zonefile = $rr{'zonefile'};
		$keyrec	  = $rr{'keyrec'};

		#
		# Set the error flag if either the zonefile or the keyrec
		# file don't exist.
		#
		if(! -e $zonefile)
		{
			rollmgr_log(LOG_ERR,$rname,"zonefile \"$zonefile\" does not exist");
			$errs++;
		}
		if(! -e $keyrec)
		{
			rollmgr_log(LOG_ERR,$rname,"keyrec \"$keyrec\" does not exist");
			$errs++;
		}

		#
		# Skip this record if the zonefile and keyrec file exist.
		#
		next if(!$errs);

		#
		# If one of the files doesn't exist, then change the rollrec
		# to a skip record.  There's no reason we should bang our
		# head against non-existent files.
		#
		rollmgr_log(LOG_ERR,$rname,"changing roll record to a skip record");
		rollrec_rectype($rname,"skip");
		$modified++;

	}

	#
	# Save the current rollrec file state.
	#
	rollrec_close();
	rollrec_unlock();

	#
	# Return success.
	# 
	return(1);
}

#-----------------------------------------------------------------------------
# Routine:	rrfokay()
#
# Purpose:	This routine checks to see if a rollrec file is okay.
#
#		Returns:
#			0 - file is in error
#			1 - file is okay
#
sub rrfokay
{
	my $rrf = shift;				# Rollrec file to check.
	my $mp  = shift;				# Message prefix.

	if(! -e $rrf)
	{
		rollmgr_log(LOG_ERR,$mp,"rollrec file \"$rrf\" does not exist");
		return(0);
	}
	elsif(-z $rrf)
	{
		rollmgr_log(LOG_ERR,$mp,"rollrec file \"$rrf\" is zero length");
		return(0);
	}
	return(1);
}

#-----------------------------------------------------------------------------
# Routine:	sleeper()
#
# Purpose:	Sleep for a specific amount of time.  This will take into
#		account interrupts we've taken from rollctl.
#
sub sleeper
{
	my $nap;				# Time left to sleep.

	rollmgr_log(LOG_TMI,"","sleeping for $sleeptime seconds");

	$sleepcnt = 0;

	while($sleepcnt < $sleeptime)
	{
		$nap = $sleeptime - $sleepcnt;

		$sleepcnt += sleep($nap);
	}
}

#-----------------------------------------------------------------------------
# Routine:	commander()
#
# Purpose:	Get any commands sent to rollerd's command socket.
#
sub commander
{
	my $cmd;					# Client's command.
	my $data;					# Command's data.

	rollmgr_log(LOG_TMI,"<command>","checking commands");

	#
	# Read and handle all the commands we've been sent.
	#
	while(42)
	{
		#
		# Get the command, return if there wasn't one.
		#
		($cmd,$data) = rollmgr_getcmd(5);
		return if(!defined($cmd));

		rollmgr_log(LOG_TMI,"<command>","cmd   - \"$cmd\"");
		rollmgr_log(LOG_TMI,"<command>","data  - \"$data\"") if($data ne "");

		if($cmd eq ROLLCMD_DISPLAY())
		{
			cmd_display($data);
		}
		elsif($cmd eq ROLLCMD_LOGFILE())
		{
			cmd_logfile($data);
		}
		elsif($cmd eq ROLLCMD_LOGLEVEL())
		{
			cmd_loglevel($data);
		}
		elsif($cmd eq ROLLCMD_LOGMSG())
		{
			cmd_logmsg($data);
		}
		elsif($cmd eq ROLLCMD_ROLLALL())
		{
			cmd_rollall();
		}
		elsif($cmd eq ROLLCMD_ROLLREC())
		{
			if(cmd_rollrec($data))
			{
				last;
			}
		}
		elsif($cmd eq ROLLCMD_ROLLZONE())
		{
			cmd_rollzone($data);
		}
		elsif($cmd eq ROLLCMD_RUNQUEUE())
		{
			cmd_runqueue($data);
		}
		elsif($cmd eq ROLLCMD_SHUTDOWN())
		{
			cmd_shutdown($data);
		}
		elsif($cmd eq ROLLCMD_SKIPALL())
		{
			cmd_skipall();
		}
		elsif($cmd eq ROLLCMD_SKIPZONE())
		{
			cmd_skipzone($data);
		}
		elsif($cmd eq ROLLCMD_SLEEPTIME())
		{
			cmd_sleeptime($data);
		}
		elsif($cmd eq ROLLCMD_STATUS())
		{
			cmd_status($data);
		}
		elsif($cmd eq ROLLCMD_ZONESTATUS())
		{
			cmd_zonestatus($data);
		}
		else
		{
			rollmgr_log(LOG_ERR,"<command>","invalid command  - \"$cmd\"");
		}

		rollmgr_closechan();
	}

}

#-----------------------------------------------------------------------------
# Routine:	cmd_display()
#
# Purpose:	Set the logfile to the user's specified file.  Nothing is done
#		if the user requests the same log file as is currently in use.
#
sub cmd_display
{
	my $onflag = shift;				# Display-on flag.

	rollmgr_log(LOG_TMI,"<command>","display command received; status flag - \"$onflag\"");

	#
	# Do nothing if the we're already doing what the user wants.
	#
	if($display == $onflag)
	{
		if($display == 1)
		{
			rollmgr_log(LOG_INFO,"<command>","graphical display is already on");
		}
		else
		{
			rollmgr_log(LOG_INFO,"<command>","graphical display is already off");
		}
		rollmgr_sendresp(ROLLCMD_RC_DISPLAY,"display status already as requested");
		return;
	}

	#
	# Change the logfile and give an appropriate set of log messages.
	#
	if($onflag)
	{
		displayer(1);
		rollmgr_log(LOG_INFO,"<command>","rollerd display started");
		rollmgr_sendresp(ROLLCMD_RC_OKAY,"rollerd display started");
	}
	else
	{
		displayer(0);
		rollmgr_log(LOG_INFO,"<command>","rollerd display stopped");
		rollmgr_sendresp(ROLLCMD_RC_OKAY,"rollerd display stopped");
	}
}

#-----------------------------------------------------------------------------
# Routine:	cmd_logfile()
#
# Purpose:	Set the logfile to the user's specified file.  Nothing is done
#		if the user requests the same log file as is currently in use.
#
sub cmd_logfile
{
	my $newlog = shift;				# New log file.
	my $oldlog;					# Old log file.

	rollmgr_log(LOG_TMI,"<command>","logfile command received; new log file - \"$newlog\"");

	#
	# Do nothing if the new logfile is the same as the current logfile.
	#
	$oldlog = rollmgr_logfile();
	if($oldlog eq $newlog)
	{
		rollmgr_log(LOG_INFO,"<command>","new logfile ($newlog) same as the old logfile");
		return;
	}

	#
	# Change the logfile and give an appropriate set of log messages.
	#
	rollmgr_log(LOG_INFO,"<command>","logfile changed from $oldlog to $newlog");
	rollmgr_log(LOG_INFO,"<command>","closing logfile $oldlog");
	$oldlog = rollmgr_logfile($newlog,0);
	if($oldlog ne "")
	{
		rollmgr_log(LOG_INFO,"<command>","logfile changed from $oldlog to $newlog");
		bootmsg(0);
		rollmgr_sendresp(ROLLCMD_RC_OKAY,"logfile changed to \"$newlog\"");
	}
	else
	{
		rollmgr_log(LOG_ERR,"<command>","unable to change logfile to $newlog");
		rollmgr_sendresp(ROLLCMD_RC_BADFILE,"unable to change logfile to \"$newlog\"");
	}
}

#-----------------------------------------------------------------------------
# Routine:	cmd_loglevel()
#
# Purpose:	Set the logging level to the user's specified level.
#
sub cmd_loglevel
{
	my $newlvl = shift;				# New level.
	my $oldlvl;					# Old level.

	my $oldstr;					# Old level's string.
	my $newstr;					# New level's string.

	$newstr = rollmgr_logstr($newlvl);
	rollmgr_log(LOG_TMI,"<command>","loglevel command received; new logging level - \"$newstr\"");

	$oldlvl = rollmgr_loglevel($newlvl,0);
	if($oldlvl >= 0)
	{
		$oldstr = rollmgr_logstr($oldlvl);

		rollmgr_log(LOG_INFO,"<command>","loglevel changed from $oldstr to $newstr");
		rollmgr_sendresp(ROLLCMD_RC_OKAY,"loglevel changed from \"$oldstr\" to \"$newstr\"");
	}
	else
	{
		rollmgr_log(LOG_ERR,"<command>","unable to change loglevel to $newlvl");
		rollmgr_sendresp(ROLLCMD_RC_BADLEVEL,"invalid loglevel \"$newlvl\"");
	}
}

#-----------------------------------------------------------------------------
# Routine:	cmd_logmsg()
#
# Purpose:	Write a log message to the log file.
#
#		The way we check for a valid log level is only good in a
#		single-threaded environment.
#
sub cmd_logmsg
{
	my $logstr = shift;			# Log level and message.

	my $loglvl;				# Logging level.
	my $logmsg;				# Log message.

	my $oldlvl;				# Real logging level.
	my $goodlvl;				# Real version of new level.

	rollmgr_log(LOG_TMI,"<command>","logmsg command received");

	#
	# Dig the log level and message out of our argument.
	#
	$logstr =~ /^\((\-\w+)\)(.*)$/;
	$loglvl = $1;
	$logmsg = $2;

	#
	# Check the validity of the caller's log level.  If it's invalid,
	# rollmgr_loglevel() will return a failure and we'll return.
	#
	$oldlvl = rollmgr_loglevel($loglvl,0);
	if($oldlvl < 0)
	{
		rollmgr_log(LOG_INFO,"<command>","invalid loglevel ($loglvl) specified for logmsg command");
		rollmgr_sendresp(ROLLCMD_RC_BADLEVEL,"invalid loglevel \"$loglvl\"");
		return;
	}

	#
	# Reset the logging level and write the caller's message.
	#
	$goodlvl = rollmgr_loglevel($oldlvl,0);
	rollmgr_log($goodlvl,"<user msg>",$logmsg);
	rollmgr_sendresp(ROLLCMD_RC_OKAY,"message written to log");
}

#-----------------------------------------------------------------------------
# Routine:	cmd_rollall()
#
# Purpose:	This command moves all the zones in the rollrec file into
#		immediate rollover.  rollnow() is called for each zone, in
#		order to start rollover.  We'll also keep track of the
#		zones we were and weren't able to put in rollover, and
#		report them to the caller.
#
sub cmd_rollall
{
	my $good = "";					# Rolled zones.
	my $bad	 = "";					# Unrolled zones.

	my $cnt	 = 0;					# Total count.
	my $gcnt = 0;					# Rolled count.
	my $bcnt = 0;					# Unrolled count.

	rollmgr_log(LOG_TMI,"<command>","rollall command received");

	#
	# Each zone in the rollrec file will be put in the rollover process,
	# starting after that initial wait period.  We'll keep track of the
	# zones that were rolled and those that weren't in order to provide
	# an appropriate response message.
	#
	foreach my $zone (rollrec_names())
	{
		$cnt++;

		#
		# If the rollover worked, increment the good count and add
		# the domain name to the list of good zones.  If it didn't
		# work, do the same for the bad count and bad-zone list.
		#
		if(rollnow($zone) == 1)
		{
			$gcnt++;
			$good .= "$zone ";
		}
		else
		{
			$bcnt++;
			$bad .= "$zone ";
		}
	}

	#
	# We don't need no steenkin' trailing whitespace.
	#
	chomp $good;
	chomp $bad;

	#
	# Send a response message to the caller.
	#
	if($gcnt == $cnt)
	{
		rollmgr_sendresp(ROLLCMD_RC_OKAY,$good);
	}
	else
	{
		my $resp;				# Response message.

		$resp = "zones not in rollrec file $rollrecfile:  $bad\n";

		#
		# If there were any zones that were put into rollover,
		# we'll add them to the message as well.
		#
		if($gcnt > 0)
		{
			$resp .= "zones now in rollover:  $good\n";
		}

		rollmgr_sendresp(ROLLCMD_RC_BADZONE,$resp);
	}
}

#-----------------------------------------------------------------------------
# Routine:	cmd_rollrec()
#
# Purpose:	This routine changes the rollrec file being used by rollerd.
#		If this command is successful, then the communications channel
#		will be closed.
#
sub cmd_rollrec
{
	my $rrf = shift;				# New rollrec file.

	rollmgr_log(LOG_TMI,"<command>","rollrec command received; rollrec file - \"$rrf\"");

	if(rrfokay($rrf,"<command>"))
	{
		rollmgr_log(LOG_INFO,"<command>","------------------------------------------------");
		rollmgr_log(LOG_INFO,"<command>","setting rollrec file from \"$rollrecfile\" to \"$rrf\"");
		$rollrecfile = $rrf;

		rollmgr_sendresp(ROLLCMD_RC_OKAY,"rollerd now using rollrec file $rrf");
		display("rollrec $rrf 0");

		#
		# Close the channel and return success.
		#
		rollmgr_closechan();
		return(1);
	}

	rollmgr_log(LOG_ERR,"<command>","invalid rollrec file \"$rrf\"");
	rollmgr_sendresp(ROLLCMD_RC_BADROLLREC,"invalid rollrec file \"$rrf\"");
	return(0);
}

#-----------------------------------------------------------------------------
# Routine:	cmd_rollzone()
#
# Purpose:	This command moves a zone into immediate rollover.  It
#		calls rollnow() to move the zone into immediate rollover.
#
sub cmd_rollzone
{
	my $zone = shift;				# Command's data.

	rollmgr_log(LOG_TMI,"<command>","rollzone command received; zone - \"$zone\"");

	if(rollnow($zone) == 1)
	{
		rollmgr_sendresp(ROLLCMD_RC_OKAY,"$zone rollover started");
	}
	else
	{
		rollmgr_sendresp(ROLLCMD_RC_BADZONE,"$zone not in rollrec file $rollrecfile");
	}
}

#-----------------------------------------------------------------------------
# Routine:	cmd_runqueue()
#
# Purpose:	This command forces rollerd to run its queue.  It does this
#		by setting the elapsed-sleep-time equal to the time-to-sleep.
#		Upon return, sleeper() will see that sleepers must awake, 
#		and rollerd will go run its rollrec queue.
#
sub cmd_runqueue
{
	rollmgr_log(LOG_TMI,"<command>","runqueue command received");

	rollmgr_log(LOG_INFO,"<command>","checking rollrec queue");
	rollmgr_sendresp(ROLLCMD_RC_OKAY,"rollerd checking rollrec queue");
	$sleepcnt = $sleeptime;
}

#-----------------------------------------------------------------------------
# Routine:	cmd_shutdown()
#
# Purpose:	This command forces rollerd to shut down.
#
sub cmd_shutdown
{
	rollmgr_log(LOG_TMI,"<command>","shutdown command received");
	rollmgr_sendresp(ROLLCMD_RC_OKAY,"rollerd shutting down");

	halt_handler();
}

#-----------------------------------------------------------------------------
# Routine:	cmd_skipall()
#
# Purpose:	This command stops rollover for all the zones in the rollrec
#		file.  The zones' rollrec records are marked as being "skip"
#		records, which will cause rollerd to ignore them.  This change
#		is reflected in the rollrec file.  skipnow() is called for each
#		zone, in order to stop rollover.  We'll also keep track of the
#		zones we were and weren't able to stop and report them to the
#		caller.
#
sub cmd_skipall
{
	my $good = "";					# Skipped zones.
	my $bad	 = "";					# Unskipped zones.

	my $cnt	 = 0;					# Total count.
	my $gcnt = 0;					# Skipped count.
	my $bcnt = 0;					# Unskipped count.

	rollmgr_log(LOG_TMI,"<command>","skipall command received");

	#
	# Each zone in the rollrec file will be removed from the rollover
	# process.  We'll keep track of the zones that were skipped and those
	# that weren't in order to provide an appropriate response message.
	#
	foreach my $zone (rollrec_names())
	{
		$cnt++;

		#
		# If the skip worked, increment the good count and add
		# the domain name to the list of good zones.  If it didn't
		# work, do the same for the bad count and bad-zone list.
		#
		if(skipnow($zone) == 1)
		{
			$gcnt++;
			$good .= "$zone ";
		}
		else
		{
			$bcnt++;
			$bad .= "$zone ";
		}
	}

	#
	# We still don't need no steenkin' trailing whitespace.
	#
	chomp $good;
	chomp $bad;

	#
	# Send a response message to the caller.
	#
	if($gcnt == $cnt)
	{
		rollmgr_sendresp(ROLLCMD_RC_OKAY,$good);
	}
	else
	{
		my $resp;				# Response message.

		$resp = "zones not in rollrec file $rollrecfile:  $bad\n";

		#
		# If there were any zones that were removed from rollover,
		# we'll add them to the message as well.
		#
		if($gcnt > 0)
		{
			$resp .= "zones now skipped:  $good\n";
		}

		rollmgr_sendresp(ROLLCMD_RC_BADZONE,$resp);
	}
}

#-----------------------------------------------------------------------------
# Routine:	cmd_skipzone()
#
# Purpose:	This command removes a zone from rollover processing. 
#
sub cmd_skipzone
{
	my $zone = shift;				# Command's data.

	rollmgr_log(LOG_TMI,"<command>","skipzone command received; zone - \"$zone\"");

	if(skipnow($zone) == 1)
	{
		rollmgr_sendresp(ROLLCMD_RC_OKAY,"$zone rollover stopped");
	}
	else
	{
		rollmgr_sendresp(ROLLCMD_RC_BADZONE,"$zone not in rollrec file $rollrecfile");
	}
}

#-----------------------------------------------------------------------------
# Routine:	cmd_sleeptime()
#
# Purpose:	This command sets rollerd's time-to-sleep to the user's
#		specified value.  This must be above a "constant" minimum
#		sleep time in order to prevent malicious users from making
#		rollerd continually run its queue without any resting.
#
#		It might be good to also enforce a maximum sleep time.
#
sub cmd_sleeptime
{
	my $newnap = shift;				# New sleep time.

	rollmgr_log(LOG_TMI,"<command>","sleeptime command received; new sleep time - \"$newnap\"");

	if($newnap < $MIN_SLEEP)
	{
		rollmgr_log(LOG_ERR,"<command>","sleep-time must be >= $MIN_SLEEP");
		rollmgr_sendresp(ROLLCMD_RC_BADSLEEP,"invalid sleep-time \"$newnap\"");
	}
	else
	{
		rollmgr_log(LOG_INFO,"<command>","setting sleep-time to $newnap");
		$sleeptime = $newnap;
		$sleepcnt  = $newnap;

		rollmgr_sendresp(ROLLCMD_RC_OKAY,"sleep-time set to $newnap");
		display("sleeptime all $sleeptime");
	}
}

#-----------------------------------------------------------------------------
# Routine:	cmd_status()
#
# Purpose:	Write some rollerd settings to the log.
#
sub cmd_status
{
	my $data = shift;				# Command's data.

	my $curdir;					# Directory.
	my $lfile;					# Log file.
	my $lvl;					# Logging level.
	my $lvlstr;					# Logging level string.
	my $outbuf = "";				# Response buffer.

	#
	# Get the info to report.
	#
	$curdir = getcwd();
	$lfile	= rollmgr_logfile();
	$lvl	= rollmgr_loglevel();
	$lvlstr	= rollmgr_logstr($lvl);

	#
	# Build status report.
	#
	$outbuf  = "boot-time:          $boottime\n";
	$outbuf .= "directory:          $curdir\n";
	$outbuf .= "rollrec file:       $rollrecfile\n";
	$outbuf .= "logfile:            $lfile\n";
	$outbuf .= "loglevel:           $lvl\n";
	$outbuf .= "sleeptime:          $sleeptime\n";
#	$outbuf .= "elapsed sleeptime:  $sleepcnt\n";


	rollmgr_log(LOG_TMI,"<command>","status command received");

	rollmgr_log(LOG_ALWAYS,"<command>","rollerd status:");
	rollmgr_log(LOG_ALWAYS,"<command>","\tboot time         - $boottime");
	rollmgr_log(LOG_ALWAYS,"<command>","\tdirectory         - $curdir");
	rollmgr_log(LOG_ALWAYS,"<command>","\trollrec file      - $rollrecfile");
	rollmgr_log(LOG_ALWAYS,"<command>","\tlogfile           - $lfile");
	rollmgr_log(LOG_ALWAYS,"<command>","\tloglevel          - $lvlstr");

	rollmgr_log(LOG_ALWAYS,"<command>","\tsleeptime         - $sleeptime");
#	rollmgr_log(LOG_ALWAYS,"<command>","\telapsed sleeptime - $sleepcnt");

	rollmgr_sendresp(ROLLCMD_RC_OKAY,$outbuf);
}

#-----------------------------------------------------------------------------
# Routine:	cmd_zonestatus()
#
# Purpose:	Return zone status to the control program.
#
sub cmd_zonestatus
{
	my $data = shift;				# Command's data.

	my $cnt = 0;					# Zone count.
	my $outbuf = "";				# Zone status line.

	rollmgr_log(LOG_TMI,"<command>","zonestatus command received");

	rollrec_lock();

	#
	# Read the rollrec file.  If we couldn't, complain and return.
	#
	if(rollrec_read($rollrecfile) <= 0)
	{
		rollrec_unlock();
		rollmgr_sendresp(ROLLCMD_RC_RRFOPEN,"unable to open rollrec file $rollrecfile");
		rollmgr_log(LOG_ALWAYS,"<command>","unable to open rollrec file $rollrecfile\n");
		return;
	}

	rollmgr_log(LOG_ALWAYS,"<command>","zone status:");

	#
	# Add the status of each zone in the rollrec file to our output buffer.
	#
	foreach my $rname (rollrec_names())
	{
		my $rrr;		# Reference to rollrec.
		my %rr;			# Rollrec hash.

		my $phase;		# Rollrec's phase.
		my $rtype;		# Rollrec's record type.

		#
		# Get the rollrec for this name.
		#
		$rrr = rollrec_fullrec($rname);
		next if(!defined($rrr));
		%rr = %$rrr;

		#
		# Get the data we're interested in.
		#
		$phase = $rr{'curphase'};
		$rtype = $rr{'rollrec_type'};

		#
		# Add the data to the output buffer and bump our zone count.
		#
		$outbuf .= "$rname\t$rtype\t$phase\n";
		rollmgr_log(LOG_ALWAYS,"<command>","\t$rname\t$rtype\t$phase\n");
		$cnt++;
	}

	#
	# Send a response to the control program.
	#
	if($cnt == 0)
	{
		rollmgr_sendresp(ROLLCMD_RC_NOZONES,"no zones defined in $rollrecfile");
		rollmgr_log(LOG_ALWAYS,"<command>","no zones defined in $rollrecfile\n");
	}
	else
	{
		rollmgr_sendresp(ROLLCMD_RC_OKAY,$outbuf);
	}

	rollrec_unlock();
}

#-----------------------------------------------------------------------------
# Routine:	rollnow()
#
# Purpose:	This command moves a zone into immediate rollover.  It
#		doesn't sit in the initial waiting period, but starts
#		right off into rollover phase 2.
#
sub rollnow
{
	my $zone = shift;				# Command's data.
	my $rrr;					# Reference to rollrec.
	my %rr;						# Rollrec hash.

	#
	# Get the rollrec for the zone.
	#
	$rrr = rollrec_fullrec($zone);
	if(!defined($rrr))
	{
		rollmgr_log(LOG_ERR,<command>,"no rollrec defined for zone $zone");
		return(0);
	}
	%rr = %$rrr;

	#
	# A skip record is changed to a regular rollrec.
	#
	if($rr{'rollrec_type'} eq "skip")
	{
		rollmgr_log(LOG_INFO,"<command>","$zone skip rollrec changed to a roll rollrec");
		rollrec_rectype($zone,"roll");
		$rrr = rollrec_fullrec($zone);
	}

	#
	# Change the zone's phase to rollover phase 2.  This bypasses the
	# initial rollover waiting period and gets right to the nitty gritty
	# of doing a rollover.
	#
	newphase($zone,$rrr,2);

	#
	# Setting the sleep values such that the queue will be run.
	#
	$sleepcnt = $sleeptime;
	rollmgr_log(LOG_INFO,"<command>","forcing a rollover for zone $zone");
	display("startroll $zone 0");
	return(1);
}

#-----------------------------------------------------------------------------
# Routine:	skipnow()
#
# Purpose:	This command prevents a zone from rolling over.  It is marked
#		as a skip record in the rollrec file.
#
sub skipnow
{
	my $zone = shift;				# Command's data.
	my $rrr;					# Reference to rollrec.
	my %rr;						# Rollrec hash.

	#
	# Get the rollrec for the zone.
	#
	$rrr = rollrec_fullrec($zone);
	if(!defined($rrr))
	{
		rollmgr_log(LOG_ERR,<command>,"no rollrec defined for zone $zone");
		return(0);
	}
	%rr = %$rrr;

	#
	# A roll record is changed to a skip rollrec and its phase set to 0.
	#
	if($rr{'rollrec_type'} eq "roll")
	{
		rollmgr_log(LOG_INFO,"<command>","$zone roll rollrec changed to a skip rollrec");

		rollrec_setval($zone,"curphase",0);
		rollrec_rectype($zone,"skip");
		rollrec_write();
		display("stoproll $zone 0");
	}
	else
	{
		rollmgr_log(LOG_INFO,"<command>","zone $zone already a skip rollrec");
	}
	return(1);
}

#-----------------------------------------------------------------------------
# Routine:	controllers()
#
# Purpose:	Initialize handlers for our externally provided commands.
#
sub controllers
{
	my $onflag = shift;				# Handler on/off flag.

	#
	# Set the signal handlers that will manage incoming commands.
	#
	if($onflag)
	{
		$SIG{'HUP'} = \&intcmd_handler;
		$SIG{'INT'} = \&halt_handler;
	}
	else
	{
		$SIG{'HUP'} = 'IGNORE';
		$SIG{'INT'} = 'IGNORE';
	}
}

#-----------------------------------------------------------------------------
# Routine:	intcmd_handler()
#
# Purpose:	Handle an interrupt and get a command.
#
sub intcmd_handler
{
	rollmgr_log(LOG_ALWAYS,"<command>","rollover manager:  got a command interrupt\n");

	controllers(0);
	commander();
	controllers(1);
}

#-----------------------------------------------------------------------------
# Routine:	halt_handler()
#
# Purpose:	Handle the "halt" command.
#
sub halt_handler
{
	display("halt woof 0");

	rollmgr_log(LOG_ALWAYS,"","rollover manager shutting down...\n");
	rollmgr_rmid();
	exit(0);
}

#-----------------------------------------------------------------------------
# Routine:	cleanup()
#
# Purpose:	Perform whatever clean-up is required.
#
sub cleanup
{
	rollmgr_log(LOG_ALWAYS,"cleaning up...") if($loglevel == LOG_TMI);
	rollmgr_rmid();
	exit(0);
}

#-----------------------------------------------------------------------------
# Routine:	displayer()
#
# Purpose:	Turn on/off the graphical display, depending on the display
#		flag.
#
sub displayer
{
	#
	# Set the global display flag to an argument -- iff we got one.
	#
	if(@_ == 1)
	{
		$display = shift;
	}

	#
	# Turn on or off the graphical display, depending on the display flag.
	#
	if($display)
	{
		open(DISPLAY, "|blinkenlights $rollrecfile");
	}
	else
	{
		display("halt");
		close(DISPLAY);
	}
}

#-----------------------------------------------------------------------------
# Routine:	display()
#
# Purpose:	Send a message to the display program iff the display flag
#		is on.  If we couldn't send the message, then we'll turn
#		the flag off.
#
sub display
{
	my $dmsg = shift;				# Message to send.
	my $savedsel;					# Saved descriptor.
	my $ret;					# Retcode from print.

	return if(!$display);

	#
	# Force this message to be unbuffered.
	#
	$savedsel = select(DISPLAY);
	$| = 1;
	$ret = print DISPLAY "$dmsg\n";
	select($savedsel);

	if(!$ret)
	{
		rollmgr_log(LOG_INFO,"<command>","unable to send message to blinkenlights; turning off display");
		$display = 0;
	}
}

#----------------------------------------------------------------------
# Routine:	version()
#
# Purpose:	Print the version number(s) and exit.
#
sub version
{
	print STDERR "$VERS\n";
	print STDERR "$DTVERS\n";

	exit(1);
}

#-----------------------------------------------------------------------------
# Routine:	usage()
#
# Purpose:	Print a usage message and exit.
#
sub usage
{
	print STDERR "usage:  rollerd [options] <zone>\n";
	print STDERR "\toptions:\n";
	print STDERR "\t\t-directory <dir>\n";
	print STDERR "\t\t-logfile <logfile>\n";
	print STDERR "\t\t-loglevel <level>\n";
	print STDERR "\t\t-sleep <sleeptime>\n";
	print STDERR "\t\t-display\n";
	print STDERR "\t\t-verbose\n";
	print STDERR "\t\t-Version\n";
	print STDERR "\t\t-help\n";
	exit(0);
}

1;

##############################################################################
#

=pod

=head1 NAME

rollerd - DNSSEC-Tools daemon to manage DNSSEC key rollover.

=head1 SYNOPSIS

  rollerd [-options] -rrfile <rollrec_file>

=head1 DESCRIPTION

The B<rollerd> daemon manages key rollover for zones.  The Pre-Publish Method
of key rollover is used for ZSK key rollovers.  (Currently, B<rollerd> only
handles ZSK rollover.) This method has four phases that are entered when it
is time to perform the ZSK rollover:

    1. wait for old zone data to expire from caches
    2. sign the zone with the KSK and Published ZSK
    3. wait for old zone data to expire from caches
    4. adjust keys in keyrec and sign the zone with new Current ZSK

The Pre-Publish Method of key rollover is defined in the Step-by-Step DNS
Security Operator Guidance Document.  See that document for more detailed
information.

The zones to be managed by B<rollerd> are defined in a I<rollrec> file.  Each
zone's entry contains data needed by B<rollerd> and some data useful to a user.
Below is a sample I<rollrec> entry:

	roll "example.com"
		zonefile        "example.com.signed"
		keyrec          "example.com.krf"
		curphase        "3"
		maxttl          "2400"
		phasestart      "Thu May  4 19:19:21 2006"

The first line gives the I<rollrec> entry's name.  The "roll" keyword
indicates that B<rollerd> should include the zone in its roll queue.  Using
"skip" in place of "roll" allows a zone to be stored in the I<rollrec> file,
but it will not be included in rollover processing.  The first three fields
tell B<rollerd> where to find example.com's signed zone file and I<keyrec>
file and the zone's current rollover phase.  The last two are for reference
by the user.  The I<maxttl> field is derived from the signed zone file.

If either of the I<zonefile> or I<keyrec> files do not exist, then a "roll"
I<rollrec> will be changed into a "skip" I<rollrec>.  That record will not be
processed.

=head2 A Note About Files and Filenames

There are a number of files and filenames used by B<rollerd> and
B<zonesigner>.  The user must be aware of the files used by these programs,
where the files are located, and where the programs are executed.

By default, B<rollerd> will change directory to the DNSSEC-Tools directory,
though this may be changed by the I<-directory> option.  Any programs started
by B<rollerd>, most importantly B<zonesigner>, will run in this same
directory.  If files and directories referenced by these programs are named
with relative paths, those paths must be relative to this directory.

The I<rollrec> entry name is used as a key to the I<rollrec> file and to the
zone's I<keyrec> file.  This entry does not have to be the name of the
entry's domain, but it is a very good idea to make it so.  Whatever is used
for this entry name, the same name B<must> be used for the zone I<keyrec> in
that zone's I<keyrec> file.

It is probably easiest to store I<rollrec> files, I<keyrec> files, zone
files, and key files in a single directory.

=head1 INITIALIZATION AND USAGE

The following steps must be taken to initialize and use B<rollerd>.  This
assumes that zone files have been created, and that BIND and DNSSEC-Tools
have been installed.

=over 4

=item 0. sign zones

The zones to be managed by B<rollerd> must be signed.  Use B<zonesigner> to
create the signed zone files and the I<keyrec> files needed by B<rollerd>.
The I<rollrec> file created in the next step B<must> use the I<keyrec> file
names and the signed zone file names created here.

=item 1. create I<rollrec> file

Before B<rollerd> may be used, a I<rollrec> file must first be created.
While this file may be built by hand, the B<rollinit> command was
written specifically to build the file.

=item 2. select operational parameters

A number of B<rollerd>'s operational parameters are taken from the
DNSSEC-Tools configuration file.  However, these may be overridden
by command-line options.  See the OPTIONS section below for more details.
If non-standard parameters are desired to always be used, the appropriate
fields in the DNSSEC-Tools configuration file may be modified to use these
values.

=item 3. install the rollover configuration

The complete rollover configuration -- B<rollerd>, I<rollrec> file,
DNSSEC-Tools configuration file values, zone files -- should be installed.  
The appropriate places for these locations are both installation-dependent
and operating system-dependent.

=item 4. test the rollover configuration

The complete rollover configuration should be tested.  

Edit the zone files so that their zones have short TTL values.  A minute TTL
should be sufficient.

Run the following command:

    rollerd -rrfile test.rollrec -logfile - -loglevel info -sleep 60

This command assumes the test I<rollrec> file is B<test.rollrec>.  It writes
a fair amount of log messages to the terminal, and checks its queue every 60
seconds.  Follow the messages to ensure that the appropriate actions, as
required by the Pre-Publish Method, are taking place.

=item 5. set B<rollerd> to start at boot

Once the configuration is found to work, B<rollerd> should be set to start
at system boot.  The actual operations required for this step are operating
system-dependent.

=item 6. reboot and verify

The system should be rebooted and the B<rollerd> logfile checked to ensure
that B<rollerd> is operating properly.

=back

=head1 OPTIONS

The following options are recognized:

=over 4

=item I<-rrfile rollrec_file>

Name of the I<rollrec> file to be processed.  This is the only required
"option".

=item I<-directory dir>

Sets the B<rollerd> execution directory.  This must be a valid directory.

=item I<-logfile log_file>

Sets the B<rollerd> log file to I<log_file>.
This must be a valid logging file, meaning that if I<logfile> already
exists, it must be a regular file.  The only exceptions to this are if
I<logfile> is B</dev/stdout> or B</dev/tty>.

=item I<-loglevel level>

Sets B<rollerd>'s logging level to I<level>.  The valid logging levels are
defined in B<rollmgr.pm(3)>.

=item I<-sleep sleeptime>

Sets B<rollerd>'s sleep time to I<sleeptime>.  The sleep time is the amount
of time B<rollerd> waits between processing its I<rollrec>-based queue.

=item I<-parameters>

Prints a set of B<rollerd> parameters and then exits.

=item I<-display>

Starts the B<blinkenlights> graphical display program to show the status of
zones managed by B<rollerd>.

=item -help

Display a usage message.

=item -verbose

Verbose output will be given.

=back

=head1 ASSUMPTIONS

B<rollerd> uses the B<rndc> command to communicate with the BIND
B<named> daemon.  Therefore, it assumes that appropriate measure have been
taken so that this communication is possible.

=head1 KNOWN PROBLEMS

The following problems (or potential problems) are known:

=over 4

=item -

Only deals with ZSK rollover.

=item -

Any process that can write to the rollover socket can send commands to
B<rollerd>.  This is probably not a Good Thing.

=item -

No testing with zone files and key files not in the process' directory.

=back

=head1 POSSIBLE ENHANCEMENTS

The following potential enhancements may be made:

=over 4

=item -

It'd be good to base B<rollerd>'s sleep time on when the next operation must
take place, rather than a simple seconds count.

=item -

It'd be nice to allow each I<rollrec> entry to specify its own logging
level.

=back

=head1 AUTHOR

Wayne Morrison, tewok@users.sourceforge.net

=head1 SEE ALSO

B<blinkenlights(8)>,
B<named(8)>,
B<rndc(8)>,
B<rollchk(8)>,
B<rollctl(8)>,
B<rollinit(8)>,
B<zonesigner(8)>

B<Net::DNS::SEC::Tools::conf.pm(3)>,
B<Net::DNS::SEC::Tools::defaults.pm(3)>,
B<Net::DNS::SEC::Tools::keyrec.pm(3)>,
B<Net::DNS::SEC::Tools::rollmgr.pm(3)>,
B<Net::DNS::SEC::Tools::rollrec.pm(3)>

=cut
