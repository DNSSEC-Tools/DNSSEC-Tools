#!/usr/bin/perl
#
# Copyright 2005-2007 SPARTA, Inc.  All rights reserved.  See the COPYING
# file distributed with this software for details
#
#
# lsroll
#
#	This script lists the rollrecs in a rollrec file.
#

use strict;

use Getopt::Long qw(:config no_ignore_case_always);

use Net::DNS::SEC::Tools::rollrec;
use Net::DNS::SEC::Tools::rollmgr;
use Net::DNS::SEC::Tools::tooloptions;

#
# Version information.
#
my $NAME   = "lsroll";
my $VERS   = "$NAME version: 1.0";
my $DTVERS = "DNSSEC-Tools Version: 1.1";

#######################################################################

#
# Data required for command line options.
#
my %options = ();			# Filled option array.
my @opts =
(
	# Records to select:
		"roll",			# "Active" rollrecs.
		"skip",			# Skipped rollrecs.

	# Data to display:
		"type",			# Record type.
		"zone",			# Zone files.
		"keyrec",		# Keyrec files.
		"kskphase",		# KSK rollover phases.
		"zskphase",		# ZSK rollover phases.
		"phases",		# KSK and ZSK rollover phases.
		"admin",		# Zone administrator's email.
		"loglevel",		# Zone administrator's email.
		"directory",		# Directory holding zone's files.
		"ttl",			# Maximum TTL.
		"display",		# Display flag.
		"phstart",		# Phase start.
		"lastksk",		# Timestamp of last KSK rollover.
		"lastzsk",		# Timestamp of last ZSK rollover.

	# Output format:
		"count",		# Only give count of matching keyrecs.
		"headers",		# Give a column header.
		"terse",		# Give terse output.
		"long",			# Give long output.
		"Version",		# Display the version number.

	"help",				# Give a usage message and exit.
);

#
# Flag values for the various options.  Variable/option connection should
# be obvious.
#
my $rollflag;
my $skipflag;

my $typeflag;
my $zoneflag;
my $keyrecflag;
my $kphaseflag;
my $zphaseflag;
my $phasesflag;
my $adminflag;
my $logflag;
my $ttlflag;
my $dirflag;
my $dispflag;
my $phstartflag;
my $lastkskflag;
my $lastzskflag;

my $cntflag;
my $headerflag;
my $terse;
my $long;
my $version = 0;			# Display the version number.

my $count   = 0;			# Record-match count.

#######################################################################

my $HEADER_RRN = "<<<header>>>";	# Name for column header "rollrec".

my @rrnames;				# List of rollrecs in the files.

my %rollrecs = ();			# Rollrecs from the rollrec files.

my %lengths  = ();			# Maximum lengths of each rollrec field.

my $prevkey;				# Previous rollrec key added to output.

my $ret;				# Return code from main().

$ret = main();
exit($ret);

#-----------------------------------------------------------------------------
# Routine:	main()
#
# Purpose:	Main controller routine for lsroll.
#
sub main()
{
	my $argc = @ARGV;		# Number of command line arguments.
	my $errors = 0;			# Total error count.

	#
	# Check our options.
	#
	doopts($argc);

	#
	# Read the keyrec files.
	#
	while($argc > 0)
	{
		getrollrecs($ARGV[0]);
		shift @ARGV;
		$argc = @ARGV;
	}

	#
	# Cook up the output:  build a header line and calculate the maximum
	# length of each field.
	#
	makeheader();
	maxlens();

	#
	# Display the data requested.
	#
	showrollrecs();

	#
	# If the matching-record count should be given, give the count in
	# requested format.
	#
	if($cntflag)
	{
		if($terse)
		{
			print "$count\n";
		}
		else
		{
			my $plural = "s";
			$plural = "" if($count == 1);

			print "$count matching record$plural\n";
		}
	}
	return(0);
}

#-----------------------------------------------------------------------------
# Routine:	doopts()
#
# Purpose:	This routine shakes and bakes our command line options.
#		A bunch of option variables are set according to the specified
#		options.  Then a little massaging is done to make sure that
#		the proper actions are taken.  A few options imply others, so
#		the implied options are set if the implying options are given.
#
sub doopts
{
	my $argc = shift;			# Command line argument count.

	#
	# Parse the options.
	#
	GetOptions(\%options,@opts);

	#
	# Set our option variables based on the parsed options.
	#
	$rollflag	= $options{'roll'}	|| 0;
	$skipflag	= $options{'skip'}	|| 0;

	$cntflag	= $options{'count'}	|| 0;
	$headerflag	= $options{'headers'}	|| 0;
	$terse		= $options{'terse'}	|| 0;
	$long		= $options{'long'}	|| 0;

	#
	# Show the version number if requested
	#
	version() if(defined($options{'Version'}));

	#
	# Give a usage flag if asked.
	#
	usage() if(defined($options{'help'}));

	#
	# Give a usage flag if asked.
	#
	if($rollflag && $skipflag)
	{
		print STDERR "please select only one of -roll and -skip\n";
		exit(0);
	}

	#
	# Ensure we were given a rollrec file to check.
	#
	$argc = @ARGV;
	usage() if($argc == 0);

	#############################################################
	#
	# WARNING:  Code order beyond this point is critical.  Do *NOT* modify
	#	    anything in the rest of this routine if you are an idiot.
	#

	#
	# Make sure conflicting options weren't given.
	#
	usage() if($long && $terse);

	#
	# Set the default flag values.
	#
	$typeflag	= 0;
	$zoneflag	= 1;
	$keyrecflag	= 1;
	$kphaseflag	= 1;
	$zphaseflag	= 1;
	$dirflag	= 0;
	$adminflag	= 0;
	$logflag	= 0;
	$ttlflag	= 0;
	$dispflag	= 0;
	$phstartflag	= 0;
	$lastkskflag	= 0;
	$lastzskflag	= 0;

	#
	# Set the output flags for -skip.
	#
	if($skipflag)
	{
		$typeflag	= 0;
		$zoneflag	= 1;
		$keyrecflag	= 1;
		$kphaseflag	= 0;
		$zphaseflag	= 0;
		$adminflag	= 0;
		$logflag	= 0;
		$ttlflag	= 0;
		$phstartflag	= 0;
		$lastkskflag	= 0;
		$lastzskflag	= 0;
	}

	#
	# Set the output flags for -long output.
	#
	if($long)
	{
		$typeflag	= 1;
		$zoneflag	= 1;
		$keyrecflag	= 1;
		$kphaseflag	= 1;
		$zphaseflag	= 1;
		$dirflag	= 1;
		$adminflag	= 1;
		$logflag	= 1;
		$ttlflag	= 1;
		$dispflag	= 1;
		$phstartflag	= 1;
		$lastkskflag	= 1;
		$lastzskflag	= 1;
	}
	elsif($terse)
	{
		$typeflag	= 0;
		$zoneflag	= 0;
		$keyrecflag	= 0;
		$kphaseflag	= 0;
		$zphaseflag	= 0;
		$dirflag	= 0;
		$adminflag	= 0;
		$logflag	= 0;
		$ttlflag	= 0;
		$dispflag	= 0;
		$phstartflag	= 0;
		$lastkskflag	= 0;
		$lastzskflag	= 0;
	}

	#
	# Now fold in the option values...
	#
	$typeflag	= 1 if($options{'type'});
	$zoneflag	= 1 if($options{'zone'});
	$keyrecflag	= 1 if($options{'keyrec'});
	$phasesflag	= 1 if($options{'phases'});
	$dirflag	= 1 if($options{'directory'});
	$adminflag	= 1 if($options{'admin'});
	$logflag	= 1 if($options{'loglevel'});
	$ttlflag	= 1 if($options{'ttl'});
	$dispflag	= 1 if($options{'display'});
	$phstartflag	= 1 if($options{'phstart'});
	$lastkskflag	= 1 if($options{'lastksk'});
	$lastzskflag	= 1 if($options{'lastzsk'});
	$kphaseflag	= 1 if($options{'kskphase'});
	$zphaseflag	= 1 if($options{'zskphase'});

	#
	# Adjust the phase-related flags to ensure that The Right Thing
	# is done.
	#
	if($options{'kskphase'} && !$options{'zskphase'})
	{
		$kphaseflag	= 1;
		$zphaseflag	= 0;
		$lastzskflag	= 0;
	}
	elsif($options{'zskphase'} && !$options{'kskphase'})
	{
		$kphaseflag	= 0;
		$zphaseflag	= 1;
		$lastkskflag	= 0;
	}

	if($phasesflag)
	{
		$kphaseflag = 0;
		$zphaseflag = 0;
	}
	if($kphaseflag && $zphaseflag)
	{
		$kphaseflag = 0;
		$zphaseflag = 0;
		$phasesflag = 1;
	}

}

#-----------------------------------------------------------------------------
# Routine:	getrollrecs()
#
# Purpose:	This routine reads the specified rollrec file and puts each
#		rollrec into the rollrec hash table.
#		A little data-massage also takes place:
#			- default admins are added to admin-less records
#			- add quotes around timestamps
#			- default loglevels are added to loglevel-less records
#			- loglevels are converted to text format
#			- roll-specific fields are zapped for skip rollrecs
#
sub getrollrecs
{
	my $rrfile = shift;			# Rollrec file.

	rollrec_lock();
	rollrec_read($rrfile);
	rollrec_unlock();

	#
	# Load the rollrecs from the rollrec file.
	#
	@rrnames = rollrec_names();
	foreach my $rn (sort(@rrnames))
	{
		my $rr;				# Reference to rollrec.
		my $type;			# Rollrec's type.

		#
		# Get a reference to the rollrec.
		#
		$rr = rollrec_fullrec($rn);

		#
		# If we're not displaying this type of record, don't
		# include it in the length calculate.
		#
		$type = $rr->{'rollrec_type'};
		if(($rollflag && ($type eq "skip"))	||
		   ($skipflag && ($type eq "roll")))
		{
			next;
		}

		#
		# Save the rollrec
		#
		$rollrecs{$rn} = $rr;
	}

	#
	# Transmogrify a few fields in the rollrec as needed.
	#
	foreach my $rn (sort(keys(%rollrecs)))
	{
		#
		# Add quotes to the timestamps and save the zonename.
		#
		$rollrecs{$rn}{'zonename'} = "$rn";
		$rollrecs{$rn}{'phasestart'} = "\"$rollrecs{$rn}{'phasestart'}\""; 
		$rollrecs{$rn}{'ksk_rolldate'} = "\"$rollrecs{$rn}{'ksk_rolldate'}\""; 
		$rollrecs{$rn}{'zsk_rolldate'} = "\"$rollrecs{$rn}{'zsk_rolldate'}\""; 

		#
		# If the rollrec has no administrator, give it the default.
		#
		if(!defined($rollrecs{$rn}{'administrator'}))
		{
			$rollrecs{$rn}{'administrator'} = "(defadmin)";
		}

		#
		# If the rollrec has no administrator, give it the default.
		#
		if(!defined($rollrecs{$rn}{'directory'}))
		{
			$rollrecs{$rn}{'directory'} = "(defdir)";
		}

		#
		# Convert the loglevel into its textual form.
		# If the rollrec has no loglevel, give it the default.
		# If the rollrec has an invalid loglevel, give it the error
		# default.
		#
		if(defined($rollrecs{$rn}{'loglevel'}))
		{
			my $lvl;			# Text logging level.

			$lvl = rollmgr_logstr($rollrecs{$rn}{'loglevel'});
			if($lvl eq "")
			{
				$rollrecs{$rn}{'loglevel'} = "(unknownlog)";
			}
			else
			{
				$rollrecs{$rn}{'loglevel'} = $lvl;
			}
		}
		else
		{
			$rollrecs{$rn}{'loglevel'} = "(deflog)";
		}

		#
		# If this is a skip rollrec, zap a few roll-specific fields.
		#
		if($rollrecs{$rn}{'rollrec_type'} eq "skip")
		{
			$rollrecs{$rn}{'kskphase'} = "-";
			$rollrecs{$rn}{'zskphase'} = "-";
			$rollrecs{$rn}{'phases'}   = "-/-";
			$rollrecs{$rn}{'phstart'}  = "---";
		}
		else
		{
			$rollrecs{$rn}{'phases'} = "$rollrecs{$rn}{'kskphase'}/$rollrecs{$rn}{'zskphase'}";
		}
	}

}

#----------------------------------------------------------------------
# Routine:	maxlens()
#
# Purpose:	Calculate the maximum length of each rollrec field.
#		After finding the longest length for each field, we'll
#		add a little buffer space.
#
sub maxlens
{
	#
	# Loop through the zone list and give data on the desired zones.
	#
	foreach my $rrname (sort(keys(%rollrecs)))
	{
		my $recref  = $rollrecs{$rrname};
		my %rollrec = %$recref;

		foreach my $key (sort(keys(%rollrec)))
		{
			if(length($rollrec{$key}) > $lengths{$key})
			{
				$lengths{$key} = length($rollrec{$key});
			}
		}
	}

	#
	# Build a dummy entry for the phases option.  This can be hardcoded
	# since a -phases will only ever give output of the "M/N" form.
	#
	$lengths{'phases'} = 3 if(!defined($lengths{'phases'}));

	#
	# Add a little buffer space between fields.
	#
	foreach my $key (sort(keys(%lengths)))
	{
		$lengths{$key} += 4;
	}
}

#----------------------------------------------------------------------
# Routine:	makeheader()
#
# Purpose:	Build a header line as a fake rollrec.
#
sub makeheader
{
	my %rr;				# New, fake rollrec.

	return if(!$headerflag);

	$rr{'rollrec_type'}	= 'Type';
	$rr{'administrator'}	= 'Administrator';
	$rr{'directory'}	= 'Directory';
	$rr{'display'}		= 'Display Flag';
	$rr{'keyrec'}		= 'Keyrec File';
	$rr{'ksk_rolldate'}	= 'Last KSK Rollover';
	$rr{'kskphase'}		= 'KSK Phase';
	$rr{'loglevel'}		= 'Log Level';
	$rr{'maxttl'}		= 'Max-TTL';
	$rr{'phasestart'}	= 'Phase Start';
	$rr{'phases'}		= 'KSK/ZSK';
	$rr{'zonefile'}		= 'Zonefile';
	$rr{'zonename'}		= 'Zone';
	$rr{'zsk_rolldate'}	= 'Last ZSK Rollover';
	$rr{'zskphase'}		= 'ZSK Phase';

	$rollrecs{$HEADER_RRN} = \%rr;
}

#-----------------------------------------------------------------------------
# Routine:	showrollrecs()
#
# Purpose:	This routine displays rollrec data.  There are three output
#		formats: default, long, terse.  There are also skip records.
#		See the pod for more info on the formats.
#
sub showrollrecs
{
	my $out;				# Output string.

	my $admin;				# Zone administrator's email.
	my $direct;				# Directory for zone's files.
	my $disp;				# blinkenlights display flag.
	my $keyrec;				# Keyrec file in rollrec.
	my $kskphase;				# Current KSK phase in rollrec.
	my $lastksk;				# Timestamp of last KSK roll.
	my $lastzsk;				# Timestamp of last ZSK roll.
	my $loglevel;				# Logging level.
	my $phases;				# Current KSK and ZSK phases.
	my $phstart;				# Phase start in rollrec.
	my $ttl;				# Maximum TTL in rollrec.
	my $type;				# Rollrec's type.
	my $zonefile;				# Zone file in rollrec.
	my $zonename;				# Zone name in rollrec.
	my $zskphase;				# Current ZSK phase in rollrec.

	#
	# Loop through the zone list and give data on the desired zones.
	#
	foreach my $rrn (sort(keys(%rollrecs)))
	{
		my $rrr = $rollrecs{$rrn};	# The zone's loaded rollrec ref.
		my %rr = %$rrr;			# The zone's loaded rollrec.

		#
		# Bump the matching-records count.
		#
		$count++ if($rrn ne $HEADER_RRN);

		#
		# Stay cloaked if only the count of matching records
		# should be given.
		#
		next if($cntflag);

		#
		# Set fields from the rollrec.  If this is a skip record,
		# we won't get the phases, ttl, or phase start.
		#
		$type = $rr{'rollrec_type'};
		$zonename = $rr{'zonename'};
		$zonefile = $rr{'zonefile'};
		$keyrec	  = $rr{'keyrec'};
		$kskphase = $rr{'kskphase'};
		$zskphase = $rr{'zskphase'};
		$phases	  = $rr{'phases'};
		$ttl	  = $rr{'maxttl'};
		$disp	  = $rr{'display'};
		$phstart  = $rr{'phasestart'};
		$lastksk  = $rr{'ksk_rolldate'};
		$lastzsk  = $rr{'zsk_rolldate'};
		$admin	  = $rr{'administrator'};
		$direct	  = $rr{'directory'};
		$loglevel = $rr{'loglevel'};

		#
		# Build the output string.
		#
		$prevkey = 'first-field';
		$out  = outfld($rrn,'zonename',$zonename,1);
		$out .= outfld($rrn,'rollrec_type',$type,$typeflag);
		$out .= outfld($rrn,'zonefile',$zonefile,$zoneflag);
		$out .= outfld($rrn,'keyrec',$keyrec,$keyrecflag);
		if($phasesflag)
		{
			$out .= outfld($rrn,'phases',$phases,1);
		}
		else
		{
			$out .= outfld($rrn,'kskphase',$kskphase,$kphaseflag);
			$out .= outfld($rrn,'zskphase',$zskphase,$zphaseflag);
		}
		$out .= outfld($rrn,'administrator',$admin,$adminflag);
		$out .= outfld($rrn,'directory',$direct,$dirflag);
		$out .= outfld($rrn,'loglevel',$loglevel,$logflag);
		$out .= outfld($rrn,'maxttl',$ttl,$ttlflag);
		$out .= outfld($rrn,'display',$disp,$dispflag);
		$out .= outfld($rrn,'phasestart',$phstart,$phstartflag);
		$out .= outfld($rrn,'ksk_rolldate',$lastksk,$lastkskflag);
		$out .= outfld($rrn,'zsk_rolldate',$lastzsk,$lastzskflag);

		#
		# Write the output.
		#
		print "$out\n";
	}
}

#----------------------------------------------------------------------
# Routine:	outfld()
#
# Purpose:	Build a field's piece of the output line.  It does the needed
#		spacing and determination of whether that fields should be
#		included in the line.
#
#		This routine only *builds* part of the output line.
#		It does not write it to output.
#
sub outfld
{
	my $zone = shift;				# Zone name.
	my $key  = shift;				# Hashkey.
	my $val	 = shift;				# Value to print.
	my $flag = shift;				# Output flag.

	my $ret;					# Return string.
	my $mlen;					# Maximum field length.
	my $vlen;					# Length of value.
	my $blen;					# Space buffer length.
	my $spaces;					# Spaces to add.

	#
	# Return if the given flag isn't set and -long wasn't given.
	#
	return('') if(!$long && !$flag);

	#
	# Figure out spacing for this line.
	#
	$mlen = $lengths{$prevkey};
	$vlen = length($rollrecs{$zone}{$prevkey});
	$blen = $mlen - $vlen;
	$spaces = ' ' x $blen if($blen > 0);

	#
	# Build the output line.
	#
	$ret = $spaces . $val;

	#
	# Save the hash key and return the output string to the caller.
	#
	$prevkey = $key;
	return($ret);
}

#----------------------------------------------------------------------
# Routine:	version()
#
# Purpose:	Print the version number(s) and exit.
#
sub version
{
	print STDERR "$VERS\n";
	print STDERR "$DTVERS\n";

	exit(1);
}


#-----------------------------------------------------------------------------
# Routine:	usage()
#
sub usage
{
	print STDERR "usage:  lsroll [options] <rollrec-file>\n";
	print STDERR "\trecord-selection options:\n";
	print STDERR "\t\t-roll		roll records\n";
	print STDERR "\t\t-skip		skip records\n";
	print STDERR "\tattribute-selection options:\n";
	print STDERR "\t\t-type\t	record type\n";
	print STDERR "\t\t-zone\t	zonefile\n";
	print STDERR "\t\t-keyrec\t	keyrec file\n";
	print STDERR "\t\t-kskphase	KSK rollover phase\n";
	print STDERR "\t\t-zskphase	ZSK rollover phase\n";
	print STDERR "\t\t-phases\t	KSK and ZSK rollover phases\n";
	print STDERR "\t\t-admin\t	zone adminstrator's email\n";
	print STDERR "\t\t-directory	directory of zone's files\n";
	print STDERR "\t\t-loglevel	rollover logging level\n";
	print STDERR "\t\t-ttl		zone TTL\n";
	print STDERR "\t\t-display	display flag\n";
	print STDERR "\t\t-phstart	start of rollover phase\n";
	print STDERR "\t\t-lastksk	time last KSK rollover ended\n";
	print STDERR "\t\t-lastzsk	time last ZSK rollover ended\n";
	print STDERR "\toutput-format options:\n";
	print STDERR "\t\t-count		only give count of matching keyrecs\n";
	print STDERR "\t\t-headers	give explanatory column headers\n";
	print STDERR "\t\t-terse\t	terse output\n";
	print STDERR "\t\t-long		long output\n";
	print STDERR "\t\t-Version	display version number\n";
	print STDERR "\t\t-help		help message \n";

	exit(1);
}

1;

##############################################################################
#

=pod

=head1 NAME

lsroll - List the I<rollrec>s in a DNSSEC-Tools I<rollrec> file.

=head1 SYNOPSIS

  lsroll [options] <rollrec-files>

=head1 DESCRIPTION

This script lists the contents of the specified I<rollrec> files.  All
I<rollrec> files are loaded before the output is displayed.  If any
I<rollrec>s have duplicated names, whether within one file or across
multiple files, the later I<rollrec> will be the one whose data are
displayed.

=head1 OUTPUT FORMATS

The output displayed for each zone in a I<rollrec> file depends on the
selected records, the selected attributes, and the selected output format.
Each option in these option groups is described in detail in the next section.
The three base output formats, along with the default I<-skip> format, are
described here.

The I<-terse> option indicates that a minimal amount of output is desired;
the I<-long> option indicates that a great deal of output is desired.  The
record-selection and attribute-selection options may be used in conjunction
with I<-terse> to display exactly the set of I<rollrec> fields needed.

The default output format is that used when neither I<-terse> nor <-long>
is given, and is a middle ground between terse and long output.

If the I<-skip> option is given, then the default output format is a little
more restricted than the normal default.  Some I<rollrec> fields don't make
sense in the context of a skip records, and so are given as "---".  These
fields are the KSK rollover phase, the ZSK rollover phase, the TTL value, and
the phase start.

The table below shows the fields displayed for each output format.

    rollrec field        default        terse        long       skip
    -------------        -------        -----        ----       ----
    rollrec name           yes           yes         yes        yes
    rollrec type           no            no          yes        no
    zone name              yes           no          yes        yes
    keyrec file            yes           no          yes        yes
    KSK phase              yes           no          yes        no
    ZSK phase              yes           no          yes        no
    administrator          no            no          yes        no
    directory              no            no          yes        no
    logging level          no            no          yes        no
    TTL value              no            no          yes        no
    display flag           no            no          yes        no
    phase start            no            no          yes        no
    last KSK rollover      no            no          yes        no
    last ZSK rollover      no            no          yes        no

=head1 OPTIONS

There are three types of options recognized by B<lsroll>:  record-selection
options, attribute-selection options, and output-format options.  Each type
is described in the subsections below.

=head2 Record-selection Options

These options select the records that will be displayed by B<lsroll>.
By default, all records will be displayed; selecting one or the other of
these options will restrict the records shown.

In order to simplify the B<lsroll> code and keep it easily understandable,
these options are mutually exclusive.

=over 4

=item I<-roll>

List all "roll" records in the I<rollrec> file.

=item I<-skip>

List all "skip" records in the I<rollrec> file.

=back

=head2 Attribute-selection Options

These options select the attributes of the records that will be displayed
by B<lsroll>.

=over 4

=item I<-type>

Include each I<rollrec> record's type in the output.  The type will be either
"roll" or "skip".

=item I<-zone>

The record's zonefile is included in the output.  This field is part
of the default output.

=item I<-keyrec>

The record's I<keyrec> file is included in the output.
This field is part of the default output.

=item I<-kskphase>

The record's KSK rollover phase are included in the output.
If this option is given with the I<-zskphase> option, then the output will
follow the format described for the I<-phases> option.
This field is part of the default output.

=item I<-zskphase>

The record's ZSK rollover phase are included in the output.
If this option is given with the I<-kskphase> option, then the output will
follow the format described for the I<-phases> option.
This field is part of the default output.

=item I<-phases>

The record's KSK and ZSK rollover phases are included in the output.
The listing is given with the KSK phase first, followed by the ZSK phase.

Examples of output from this option are:

    KSK phase	ZSK phase	output
        0           0            0/0
        3           0            3/0
        0           5            0/5

=item I<-admin>

The record's administrator value is included in the output.
If an administrator value is not included in a I<rollrec>, then the value
"(defadmin)" will be given.

=item I<-directory>

The name of the directory that holds the zone's files is included in the
output.  If a zone directory is not included in a I<rollrec>, then the value
"(defdir)" will be given.

=item I<-loglevel>

The B<rollerd> logging level for this zone.  This value may be given in
the I<rollrec> file in either the textual or numeric form.  The textual form
of the logging level will be displayed, not the numeric.
If a logging level value is not included in a I<rollrec>, then the value
"(deflog)" will be given.
If an undefined logging level value is included in a I<rollrec>, then the
value "(unknownlog)" will be given.

=item I<-ttl>

The record's TTL value is included in the output.

=item I<-display>

The record's display flag, used by B<blinkenlights>, is included in the output.

=item I<-phstart>

The record's rollover phase is included in the output.
If no rollover has yet been performed for this zone, an empty date is given.

=item I<-lastksk>

The record's last KSK rollover date is included in the output.
If no KSK rollover has yet been performed for this zone, an empty date is given.

=item I<-lastzsk>

The record's last ZSK rollover date is included in the output.
If no ZSK rollover has yet been performed for this zone, an empty date is given.

=back

=head2 Output-format Options

These options select the type of output that will be given by I<lsroll>.

=over 4

=item I<-count>

Only a count of matching keyrecs in the I<rollrec> file is given.

=item I<-headers>

Display explanatory column headers.

=item I<-terse>

Terse output is given.  Only the record name and any other fields specifically
selected are included in the output.

=item I<-long>

Long output is given.  All record fields are included.

=item -help

Display a usage message.

=back

=head1 COPYRIGHT

Copyright 2005-2007 SPARTA, Inc.  All rights reserved.
See the COPYING file included with the DNSSEC-Tools package for details.

=head1 AUTHOR

Wayne Morrison, tewok@users.sourceforge.net

=head1 SEE ALSO

B<blinkenlights(8)>,
B<rollchk(8)>,
B<rollinit(8)>,
B<rollerd(8)>

B<Net::DNS::SEC::Tools::rollrec.pm(3)>

B<Net::DNS::SEC::Tools::file-rollrec(5)>

=cut

