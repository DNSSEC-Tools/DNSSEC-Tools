#!/usr/bin/perl
#
# Copyright 2005-2006 SPARTA, Inc.  All rights reserved.  See the COPYING
# file distributed with this software for details
#
#
# genkrf
#
#	This script generates a keyrec file.
#

use strict;

use Getopt::Long;
use Net::DNS::SEC::Tools::conf;
use Net::DNS::SEC::Tools::keyrec;
use Net::DNS::SEC::Tools::tooloptions;

#######################################################################
#
# Constants
#
our $DEF_TOOLSCONF = "/usr/local/etc/dnssec/dnssec-tools.conf";

#
# A hash mapping algorithm numbers to algorithm names.
#
our %algos = (
    "001" => "rsa",
    "002" => "dh",
    "003" => "dsa",
    "005" => "rsasha1",
    "157" => "hmac_md5"
);

#
# Names of fields from bind-9.3.1/lib/dns/dst_parse.c.
# Private-key-format: v1.2
# These help in finding the size of the key from the .private key file.
#
our %algofields = (
    "001" => "Modulus:",
    "002" => "Prime(p):",
    "003" => "Prime(p):",
    "005" => "Modulus:",
    "157" => "Key:"
);
		  
#
# Data required for command line options.
#
my $zone; 				# Name of the zone.
my $ksk;  				# Name of KSK.
my $zskcur;				# Name of current ZSK.
my $zskpub;				# Name of published ZSK.
my $zonefile;                           # Name of the zone file.
my $signedfile;                         # Name of the signed zone file.
my $kskdir;                             # Directory where the KSK resides.
my $zskdir;                             # Directory where the ZSKs reside.
my $endtime;                            # Endtime of signature validity.
my $random;                             # The source of randomness.
my $krfile;                             # Name of the keyrec file to generate.
my $ksklife;                            # Lifetime of the KSK.
my $zsklife;                            # Lifetime of the ZSK.
my $algo;                               # The encryption algorithm.
my $ksksize;                            # The KSK size.
my $zsksize;                            # The ZSK size.

my $verbose;
my $helpflag;

#
# Command-line options specifically for this program.
#
my @opts = (
		"ksk=s",
		"zskcur=s",
		"zskpub=s",
	   );

#
# Data from the dnssec-tools.conf file.
#
my $keygen;                             # The key-generation program.

#######################################################################

my $ret;				# Return code from main().

$ret = main();
exit($ret);

#-----------------------------------------------------------------------------
#
# Routine:	main()
#
# Uses global variables in this file
#
sub main()
{
	my $argc = @ARGV;		# Number of command line arguments.
	my $errors = 0;			# Total error count.

	#
	# Parse the command line options.
	#
	optsandargs();

	#
	# Generate new keys if not present
	#
	$ksk    = genksk($kskdir) if (!$ksk);
	$zskcur = genzsk($zskdir) if (!$zskcur);
	$zskpub = genzsk($zskdir) if (!$zskpub);

	if (!$ksk) {
	    print STDERR "Error: could not generate KSK.  Please check the $DEF_TOOLSCONF file for correctness\n";
	    exit(1);
	}

	if (!$zskcur || !$zskpub) {
	    print STDERR "Error: could not generate ZSK.  Please check the $DEF_TOOLSCONF file for correctness\n";
	    exit(1);
	}

	#
	# Generate the keyrec file
	#
	my $retval = keyrec_creat($krfile);
	keyrec_read($krfile);

	#
	# Add zone keyrec.
	#
	keyrec_add('zone', $zone, {
				   'zonefile'        => $zonefile,
				   'keyrec_type'     => "zone",
				   'signedfile'      => $signedfile,
				   'endtime'         => $endtime,
				   'kskdirectory'    => $kskdir,
				   'kskpath'         => "$kskdir/$ksk.key",
				   'kskkey'          => $ksk,
				   'zskdirectory'    => $zskdir,
				   'zskcur'          => $zskcur,
				   'zskpub'          => $zskpub,
				   'zskcurpath'      => "$zskdir/$zskcur.key",
				   'zskpubpath'      => "$zskdir/$zskpub.key",
				   'keyrec_signdate' => "",
				   'keyrec_signsecs' => "",
				   });

	#
	# Add ksk keyrec.
	#
	keyrec_add('key', $ksk, {
				 'zonename'	  => $zone,
				 'keyrec_type'	  => "ksk",
				 'algorithm'	  => getkeyalgo($ksk),
				 'random'	  => $random,
				 'ksklength'	  => getkeysize('ksk', $ksk, $kskdir),
				 'ksklife'	  => $ksklife,
				 'keypath'	  => "$kskdir/$ksk.key",
				 'keyrec_gendate' => "",
				 'keyrec_gensecs' => "",
				 });

	#
	# Add zskcur keyrec.
	#
	keyrec_add('key', $zskcur, {
				    'zonename'	     => $zone,
				    'keyrec_type'    => "zskcur",
				    'algorithm'	     => getkeyalgo($zskcur),
				    'random'	     => $random,
				    'zsklength'	     => getkeysize('zsk', $zskcur, $zskdir),
				    'zsklife'	     => $zsklife,
				    'keypath'	     => "$zskdir/$zskcur.key",
				    'keyrec_gendate' => "",
				    'keyrec_gensecs' => "",
				    });

	#
	# Add zskpub keyrec.
	#
	keyrec_add('key', $zskpub, {
				    'zonename'	     => $zone,
				    'keyrec_type'    => "zskpub",
				    'algorithm'	     => getkeyalgo($zskpub),
				    'random'	     => $random,
				    'zsklength'	     => getkeysize('zsk', $zskpub, $zskdir),
				    'zsklife'	     => $zsklife,
				    'keypath'	     => "$zskdir/$zskpub.key",
				    'keyrec_gendate' => "",
				    'keyrec_gensecs' => "",
				    });

	#
	# Write the keyrec file.
	#
	keyrec_write();
	keyrec_close();

	print STDERR "genkrf:. keyrec file $krfile created successfully\n" if($verbose);
	return(0);
}

#-----------------------------------------------------------------------------
#
# Routine:	optsandargs()
#
# Purpose:	Parse the command line for options and arguments.
#
# Uses global variables in this file
#
sub optsandargs
{
	my $ropts;				# Reference to options hash.
	my %opts = ();				# Options hash.

	#
	# Slurp up the options.
	#
	$ropts = tooloptions("","",@opts);
	%opts = %$ropts 	if($ropts != undef);

	#
	# Get the option values.  If these weren't given on the command
	# line, they'll be taken from the config file or the defaults.
	#
	$ksk	   = $opts{'ksk'};
	$zskcur	   = $opts{'zskcur'};
	$zskpub	   = $opts{'zskpub'};

	$ksksize   = $opts{'ksklength'} || dnssec_tools_defaults("ksklength");
	$ksklife   = $opts{'ksklife'}   || dnssec_tools_defaults("ksklife");
	$zsksize   = $opts{'zsklength'} || dnssec_tools_defaults("zsklength");
	$zsklife   = $opts{'zsklife'}   || dnssec_tools_defaults("zsklife");

	$algo	   = $opts{'algorithm'}	|| dnssec_tools_defaults("zsklife");
	$endtime   = $opts{'endtime'}	|| dnssec_tools_defaults("enddate");
	$random	   = $opts{'random'}	|| dnssec_tools_defaults("zsklife");

	$keygen	   = $opts{'keygen'}	|| dnssec_tools_defaults("bind-keygen");

	$verbose   = $opts{'verbose'};
	$helpflag  = $opts{'help'};

	#
	# Give usage message in a few situations.
	#
	usage() if ($#ARGV < 0);
	usage() if($helpflag);

	#
	# Get the zone file and signed filename.
	#
	$zonefile   = $ARGV[0];
	if ($#ARGV > 0) {
	    $signedfile = $ARGV[1];
	}
	else {
	    $signedfile = $zonefile . ".signed";
	}

	#
	# Get the keyrec's zone and strip off a terminal ".".
	#
	$zone = $opts{'zone'} || $zonefile;
	$zone =~ s/^(.*)\.$/$1/;

	#
	# Set the output filename.
	#
	$krfile = $opts{'krfile'} || "$zone.krf";

	$kskdir = "." if (!$kskdir);
	$zskdir = "." if (!$zskdir);

	#
	# If the verbose flag was given, show all the values.
	#
	if($verbose > 1)
	{
		print "zonefile   - \"$zonefile\"\n";
		print "signedfile - \"$signedfile\"\n";
		print "krfile     - \"$krfile\"\n\n";
		print "zone       - \"$zone\"\n";
		print "algorithm  - \"$algo\"\n\n";
		print "endtime    - \"$endtime\"\n\n";
		print "random     - \"$random\"\n\n";
		print "ksk        - \"$ksk\"\n";
		print "zskcur     - \"$zskcur\"\n";
		print "zskpub     - \"$zskpub\"\n\n";
		print "ksksize    - \"$ksksize\"\n";
		print "ksklife    - \"$ksklife\"\n";
		print "zsksize    - \"$zsksize\"\n";
		print "zsklife    - \"$zsklife\"\n\n";
	}
}

#-----------------------------------------------------------------------------
#
# Routine:      getkeyalgo()
#
# Purpose:      This routine takes the identification string of the key
#               generated by dnssec-keygen as a parameter and returns the name
#               of the algorithm for that key.
#
#               The identification string of the key has the following format:
#
#                     Knnnn.+aaa+iiiii
#
#               where:
#
#                     nnnn is the key name
#                     aaa  is the numeric representation of the algorithm
#                     iiiii is the key identifier (or footprint)
#
sub getkeyalgo
{
    my $key = shift;

    my $algonum = $key;
    $algonum =~ s/^[^\+]*\+([^+]*)\+.*$/$1/g;
    return($algos{$algonum});
}

#-----------------------------------------------------------------------------
#
# Routine:      getkeysize()
#
# Purpose:      This routine takes the identification string of the key
#               and an optional key directory as parameters and returns
#               the size of the key.  If the directory is not specified
#               it defaults to the current directory.
#
sub getkeysize
{
    my $keytype	= shift;			# Type of key to create.
    my $key	= shift;			# Name of key.
    my $keydir	= shift;			# Key's directory.

    my $keysize = 0;				# Key length.

    #
    # If the key's size field is set, we'll use it instead of
    # calculating things.
    #
    if($keytype eq "ksk") {
	return($ksksize) if($ksksize > -1);
    }
    else {
	return($zsksize) if($zsksize > -1);
    }

    if (!$keydir) {
	$keydir = ".";
    }

    my $keypath = $keydir . "/" . $key . ".private";

    my $algonum = $key;
    $algonum =~ s/^[^\+]*\+([^+]*)\+.*$/$1/g;

    my $algofield = $algofields{$algonum};

    open(KF, "< $keypath") or return "";

    while(<KF>) {
	my $line = $_;

	next if ($line !~ /^$algofield/);

	# Extract the value of the field.
	$line =~ s/^$algofield(.*)$/$1/;
	$line =~ s/\s//g;

	# The value is encoded in Base64, hence the
	# following algorithm for finding the keysize.
	$keysize = length($line);
	$keysize = ($keysize / 4) * 3;

	if ($line =~ /==$/) {
		$keysize -= 2;
	}
	elsif ($line =~ /=$/) {
		$keysize -= 1;
	}
	    
	$keysize *= 8;
	last;
    }


    close(KF);

    return($keysize);
}

#-----------------------------------------------------------------------------
#
# Routine:      genksk()
#
# Purpose:      This routine generates a new Key Signing Key (KSK).
#
sub genksk
{
    my $cmdopts = "-r $random -a $algo -b $ksksize";
    my $ksk = `$keygen $cmdopts -n zone -f KSK $zone`;

    chomp $ksk;
    if ($kskdir ne ".") {
	`mkdir -p $kskdir && mv $ksk* $kskdir`;
    }

    $ksksize = -1;

    return($ksk || "");
}


#-----------------------------------------------------------------------------
#
# Routine:      genzsk()
#
# Purpose:      This routine generates a new Zone Signing Key (ZSK).
#
sub genzsk
{
    my $cmdopts = "-r $random -a $algo -b $zsksize";
    my $zsk = `$keygen $cmdopts -n zone $zone`;

    chomp $zsk;
    if ($zskdir ne ".") {
	`mkdir -p $zskdir && mv $zsk* $zskdir`;
    }

    $zsksize = -1;

    return($zsk || "");
}

#-----------------------------------------------------------------------------
#
# Routine:	usage()
#
# Purpose:      This routine prints the usage and exits.
#
sub usage
{
	print STDERR "usage: genkrf [options] <zone-file> [signed-zone-file]\n";

	print STDERR "\n\t<zone-file>                     name of the zone file\n";
	print STDERR "\t[signed-zone-file]              name of the signed zone file\n";

	print STDERR "\n\toptions:\n";
	print STDERR "\t\t-zone ZONE              name of the zone\n";
	print STDERR "\t\t-krfile KEYREC          zone's keyrec file\n";
	print STDERR "\t\t-algorithm ALGORITHM    encryption algorithm\n";
	print STDERR "\t\t-endtime ENDTIME        end time of signature\n";
	print STDERR "\t\t-random RANDOMDEV       source of randomness\n\n";

	print STDERR "\t\t-ksk KSK                name of the KSK\n";
	print STDERR "\t\t-kskdir PATH            KSK directory\n";
	print STDERR "\t\t-ksklength KEYLEN       KSK length\n";
	print STDERR "\t\t-ksklife LIFETIME       KSK lifetime\n\n";

	print STDERR "\t\t-zskcur ZSKCUR          name of the current ZSK\n";
	print STDERR "\t\t-zskpub ZSKPUB          name of the published ZSK\n";
	print STDERR "\t\t-zskdir PATH            ZSK directory\n";
	print STDERR "\t\t-zsklength KEYLEN       ZSK length\n";
	print STDERR "\t\t-zsklife LIFETIME       ZSK lifetime\n\n";

	print STDERR "\t\t-verbose                verbose output\n";
	print STDERR "\t\t-help                   help message\n";

	exit(0);
}


1;

##############################################################################
#

=pod

=head1 NAME

genkrf - Generate a I<keyrec> file from existing Key Signing Key (KSK)
         and/or Zone Signing Key (ZSK) files.

=head1 SYNOPSIS

  genkrf [options] <zone-file> [<signed-zone-file>]

  genkrf -help

=head1 DESCRIPTION

This script generates a I<keyrec> file (see zonesigner(1) for details) from
existing KSK and/or ZSK files.  It generates new KSK and/or ZSK keys if
needed.

The name of the I<keyrec> file to be generated is given by the I<-krfile>
option.  If this option is not specified, <zone-name>.krf is used as the
name of the I<keyrec> file.  If the I<keyrec> file already exists, it will
be overwritten with new I<keyrec> definitions.

The I<zone-file> argument is required.  It specifies the name of the zone
file from which the signed zone file was created.  The optional
I<signed-zone-file> argument specifies the name of the signed zone file.
If it is not given, then it defaults to "I<<zone-file>>.signed".

=head1 OPTIONS

B<genkrf> has the following options:

=over 4

=item -zone

This option specifies the name of the zone.  If it is not given then
I<zone-file> will be used as the name of the zone.

=item -krfile

This option specifies the name of the keyrec file.  If it is not given
then I<zone-name>.krf will be used as the name of the keyrec file to
be generated.

=item -ksk

This option specifies the KSK being used to sign the zone.  If this
option is not given, a new KSK will be created.

=item -kskdir

This option specifies the absolute or relative path of the directory
where the KSK resides.  If this option is not given, it defaults to
the current directory ".".

=item -zskcur

This option specifies the current ZSK being used to sign the zone.
If this option is not given, a new ZSK will be created.

=item -zskpub

This option specifies the published ZSK for the zone.  If this option
is not given, a new ZSK will be created.

=item -zskdir

This option specifies the absolute or relative path of the directory
where the ZSKs reside.  If this option is not given, it defaults to
the current directory ".".

=item -endtime

This option specifes the time that the signature on the zone expires,
measured in seconds.  See the man page for I<dnssec-signzone> for the
valid format of this field.  If this option is not specified, its
value is read from the /usr/local/etc/dnssec/dnssec-tools.conf file.
If this file does not specify an endtime field, the value of this
option defaults to 2592000 seconds (30 days).

=item -random

Source of randomness used to generate the zone's keys. See the man
page for I<dnssec-signzone> for the valid format of this field.  If
this option is not specified, its value is read from the
/usr/local/etc/dnssec/dnssec-tools.conf file.  If this file does not
specify a random field, the value of this option defaults to 
"/dev/urandom".

=back

=over 4

=item -help

Display a usage message.

=back

=head1 COPYRIGHT

Copyright 2005-2006 SPARTA, Inc.  All rights reserved.
See the COPYING file included with the DNSSEC-Tools package for details.

=head1 AUTHOR

Abhijit Hayatnagarkar

=head1 SEE ALSO

B<Net::DNS::SEC::Tools::conf.pm(3)>,
B<Net::DNS::SEC::Tools::defaults.pm(3)>,
B<Net::DNS::SEC::Tools::keyrec.pm(3)>

B<zonesigner(1)>

=cut
