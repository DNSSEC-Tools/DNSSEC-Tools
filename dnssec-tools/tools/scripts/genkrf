#!/usr/bin/perl
#
# Copyright 2005 SPARTA, Inc.  All rights reserved.  See the COPYING
# file distributed with this software for details
#
#
# genkrf
#
#	This script generates a keyrec file.
#

use strict;

use Getopt::Long;
use Net::DNS::SEC::Tools::keyrec;
use Net::DNS::SEC::Tools::conf;

#######################################################################
#
# Constants
#
our $DEF_ENDTIME   = "+2592000";        # Thirty days
our $DEF_RANDOM    = "/dev/urandom";    # Default source of randomness
our $DEF_KEYGEN    = "dnssec-keygen";   # Default command for key generation
our $DEF_ALGORITHM = "rsasha1";         # Default algorithm
our $DEF_KSKSIZE   = 2048;              # Default KSK size
our $DEF_ZSKSIZE   = 1024;              # Default ZSK size
our $DEF_TOOLSCONF = "/usr/local/etc/dnssec/dnssec-tools.conf";

# A hash mapping algorithm numbers to algorithm names
our %algos = (
    "001" => "rsa",
    "002" => "dh",
    "003" => "dsa",
    "005" => "rsasha1",
    "157" => "hmac_md5"
);

# Names of fields from bind-9.3.1/lib/dns/dst_parse.c
# Private-key-format: v1.2
# These help in finding the size of the key from the .private key file
our %algofields = (
    "001" => "Modulus:",
    "002" => "Prime(p):",
    "003" => "Prime(p):",
    "005" => "Modulus:",
    "157" => "Key:"
);
		  
#
# Data required for command line options.
#
my $zone; 				# Name of the zone
my $ksk;  				# Name of KSK.
my $zskcur;				# Name of current ZSK.
my $zskpub;				# Name of published ZSK.
my $zonefile;                           # Name of the zone file
my $signedfile;                         # Name of the signed zone file
my $kskdir;                             # Directory where the KSK resides
my $zskdir;                             # Directory where the ZSKs reside
my $endtime;                            # Endtime of signature validity
my $random;                             # The source of randomness
my $krfile;                             # Name of the keyrec file to generate
my $helpflag;

#
# Command line options for this program
#
my @opts = ("zone=s"      => \$zone,
	    "ksk=s"       => \$ksk,
	    "kskdir=s"    => \$kskdir,
	    "zskcur=s"    => \$zskcur,
	    "zskpub=s"    => \$zskpub,
	    "zskdir=s"    => \$zskdir,
	    "endtime=s"   => \$endtime,
	    "random=s"    => \$random,
	    "krfile=s"    => \$krfile,
	    "help"        => \$helpflag # Give a usage message and exit.
	    );

#
# Data from the dnssec-tools.conf file
#
my $keygen;                             # The key-generation program
my $algo;                               # The algorithm
my $ksksize;                            # The KSK size
my $zsksize;                            # The ZSK size

#######################################################################

my $ret;				# Return code from main().

$ret = main();
exit($ret);

#-----------------------------------------------------------------------------
#
# Routine:	main()
#
# Uses global variables in this file
#
sub main()
{
	my $argc = @ARGV;		# Number of command line arguments.
	my $errors = 0;			# Total error count.

	#
	# Parse the command line options.
	#
	optsandargs();

	#
	# Generate new keys if not present
	#
	$ksk    = genksk($kskdir) if (!$ksk);
	$zskcur = genzsk($zskdir) if (!$zskcur);
	$zskpub = genzsk($zskdir) if (!$zskpub);

	if (!$ksk) {
	    print STDERR "Error: could not generate KSK.  Please check the $DEF_TOOLSCONF file for correctness\n";
	    exit(1);
	}

	if (!$zskcur || !$zskpub) {
	    print STDERR "Error: could not generate ZSK.  Please check the $DEF_TOOLSCONF file for correctness\n";
	    exit(1);
	}

	#
	# Generate the keyrec file
	#

	# Initialize a keyrecc data structure
	my $retval = keyrec_creat($krfile);

	keyrec_read($krfile);

	# Add zone keyrec
	keyrec_add('zone', $zone, {
				   'keyrec_signdate' => "",
				   'keyrec_signsecs' => "",
				   'endtime'         => $endtime,
				   'signedfile'      => $signedfile,
				   'zonefile'        => $zonefile,
				   'zskdirectory'    => $zskdir,
				   'zskpubpath'      => "$zskdir/$zskpub.key",
				   'zskcurpath'      => "$zskdir/$zskcur.key",
				   'zskpub'          => $zskpub,
				   'zskcur'          => $zskcur,
				   'kskdirectory'    => $kskdir,
				   'kskpath'         => "$kskdir/$ksk.key",
				   'kskkey'          => $ksk,
				   'keyrec_type'     => "zone"
				   });

	# Add ksk keyrec
	keyrec_add('key', $ksk, {
				 'keyrec_gendate' => "",
				 'keyrec_gensecs' => "",
				 'ksklength'      => getkeysize($ksk, $kskdir),
				 'keypath'        => "$kskdir/$ksk.key",
				 'random'         => $random,
				 'algorithm'      => getkeyalgo($ksk),
				 'zonename'       => $zone,
				 'keyrec_type'    => "ksk"
				 });

	# Add zskcur keyrec
	keyrec_add('key', $zskcur, {
				    'keyrec_gendate' => "",
				    'keyrec_gensecs' => "",
				    'zsklength'      => getkeysize($zskcur, $zskdir),
				    'keypath'        => "$zskdir/$zskcur.key",
				    'random'         => $random,
				    'algorithm'      => getkeyalgo($zskcur),
				    'zonename'       => $zone,
				    'keyrec_type'    => "zskcur"
				    });

	# Add zskpub keyrec
	keyrec_add('key', $zskpub, {
				    'keyrec_gendate' => "",
				    'keyrec_gensecs' => "",
				    'zsklength'      => getkeysize($zskpub, $zskdir),
				    'keypath'        => "$zskdir/$zskpub.key",
				    'random'         => $random,
				    'algorithm'      => getkeyalgo($zskpub),
				    'zonename'       => $zone,
				    'keyrec_type'    => "zskpub"
				    });

	# Write the keyrec file
	keyrec_write();
	keyrec_close();

	print STDERR "genkrf: file $krfile created successfully.\n";
	return(0);
}

#-----------------------------------------------------------------------------
#
# Routine:	optsandargs()
#
# Purpose:	Parse the command line for options and arguments.
#
# Uses global variables in this file
#
sub optsandargs
{
	# Parse the command-line options
	GetOptions(@opts);

	usage() if $helpflag;

	usage() if ($#ARGV < 0);

	$zonefile = $ARGV[0];

	if ($#ARGV > 0) {
	    $signedfile = $ARGV[1];
	}
	else {
	    $signedfile = $zonefile . ".signed";
	}

#	usage() if (!$ksk && !$zskcur && !$zskpub);

	# Parse the dnssec-tools.conf file
	my %dtconf = parseconfig();

	$zone = $zonefile if (!$zone);
	$zone =~ s/^(.*)\.$/$1/;

	$krfile = $zone . ".krf" if (!$krfile);

	$kskdir = "." if (!$kskdir);
	$zskdir = "." if (!$zskdir);

	$endtime = $dtconf{'endtime'} if (!$endtime);
	$endtime = $DEF_ENDTIME if (!$endtime);

	$random = $dtconf{'random'} if (!$random);
	$random = $DEF_RANDOM if (!$random);

	$keygen  = $dtconf{'keygen'}    || $DEF_KEYGEN;
	$ksksize = $dtconf{'ksklength'} || $DEF_KSKSIZE;
	$zsksize = $dtconf{'zsklength'} || $DEF_ZSKSIZE;
	$algo    = $dtconf{'algorithm'} || $DEF_ALGORITHM;
}

#-----------------------------------------------------------------------------
#
# Routine:	usage()
#
# Purpose:      This routine prints the usage and exits
#
sub usage
{
	print STDERR "usage: genkrf [options] <zone-file> [<signed-zone-file>]\n";

	print STDERR "\n\t<zone-file>                  name of the zone file\n";
	print STDERR "\t<signed-zone-file>           name of the signed zone file\n";

	print STDERR "\n\toptions:\n";
	print STDERR "\t\t-zone=<ZONE>         name of the zone\n";
	print STDERR "\t\t-ksk=<KSK>           name of the Key Signing Key (KSK)\n";
	print STDERR "\t\t-kskdir=<PATH>       KSK directory\n";
	print STDERR "\t\t-zskcur=<ZSKCUR>     name of the current Zone Signing Key (ZSK)\n";
	print STDERR "\t\t-zskpub=<ZSKPUB>     name of the published ZSK\n";
	print STDERR "\t\t-zskdir=<PATH>       ZSK directory\n";
	print STDERR "\t\t-endtime=<ENDTIME>   end time of signature\n";
	print STDERR "\t\t-random=<RANDOMDEV>  source of randomness\n";

	print STDERR "\t\t-help\t              help message\n";

	exit(0);
}

#-----------------------------------------------------------------------------
#
# Routine:      getkeyalgo()
#
# Purpose:      This routine takes the identification string of the key
#               generated by dnssec-keygen as a parameter and returns the name
#               of the algorithm for that key.
#
#               The identification string of the key has the following format:
#
#                     Knnnn.+aaa+iiiii
#
#               where
#
#                     nnnn is the key name
#                     aaa  is the numeric representation of the algorithm
#                 and iiiii is the key identifier (or footprint)
#
sub getkeyalgo
{
    my $key = shift;

    my $algonum = $key;
    $algonum =~ s/^[^\+]*\+([^+]*)\+.*$/$1/g;
    return $algos{$algonum};
}

#-----------------------------------------------------------------------------
#
# Routine:      getkeysize()
#
# Purpose:      This routine takes the identification string of the key
#               and an optional key directory as parameters and returns
#               the size of the key.  If the directory is not specified
#               it defaults to the current directory.
#
sub getkeysize
{
    my $key = shift;
    my $keydir = shift;
    my $keysize = 0;

    if (!$keydir) {
	$keydir = ".";
    }

    my $keypath = $keydir . "/" . $key . ".private";

    my $algonum = $key;
    $algonum =~ s/^[^\+]*\+([^+]*)\+.*$/$1/g;

    my $algofield = $algofields{$algonum};

    open(KF, "< $keypath") or return "";

    while(<KF>) {
	my $line = $_;
	if ($line =~ /^$algofield/) {
	    # Extract the value of the field
	    $line =~ s/^$algofield(.*)$/$1/;
	    $line =~ s/\s//g;

	    # The value is encoded in Base64, hence the
	    # following algorithm for finding the keysize
	    $keysize = length($line);
	    $keysize = ($keysize / 4) * 3;
	    if ($line =~ /==$/) {
		$keysize -= 2;
	    }
	    elsif ($line =~ /=$/) {
		$keysize -= 1;
	    }
	    
	    $keysize *= 8;
	    last;
	}
    }
    close(KF);

    return $keysize;
}

#-----------------------------------------------------------------------------
#
# Routine:      genksk()
#
# Purpose:      This routine generates a new Key Signing Key (KSK)
#
# Uses global variables in this file
#
sub genksk
{
    my $cmdopts = "-r $random -a $algo -b $ksksize";
    my $ksk = `$keygen $cmdopts -n zone -f KSK $zone`;

    chomp $ksk;
    if ($kskdir ne ".") {
	`mkdir -p $kskdir && mv $ksk* $kskdir`;
    }
    return $ksk || "";
}


#-----------------------------------------------------------------------------
#
# Routine:      genzsk()
#
# Purpose:      This routine generates a new Zone Signing Key (ZSK)
#
# Uses global variables in this file
#
sub genzsk
{
    my $cmdopts = "-r $random -a $algo -b $zsksize";

    my $zsk = `$keygen $cmdopts -n zone $zone`;
    chomp $zsk;
    if ($zskdir ne ".") {
	`mkdir -p $zskdir && mv $zsk* $zskdir`;
    }
    return $zsk || "";
}


1;

##############################################################################
#

=pod

=head1 NAME

genkrf - Generate a I<keyrec> file from existing Key Signing Key (KSK)
         and/or Zone Signing Key (ZSK) files.

=head1 SYNOPSIS

  genkrf [options] <zone-file> [<signed-zone-file>]

  genkrf -help

=head1 DESCRIPTION

This script generates a I<keyrec> file (see zonesigner(1) for details) from
existing KSK and/or ZSK files.  It generates new KSK and/or ZSK keys if
needed.

The name of the I<keyrec> file to be generated is given by the I<-krfile>
option.  If this option is not specified, <zone-name>.krf is used as the
name of the I<keyrec> file.  If the I<keyrec> file already exists, it will
be overwritten with new I<keyrec> definitions.

The I<zone-file> argument is required.  It specifies the name of the zone
file from which the signed zone file was created.  The optional
I<signed-zone-file> argument specifies the name of the signed zone file.
If it is not given, then it defaults to "I<<zone-file>>.signed".

=head1 OPTIONS

B<genkrf> has the following options:

=over 4

=item -zone

This option specifies the name of the zone.  If it is not given then
I<zone-file> will be used as the name of the zone.

=item -krfile

This option specifies the name of the keyrec file.  If it is not given
then I<zone-name>.krf will be used as the name of the keyrec file to
be generated.

=item -ksk

This option specifies the KSK being used to sign the zone.  If this
option is not given, a new KSK will be created.

=item -kskdir

This option specifies the absolute or relative path of the directory
where the KSK resides.  If this option is not given, it defaults to
the current directory ".".

=item -zskcur

This option specifies the current ZSK being used to sign the zone.
If this option is not given, a new ZSK will be created.

=item -zskpub

This option specifies the published ZSK for the zone.  If this option
is not given, a new ZSK will be created.

=item -zskdir

This option specifies the absolute or relative path of the directory
where the ZSKs reside.  If this option is not given, it defaults to
the current directory ".".

=item -endtime

This option specifes the time that the signature on the zone expires,
measured in seconds.  See the man page for I<dnssec-signzone> for the
valid format of this field.  If this option is not specified, its
value is read from the /usr/local/etc/dnssec/dnssec-tools.conf file.
If this file does not specify an endtime field, the value of this
option defaults to 2592000 seconds (30 days).

=item -random

Source of randomness used to generate the zone's keys. See the man
page for I<dnssec-signzone> for the valid format of this field.  If
this option is not specified, its value is read from the
/usr/local/etc/dnssec/dnssec-tools.conf file.  If this file does not
specify a random field, the value of this option defaults to 
"/dev/urandom".

=back

=over 4

=item -help

Display a usage message.

=back

=head1 COPYRIGHT

Copyright 2005 SPARTA, Inc.  All rights reserved.
See the COPYING file included with the DNSSEC-Tools package for details.

=head1 AUTHOR

Abhijit Hayatnagarkar

=head1 SEE ALSO

B<Net::DNS::SEC::Tools::keyrec.pm(3)>

B<zonesigner(1)>

=cut
