#!/usr/bin/perl
#
# Copyright 2005 Sparta, Inc.  All rights reserved.  See the COPYING
# file distributed with this software for details
#
# zonesigner
#
#	This script combines a lot of actions required to sign a zone into a
#	single command.  The command is used in this way:
#
#		zonesigner [options] <zone> <zoneout>
#
#		where:
#			zone	 - the zone to be signed.  This may also be
#				   specified with the -zone option.  This is
#				   a zone file to which the $INCLUDE ksk and
#				   $INCLUDE zsk lines are added
#			zoneout	 - the name of the output zone file
#
#
#	Options, their meanings, and default values are given below.
#
#	Options passed to dnssec-keygen:
#		-algorithm	crypto algorithm	(RSASHA1)
#		-random		source of randomness	(/dev/urandom)
#		-ksklength	size of KSK key		(1024)
#		-zsklength	size of ZSK key		(512)
#
#	Options passed to dnssec-signzone:
#		-endtime	end-time		(259200)
#		-gends		generate DS records	(not given)
#
#	Other options:
#		-krfile		keyrec file to use
#		-ksdir		directory for keysets
#		-keyrec		keyrec to search for in specified keyrec file
#		-zone		zone name
#
#		-reuseksk	re-use the zone's current KSK
#		-reusezsk	re-use the zone's current ZSK
#
#		-kgopts		additional options to pass to dnssec-keygen
#		-szopts		additional options to pass to dnssec-signzone
#
#		-help		display usage message
#		-verbose	verbose output
#

use strict;

use Net::DNS::SEC::Tools::keyrec;
use Net::DNS::SEC::Tools::tooloptions;

#
# Verbose values.
#
my $VERBOSE_LOW	   = 1;			# Lowest verbosity level.
my $VERBOSE_MEDIUM = 2;			# Middlin' verbosity level.
my $VERBOSE_HIGH   = 3;			# High verbosity level.

#
# Options fields.
#
my $alg;				# Encryption algorithm.
my $enddate;				# End-time for zone signing.
my $gends;				# Generate DS records in zone signing.
my $help = 0;				# Help flag.
my $kgopts;				# Additional dnssec-keygen options.
my $ksdir;				# Directory to hold keysets.
my $ksize;				# Size of KSK.
my $kskdir;				# Directory to hold KSK.
my $nokrfile;				# Flag for not using a keyrec file.
my $random;				# Random number generation method.
my $szopts;				# Additional dnssec-signzone options.
my $verbose = 0;			# Turn off verbosity.
my $zsize;				# Size of ZSK.
my $zskdir;				# Directory to hold ZSK.

my $ksk;				# KSK we've generated.
my $kskpath;				# Path to the KSK.
my $reuseksk;				# Reuse the existing KSK.
my $zskcur;				# Current ZSK.
my $zskpub;				# Published ZSK.
my $zskcurpath;				# Path to the published KSK.
my $zskpubpath;				# Path to the current KSK.
my $reusezsk;				# Reuse the existing ZSK.

my $zone;				# Zone to play with.
my $zoneout;				# Zone file (output.)
my $krfile;				# User-specified keyrec file.

my $status;				# Zone-signing status.
my @zonestat;				# stat() buffer for zone file.

#
# Some path variables to be set from the config file.
#
my $checkzone;
my $keygen;
my $signzone;

my %opts;				# Options.
my @saveargs = @ARGV;			# Copy of argument vector.

#
# Zonesigner-specific command line arguments.
#
my @zsopts = ( "rollforce" );
my $forceroll = 0;			# Force-a-roll-over flag.

#
# Set some path variables.
#
my $CP		= "/bin/cp";
my $DATE	= "/bin/date";
my $MV		= "/bin/mv";


#
# Do our work.
#
$status = main();
exit($status);

#######################################################################
#
# Routine:	main()
#
# Purpose:	Yeah, yeah, a main() isn't necessary.  However, it offends my
#		sense of aesthetics to have great gobs of code on the same
#		level as a pile of globals.
#
#		But what about all those globals, you ask...
#
sub main
{
	my $statlen;				# Length of stat() buffer.
	my $status;				# Status of zone-signing.

	#
	# Munch on the options and arguments.
	#
	optsandargs();

	if($verbose > $VERBOSE_LOW)
	{
		print "\narguments:\n";
		print "\tzone	 - $zone\n";
		print "\tzoneout - $zoneout\n";
	}

	#
	# If help was specified, give the usage and exit.
	#
	if($help == 1)
	{
		usage(1);
	}

	#
	# Ensure that the required data were specified.
	#
	if(($zone eq "") || ($zoneout eq ""))
	{
		print STDERR "no zone specified\n";
		usage(2);
	}

	#
	# Ensure that the zone file exists and open it.
	#
	$statlen = @zonestat = stat($zone);
	if($statlen == 0)
	{
		print STDERR "zone file $zone does not exist\n";
		exit(1);
	}
	open(ZF,"+< $zone") or die "unable to open zone file $zone";

	#
	# Ensure that the zone file has not been signed yet.
	#
	if(presigned())
	{
		print STDERR "zone file $zone already signed\n";
		exit(1);
	}

	#
	# Generate the KSK and ZSK key files.
	#
	genkeys();

	#
	# Create the key directories and move the key files into the
	# appropriate repositories.
	#
	keydirs();

	#
	# Set some short-hand variables.
	#
	$kskpath    = "$kskdir/$ksk.key";
	$zskcurpath = "$zskdir/$zskcur.key";
	$zskpubpath = "$zskdir/$zskpub.key";

	#
	# Create the unsigned zone file and add include lines for the key files.
	#
	zoneincludes();

	#
	# Sign the zone with the new keys and ensure the signing succeeded.
	#
	$status = zonesign();
	return($status);
}

#######################################################################
#
# Routine:	optsandargs()
#
# Purpose:	Parse the command line for options and arguments.
#
sub optsandargs()
{
	my $argc;			# Number of arguments.
	my $ropts;			# Reference to the option hash.

	#
	# Set the options, try to use the config file, the command line
	# options and a keyrec file.  We'll take the following steps in
	# trying to get a good set of options.
	#
	#  1. Set options from config file, command line, and a keyrec.
	#     Look in the options for -krfile and -keyrec to find the keyrec.
	#  2. Set options from config file, command line, and a keyrec.
	#     Use our first argument is a zone name, and assume there's
	#     a -krfile.  (Previous step showed there isn't a -keyrec.)
	#  3. Set options from the config file and command line.  No keyrec
	#     will be used.
	#
	opts_setcsopts(@zsopts);
	opts_createkrf();
	$ropts = opts_zonekr();
	if($ropts == undef)
	{
		$zone = $ARGV[0];
		$ropts = opts_zonekr("",$zone);
		if($ropts == undef)
		{
			$ropts = tooloptions("","");
		}
	}
	if($ropts != undef)
	{
		%opts = %$ropts;
	}

	#
	# Get the KSK- and ZSK-related arguments.
	#
	$ksize	  = $opts{'ksklength'}	  || "";
	$zsize	  = $opts{'zsklength'}	  || "";
	$kskdir	  = $opts{'kskdirectory'} || '.';
	$zskdir	  = $opts{'zskdirectory'} || '.';
	$kskpath  = $opts{'kskpath'}	  || "";
	$reuseksk = $opts{'reuseksk'}	  || 0;
	$reusezsk = $opts{'reusezsk'}	  || 0;

	#
	# Get the rest of the options.
	#
	$alg	  = $opts{'algorithm'}	|| "";
	$enddate  = $opts{'endtime'}	|| "";
	$gends	  = $opts{'gends'}	|| "";
	$random   = $opts{'random'}	|| "";
	$kgopts   = $opts{'kgopts'}	|| "";
	$ksdir	  = $opts{'ksdir'}	|| "";
	$szopts   = $opts{'szopts'}	|| "";
	$krfile   = $opts{'krfile'}	|| "";
	$nokrfile = $opts{'nokrfile'}	|| "";

	#
	# Get our undocumented options.
	#
	$forceroll = $opts{'rollforce'}	|| 0;

	#
	# Set up options and values, if they've been given.
	#
	$ksize	 = "-b $ksize"	 if($ksize ne "");
	$zsize	 = "-b $zsize"	 if($zsize ne "");
	$alg	 = "-a $alg"	 if($alg ne "");
	$enddate = "-e $enddate" if($enddate ne "");
	$gends	 = "-g"		 if($gends ne "");
	$ksdir	 = "-d $ksdir"	 if($ksdir ne "");
	$random	 = "-r $random"	 if($random ne "");

	$help	 = $opts{'help'};
	$verbose = $opts{'verbose'};


	#
	# Get the paths to the external commands.  Crash and burn if these
	# fields aren't defined anywhere.
	#
	$checkzone = $opts{'checkzone'};
	$keygen	   = $opts{'keygen'};
	$signzone  = $opts{'signzone'};
	if(($checkzone eq "")	||
	   ($keygen    eq "")	||
	   ($signzone  eq ""))
	{
		print STDERR "full paths must be specified in the config file for named-checkzone, dnssec-keygen, and dnssec-signzone.\n";
		exit(-1);
	}

	#
	# If the verbose flag was set, we'll print out the options we're
	# using.
	#
	if($verbose > $VERBOSE_MEDIUM)
	{
		print "zonesigner arguments:\n";
		print "\tkrfile		- <$krfile>\n";
		print "\tnokrfile	- <$nokrfile>\n";
		print "\n";

		print "key-signing parameters:\n";
		print "\talgorithm	- <$alg>\n";
		print "\trandom		- <$random>\n";
		print "\tksize		- <$ksize>\n";
		print "\tkskdir		- <$kskdir>\n";
		print "\treuseksk	- <$reuseksk>\n";
		print "\tzsize		- <$zsize>\n";
		print "\tzskdir		- <$zskdir>\n";
		print "\treusezsk	- <$reusezsk>\n";
		print "\tkgopts		- <$kgopts>\n";
		print "\n";

		print "zone-signing parameters:\n";
		print "\tenddate	- <$enddate>\n";
		print "\tgends		- <$gends>\n";
		print "\tksdir		- <$ksdir>\n";
		print "\tszopts		- <$szopts>\n";
		print "\n";

		print "external commands:\n";
		print "\tcheckzone	- <$checkzone>\n";
		print "\tkeygen		- <$keygen>\n";
		print "\tsignzone	- <$signzone>\n";
	}

	#
	# Check that we don't have too many arguments.
	#
	$argc = @ARGV;
	usage(3) if($argc > 3);
	#
	# If we've got two arguments (after option removal) we'll look for
	# the zone name in the arguments.  If we find it, we'll add the
	# zone name to the argument list.  If we don't, we'll duplicate
	# the existing argument for use as both source and destination.
	#
	if($argc == 1)
	{
		$zone = $opts{'zone'};

		if(defined($zone))
		{
			unshift(@ARGV,$zone);
		}
		else
		{
			unshift(@ARGV,$ARGV[0]);
		}
	}

	#
	# Set variables for the arguments.
	#
	$zone	 = $ARGV[0];
	$zoneout = $ARGV[1];

	#
	# If the keyrec file is empty, we'll create a keyrec for
	# the zone.
	#
	chkkrf();

	#
	# Ensure that two mutually exclusive keyrec file options aren't given.
	#
	if(defined($opts{'krfile'}) && defined($opts{'nokrfile'}))
	{
		print STDERR "-krfile and -nokrfile are mutually exclusive\n";
		usage(4);
	}
}

#######################################################################
#
# Routine:	presigned()
#
# Purpose:	Ensure that the specified zone file is not a signed zone file.
#		We'll check for the presence of a signed-specific record.
#
#		Returns:
#			0 - Zone not previously signed.
#			1 - Zone previously signed.
#
sub presigned
{
	my $zfile = shift;			# Name of zone file.

	my $file = "";				# Contents of zone file.
	my $flen = 0;				# Length of zone file.
	my $hitcnt;				# Number of RRSIGs in file.
	my @hits;				# RRSIG hits.

	#
	# Get the zone file's length and contents.
	#
	$flen = $zonestat[7];
	seek(ZF,0,0);
	read(ZF,$file,$flen);

	$hitcnt = @hits = $file =~ /RRSIG/mg;

	#
	# If we found some RRSIG records, return a true value.  If not,
	# return a false value.
	#
	if($hitcnt > 0)
	{
		return(1);
	}
	return(0);
}

#######################################################################
#
# Routine:	genkeys()
#
# Purpose:	Generate new KSK and ZSK keys.  New keyrecs for the new keys
#		are added to the keyrec file.
#
sub genkeys
{
	print "\ngenerating key files:\n" if($verbose);

	#
	# Generate the KSK key.
	#
	genksk();

	#
	# Generate the ZSK keys.
	#
	if($forceroll)
	{
		forceroll();
	}
	else
	{
		$zskcur = genzsk("cur");
		$zskpub = genzsk("pub");
	}
}

#######################################################################
#
# Routine:	genksk()
#
# Purpose:	Generate a new KSK key.
#
sub genksk
{
	my $cmdopts;			# Options for dnssec-signzone.
	my $zskdir;			# ZSK directory for saving.

	#
	# If we're going to reuse the KSK, ensure it's been created and
	# return.
	#
	if($reuseksk == 1)
	{
		if($opts{'kskkey'} eq "")
		{
			print STDERR "unable to re-use a non-existent KSK\n";
			exit(1);
		}

		$ksk = $opts{'kskkey'};
		print "\treusing existing KSK - $ksk\n\n" if($verbose);

		return;
	}

	#
	# Generate the new KSK.
	#
	$cmdopts = "$kgopts $random $alg $ksize";
	print "\t$keygen $cmdopts -n zone -f KSK $zone\n" if($verbose);
	$ksk = `$keygen $cmdopts -n zone -f KSK $zone`;
	if($? != 0)
	{
		print STDERR "unable to generate KSK key file;\n";
		print STDERR "dnssec-keygen returned $?\n" if($verbose);
		exit(1);
	}
	chomp $ksk;
	print "\t\tnew KSK - $ksk\n\n" if($verbose);

	#
	# Save the ZSK directory.
	#
	$zskdir = $opts{'zskdirectory'};
	delete $opts{'zskdirectory'};

	#
	# Add the KSK's keyrec to the keyrec file.
	#
	$opts{'keyrec_type'} = "ksk";
	$opts{'kgopts'}      = $kgopts if($kgopts ne "");
	keyrec_add('key',$ksk,\%opts);

	#
	# Restore the ZSK directory and dump the keyrec type.
	#
	$opts{'zskdirectory'} = $zskdir;
	delete $opts{'keyrec_type'};
}

#######################################################################
#
# Routine:	genzsk()
#
sub genzsk
{
	my $cmdopts;			# Options for dnssec-signzone.
	my $keytype = shift;		# ZSK type:  cur, new, pub.
	my $kskdir;			# KSK directory for saving.
	my $zskkey;			# Hash key for this ZSK.
	my $zsk;			# Generated key.

	#
	# Get the hash key for the ZSK we're going to generate.
	#
	$zskkey = "zsk" . $keytype;

	#
	# If we're reusing the ZSK, ensure it's already defined and return.
	#
	if($reusezsk == 1)
	{
		if(keyrec_fullrec($opts{$zskkey}) eq "")
		{
			print STDERR "$keytype ZSK keyrec does not exist; unable to re-use non-existent $keytype ZSK\n";
			exit(1);
		}

		$zsk = $opts{$zskkey};
		print "\treusing existing $keytype ZSK - $zsk\n\n" if($verbose);

		return($zsk);
	}

	#
	# Generate a ZSK key.
	#
	$cmdopts = "$kgopts $random $alg $zsize";
	print "\t$keygen $cmdopts -n zone $zone\n" if($verbose);
	$zsk = `$keygen $cmdopts -n zone $zone`;
	if($? != 0)
	{
		print STDERR "unable to generate $keytype ZSK key file;\n";
		print STDERR "dnssec-keygen returned $?\n" if($verbose);
		exit(1);
	}
	chomp $zsk;
	print "\t\tnew $keytype ZSK - $zsk\n\n" if($verbose);

	#
	# Save the KSK directory.
	#
	$kskdir = $opts{'kskdirectory'};
	delete $opts{'kskdirectory'};

	#
	# Add the ZSK's keyrec to the keyrec file.
	#
	$opts{'keyrec_type'} = "$zskkey";
	$opts{'kgopts'}	     = $kgopts if($kgopts ne "");
	keyrec_add('key',$zsk,\%opts);
	$opts{"$zskkey"} = $zsk;

	#
	# Restore the KSK directory and dump the keyrec type.
	#
	$opts{'kskdirectory'} = $kskdir;
	delete $opts{'keyrec_type'};
	delete $opts{'kgopts'} if($kgopts ne "");

	return($zsk);
}

#######################################################################
#
# Routine:	keydirs()
#
# Purpose:	Check the validity of the key directories and move the newly
#		generated key in.  Don't do anything if the directory is '.' 
#
sub keydirs
{
	print "checking key directories\n" if($verbose > $VERBOSE_LOW);

	#
	# Ensure the KSK key directory exists and is actually a directory.
	#
	if($reuseksk != 1)
	{
		if($kskdir ne ".")
		{
			if(! -e $kskdir)
			{
				print "creating KSK directory - $kskdir\n" if($verbose);
				mkdir($kskdir);
			}
			elsif(! -d $kskdir)
			{
				print STDERR "KSK repository ($kskdir) is not a directory\n";
				exit(3);
			}
			system("$MV $ksk.* $kskdir");
		}
	}

	#
	# Ensure the ZSK key directory exists and is a directory.
	#
	if($reusezsk != 1)
	{
		if($zskdir ne ".")
		{
			if(! -e $zskdir)
			{
				print "creating ZSK directory - $zskdir\n" if($verbose);
				mkdir($zskdir);
			}
			elsif(! -d $zskdir)
			{
				print STDERR "ZSK repository ($zskdir) is not a directory\n";
				exit(3);
			}

			system("$MV $zskcur.* $zskdir");
			system("$MV $zskpub.* $zskdir");
		}
	}
}

#######################################################################
#
# Routine:	zoneincludes()
#
# Purpose:	Add include statements to the zone file for the key files.
#
sub zoneincludes
{
	my $file;				# Zone's contents.
	my $flen;				# Zone file's length.
	my $newserial;				# Zone's new serial number.

	print "adding key includes to zone file\n" if($verbose > $VERBOSE_LOW);

	#
	# Update the zone data's serial number.
	#
	$newserial = serialincr($zone);
	if($newserial == -1)
	{
		print STDERR "unable to update serial number in $zone\n";
		exit(3);
	}
	print "$zone's new serial number - $newserial\n" if($verbose > $VERBOSE_LOW);

	#
	# If there are already include lines in the zone file, we'll
	# adjust the lines to get the current files.
	#
	if(hasincludes())
	{
		my $newfile = "";		# New zone contents.
		my $tail;			# Tail end of zone searches.

		#
		# Get the data from the zone file.
		#
		seek(ZF,0,0);
		@zonestat = stat($zone);
		$flen = $zonestat[7];
		read(ZF,$file,$flen);

		#
		# Find our region of the file.  If we've messed with this
		# file once before, we'll adjust the existing lines.  If we
		# haven't, we'll get rid of any existing key inclusions and
		# then add our own.
		#
		#
		if($file =~ /manipulated by dnssec-tools./s)
		{
			$newfile = $` . $&;
			$tail = $';
		}
		else
		{
			my $incpat;			# Pattern for includes.

			#
			# Delete any existing key inclusions already in
			# the zone file.  This is just the inclusions
			# themselves; no related comments are removed.
			#
			$incpat = '\$INCLUDE.*?\.key.*?\n';
			while($file =~ /$incpat/si)
			{
				my $matchline = $&;	# Matching line.
				my $matchkey;		# Key from matchline.

				$file =~ s/$incpat//;

				if($verbose > $VERBOSE_LOW)
				{
					$matchline =~ /(".*")/;
					$matchkey = $1;
					print "deleting include line for $matchkey\n";
				}
			}

			#
			# Append our include lines to the very end of the
			# zone file.
			#
			$newfile = $file;
			$tail = getincl();
		}

		#
		# Adjust the KSK key.
		#
		$tail =~ /ksk\n/m;
		$newfile .= $` . $&;
		$tail = $';
		$tail =~ s/\$INCLUDE ".*?"/\$INCLUDE "$kskpath"/;

		#
		# Adjust the current ZSK key.
		#
		$tail =~ /current zsk\n/m;
		$newfile .= $` . $&;
		$tail = $';
		$tail =~ s/\$INCLUDE ".*?"/\$INCLUDE "$zskcurpath"/;

		#
		# Adjust the published ZSK key.
		#
		$tail =~ /published zsk\n/m;
		$newfile .= $` . $&;
		$tail = $';
		$tail =~ s/\$INCLUDE ".*?"/\$INCLUDE "$zskpubpath"/;

		#
		# ... and add the modified end of the file to our saved end.
		#
		$newfile .= $tail;

		#
		# If the new file has a length of zero, we've got a problem,
		# Houston.
		#
		if(length($newfile) == 0)
		{
			print STDERR "strange error -- the massaged zone file has a length of zero; stopping\n";
			exit(1);
		}

		#
		# Re-write the zone file.
		#
		seek(ZF,0,0);
		truncate(ZF,0);
		print ZF $newfile;
		close(ZF);

		#
		# Copy the zone data to a new file.
		#
		system("$CP $zone $zoneout") if($zone ne $zoneout);
		open(ZF,"+< $zone");
		@zonestat = stat($zone);
	}
	else
	{
		my $incstr;			# Include section.

		#
		# Copy the zone data to a new file.
		#
		system("$CP $zone $zoneout") if($zone ne $zoneout);

		#
		# Get the include-keys section.
		#
		$incstr = getincl();

		#
		# Add lines to include the KSK and ZSK files.
		#
		open(ZF,">> $zoneout");
		print ZF $incstr;

		close(ZF);
	}
}

#######################################################################
#
# Routine:	zonesign()
#
# Purpose:	Sign the zone with the new keys and ensure that the signing
#		succeeded.
#
sub zonesign
{
	my $chron;			# Today's date.
	my $ktag;			# Tag value from KSK.
	my $zcurtag;			# Tag value from current ZSK.
	my $zpubtag;			# Tag value from published ZSK.
	my $szone;			# Result from dnssec-signzone execution.
	my $cmdopts;			# Options for dnssec-signzone.
	my $status;			# Execution return code.

	#
	# Build a set of options for dnssec-signzone.  This isn't strictly
	# necessary, but it does keep the dnssec-signzone execution a bit
	# cleaner than it would be otherwise.
	#
	$cmdopts = "$szopts $gends $ksdir -k $kskpath -o $zone $enddate";

	#
	# Sign the zone with the new keys.
	#
	print "signing zone\n" if($verbose);
	print "\t$signzone $cmdopts $zoneout $zskcurpath\n" if($verbose);
	$szone = `$signzone $cmdopts $zoneout $zskcurpath`;
	if($szone eq "")
	{
		print STDERR "unable to sign zone\n";
		exit(1);
	}

	#
	# Ensure the signing succeeded.
	#
	print "checking zone\n" if($verbose);
	$status = system("$checkzone -q $zone $szone");
	if($status != 0)
	{
		print STDERR "problems with zone signing\n";
		system("$checkzone $zone $szone");
		return($status);
	}

	#
	# Add the ZSK's keyrec to the keyrec file.
	#
	updzonerec($szone);

	#
	# Get the tag values.
	#
	$ksk =~ /.*\+.*\+([0-9][0-9]*)/;
	$ktag = $1;
	$zskcur =~ /.*\+.*\+([0-9][0-9]*)/;
	$zcurtag = $1;
	$zskpub =~ /.*\+.*\+([0-9][0-9]*)/;
	$zpubtag = $1;

	#
	# Get today's date.
	#
	$chron = `$DATE +"%m/%d/%y"`;
	$chron =~ s/\n//;

	print "zone signed successfully\n\n";
	print "${zone}:\n";
	print "	ZSK (cur) $zcurtag  $zsize  $chron	KSK  $ktag  $ksize  $chron\n";
	print "	ZSK (pub) $zpubtag  $zsize  $chron\n";
	return(0);
}

#######################################################################
#
# Routine:	updzonerec()
#
# Purpose:	Add the zone's keyrec to the keyrec file.  Also, we'll add the
#		zone's name to the keyrecs of its keys.
#
sub updzonerec
{
	my $zfile = shift;			# New zone file.

	my $chronosecs;				# Current time in seconds.
	my $chronostr;				# Current time string.
	my $kr;					# Zone's keyrec reference.
	my %keyrec;				# Zone's keyrec.

	print "updating the keyrec file for the zone\n" if($verbose);

	#
	# Set some fields we've got to have -- in case they aren't
	# set in the options.
	#
	$opts{'zonefile'}     = $zoneout;
	$opts{'signedfile'}   = $zoneout . ".signed";
	$opts{'kskdirectory'} = $kskdir;
	$opts{'kskkey'}	      = $ksk;
	$opts{'kskpath'}      = $kskpath;
	$opts{'zskcur'}	      = $zskcur;
	$opts{'zskpub'}	      = $zskpub;
	$opts{'zskdirectory'} = $zskdir;
	$opts{'zskcurpath'}   = $zskcurpath;
	$opts{'zskpubpath'}   = $zskpubpath;
	$opts{'szopts'}       = $szopts if($szopts ne "");

	#
	# Get the keyrec for the zone.  If there isn't one, it's a new
	# zone and we'll create a new keyrec.
	#
	$kr = keyrec_fullrec($zone);
	if(!defined($kr))
	{
		keyrec_add('zone',$zone,\%opts);
	}
	else
	{

		#
		# If there is a keyrec for the zone, we'll make sure the
		# defined zone keyrec fields are set.
		#
		foreach my $field (keyrec_zonefields())
		{
			if(defined($opts{$field}))
			{
				keyrec_setval('zone',$zone,$field,$opts{$field});
			}
		}
	}

	#
        # Set a timestamp for the zone entry.
	#
	$chronosecs = time();
	$chronostr  = gmtime($chronosecs);
	keyrec_setval('zone',$zone,'keyrec_signsecs',$chronosecs);
	keyrec_setval('zone',$zone,'keyrec_signdate',$chronostr);

	#
	# Set the zone name in the keyrecs of our keys.
	#
	keyrec_setval('key',$ksk,'zonename',$zone);
	keyrec_setval('key',$zskcur,'zonename',$zone);
	keyrec_setval('key',$zskpub,'zonename',$zone);

	#
	# Save the keyrec file.
	#
	keyrec_write();
}

#######################################################################
#
# Routine:	hasincludes
#
# Purpose:	This routine returns a flag indicating if the zone file
#		includes any keys.
#
#		0 - zone file does not include keys
#		1 - zone file includes keys
#
sub hasincludes
{
	my $file = "";				# Contents of zone file.
	my $flen = 0;				# Length of zone file.
	my $keyname;				# Name of key from include.

	#
	# Get the zone file's length and contents.
	#
	seek(ZF,0,0);
	$flen = $zonestat[7];
	read(ZF,$file,$flen);

	#
	# Look for the key inclusion.
	#
	$file =~ /^\$INCLUDE \"(.+?)\"$/m;
	$keyname = $1;

	#
	# Give the appropriate response.
	#
	if($keyname eq "")
	{
		return(0);
	}
	return(1);
}

#######################################################################
#
# Routine:	serialincr
#
# Purpose:	This routine increments the serial number of an SOA record in
#		a zone file.  The serial number is found in both the multi-
#		line parenthesize form and the single line unparenthesize form.
#
#		On success, the new serial number is returned.
#		On failure, -1 is returned.
#
sub serialincr
{
	my $zfile = shift;			# Name of zone file.

	my $file = "";				# Contents of zone file.
	my $flen = 0;				# Length of zone file.

	my $remnant;				# Contents after the SOA line.
	my $soafields;				# SOA's fields.
	my $serialnum;				# Current serial number.
	my $serialnew;				# New serial number.

	#
	# Get the zone file's length and contents.
	#
	$flen = $zonestat[7];
	seek(ZF,0,0);
	read(ZF,$file,$flen);

	#
	# Find the SOA line and save everything after it.
	#
	$file =~ /\s+IN\s+SOA\s+/si;
	$remnant = $';

	#
	# Find the SOA's parenthesized fields.
	#
	$remnant =~ /\(.*?\)/s;
	$soafields = $&;

	#
	# Get the SOA's serial number and increment it.
	#
	$soafields =~ /([0-9]+)/;
	$serialnum = $1;

	#
	# We assumed the serial number was parenthesized.  If we didn't
	# find it, we'll look for it in an unparenthesized line.
	#
	if($serialnum eq "")
	{
		#
		# Pick up the SOA line.
		#
		$file =~ /\s+IN\s+SOA\s+/si;
		$remnant = $';

		#
		# Snork out the serial number.
		#
		$remnant =~ /\S+\s+\S+\s+(\S+)\s+/;
		$serialnum = $1;

		#
		# If we didn't find the serial number here either,
		# return a failure.
		#
		if($serialnum eq "")
		{
			return(-1);
		}
	}

	#
	# Increment the serial number and change it in the file contents.
	#
	$serialnew = $serialnum + 1;
	$file =~ s/$serialnum/$serialnew/;

	#
	# Write the new file contents and close the file.
	#
	seek(ZF,0,0);
	truncate(ZF,0);
	print ZF $file;
	close(ZF);

	#
	# Re-open the zone file with the latest info.
	#
	@zonestat = stat($zone);
	open(ZF,"+< $zone");

	return($serialnew);
}

#######################################################################
#
# Routine:	chkkrf()
#
# Purpose:	If we have a new keyrec file, we'll add a new keyrec
#		for the specified zone.  We'll set a few basic keyrec
#		files in the entry.
#
#		Condition order is important!  Don't re-arrange or condense
#		unless you know what you're doing!
#
sub chkkrf
{
	my %zoneopts;				# Initial fields for zone.

	#
	# If no keyrec file should be created, we'll return now.
	#
	if($nokrfile)
	{
		print "not using a keyrec file\n" if($verbose);
		return;
	}

	#
	# If no keyrec file was specified and we haven't been told not
	# to use a keyrec file, we'll use the default.
	#
	if($krfile eq "")
	{
		my $defkrf;			# Default keyrec file.

		#
		# Get the default keyrec file.  If there isn't one,
		# we'll use the zone name.
		#
		$defkrf = keyrec_defkrf();
		$defkrf = $zone . ".krf"  if($defkrf eq "");

		#
		# Put the default keyrec file onto the argument vector
		# and redo the argument checking.
		#
		@ARGV = @saveargs;
		unshift(@ARGV,$defkrf);
		unshift(@ARGV,"-krfile");
		print "using default keyrec file $defkrf\n" if($verbose);

		#
		# Rescan our arguments.
		#
		opts_reset();
		optsandargs();
		return;
	}

	#
	# If the keyrec file is of non-zero length, we'll return now.
	#
	if(-s $krfile)
	{
		return;
	}

	#
	# Set the basic zone keyrec fields and add the keyrec.
	#
	$zoneopts{'keyrec_type'} = "zone";
	$zoneopts{'zonefile'}	 = $zoneout;

	keyrec_add('zone',$zone,\%zoneopts);

	print "using keyrec file $krfile\n" if($verbose);
}

#######################################################################
#
# Routine:	getincl()
#
# Purpose:	Return the text used in the include lines.
#
sub getincl
{
	my $incstr;				# Include section.

	$incstr = <<EOF;

;;
;;
;; DO NOT DIRECTLY MODIFY ANYTHING BELOW THIS LINE.
;;
;;	All subsequent lines are added and manipulated by dnssec-tools.
;;

;; ksk
\$INCLUDE \"$kskpath\"

;; current zsk
\$INCLUDE \"$zskcurpath\"

;; published zsk
\$INCLUDE \"$zskpubpath\"

EOF

	return($incstr);
}

#######################################################################
#
# Routine:	forceroll()
#
# Purpose:	Force a roll-over of the ZSK keys.  The current ZSK is
#		marked as obsolete.  The published ZSK is moved to being
#		the current ZSK.  If the zone has a new ZSK, it is
#		moved to being the published ZSK; if not, a new published
#		ZSK is generated.  Finally, a new ZSK is generated.
#
#		This functionality is not documented in the zonesigner pod.
#		This should only be used if you know what you're doing.
#
sub forceroll
{
	my $zsknew;				# Name of new ZSK key.
	my $zskkey;				# ZSK key.
	my $krref;				# Reference to Key's keyrec.

	print "\tforcing a key roll-over\n" if($verbose);

	#
	# Get rid of any reusable ZSKs.  We're rolling them over, so
	# by definition some ZSKs are reused and some are not.
	#
	$reusezsk = 0;

	#
	# Ensure that a roll-over makes sense.
	#
	if($opts{'zskpub'} eq "")
	{
		print STDERR "zone $zone has no published ZSK to roll-over to a current ZSK\n";
		exit(1);
	}

	#
	# Render the current ZSK obsolete.
	#
	$krref = keyrec_fullrec($opts{'zskcur'});
	$krref->{'keyrec_type'} = "zskobs";
	keyrec_setval("key",$krref->{'keyrec_name'},"keyrec_type","zskobs");
	print "\tcurrent ZSK ($krref->{'keyrec_name'}) now obsolete\n" if($verbose > $VERBOSE_LOW);

	#
	# Convert the published ZSK into the current ZSK.
	#
	$krref = keyrec_fullrec($opts{'zskpub'});
	$krref->{'keyrec_type'} = 'zskcur';
	$opts{'zskcur'} = $krref->{'keyrec_name'};
	$zskcur = $krref;
	$zskcur = $opts{'zskcur'};
	keyrec_setval("key",$zskcur,"keyrec_type","zskcur");
	print "\tpublished ZSK ($krref->{'keyrec_name'}) now current\n" if($verbose > $VERBOSE_LOW);

	#
	# If we have a new ZSK, we'll make that the current published ZSK.
	# If not, we'll generate a published ZSK.
	#
	if(defined($opts{'zsknew'}))
	{
		$krref = keyrec_fullrec($opts{'zsknew'});
		$krref->{'keyrec_type'} = "zskpub";
		$opts{'zskpub'} = $krref->{'keyrec_name'};
		$zskpub = $krref;
		$zskpub = $opts{'zskpub'};

		print "\tnew ZSK ($krref->{'keyrec_name'}) now published\n" if($verbose > $VERBOSE_LOW);
	}
	else
	{
		$zskpub = genzsk("pub");
		$krref = keyrec_fullrec($opts{'zskpub'});
		$opts{'zskpub'} = $krref->{'keyrec_name'};

		print "\tpublished ZSK ($krref->{'keyrec_name'}) created\n" if($verbose > $VERBOSE_LOW);
	}

	keyrec_setval("key",$zskpub,"keyrec_type","zskpub");

	#
	# Generate a new ZSK.
	#
	$zsknew = genzsk("new");
	print "\tnew ZSK ($zsknew) created\n" if($verbose > $VERBOSE_LOW);
	keyrec_setval("key",$zsknew,"keyrec_type","zsknew");
}

#######################################################################
#
# Routine:	usage()
#
# Purpose:	Give usage message and exit.
#
sub usage
{
	my $whence = shift;			# Location of call.

	print STDERR "usage:  zonesigner [options] <zone-file> <zone-out>\n";
	print STDERR "\n";

	print STDERR "\t\tzonesigner options:\n";
	print STDERR "\t\t\t-nokrfile\n";
	print STDERR "\t\t\t-krfile keyrec-file\n";
	print STDERR "\t\t\t-reuseksk\n";
	print STDERR "\t\t\t-reusezsk\n";
	print STDERR "\t\t\t-zone zone-name\n";
	print STDERR "\t\t\t-help\n";
	print STDERR "\t\t\t-verbose\n";
	print STDERR "\n";

	print STDERR "\t\tdnssec-keygen options:\n";
	print STDERR "\t\t\t-algorithm algorithm\n";
	print STDERR "\t\t\t-ksklength KSK-size\n";
	print STDERR "\t\t\t-zsklength ZSK-size\n";
	print STDERR "\t\t\t-random random-path\n";
	print STDERR "\t\t\t-kgopts dnssec-keygen-options\n";
	print STDERR "\n";

	print STDERR "\t\tdnssec-signzone options:\n";
	print STDERR "\t\t\t-endtime end-time\n";
	print STDERR "\t\t\t-gends\n";
	print STDERR "\t\t\t-ksdir keyset-directory\n";
	print STDERR "\t\t\t-szopts dnssec-signszone-options\n";
	print STDERR "\n";

#	print "\ncalled from $whence\n" if($verbose && ($whence > 0));

	exit(1);
}

1;

##############################################################################
#

=pod

=head1 NAME

zonesigner - Check a B<dnssec-tools> I<keyrec> file for problems and
consistencies.

=head1 SYNOPSIS

  zonesigner [options] <zone-file> <zone-out>

=head1 DESCRIPTION

This script combines into a single command many actions that are required to
sign a zone.  It generates the required KSK and ZSK keys, adds the key data
to a zone file, signs the zone, and runs checks to ensure that everything
worked properly.

Using I<keyrec> files, defined and maintained by B<dnssec-tools>,
I<zonesigner> can automatically gather many of the options used to previously
sign and generate a zone and its keys.  This allows the zone to be maintained
using the same key lengths and expiration times, for example, without an
administrator needing to manually track these fields.

I<zonesigner> is used in this way:

=over 4

zonesigner [options] <zone-name> <zone-out>

=back

I<zone-name> is the name of the zone that will be signed and the name of the
zone file from which a signed zone file will be created.  This may also be
specified with the I<-zone> option.  Several $INCLUDE lines will be added at
the end and the SOA serial number will be incremented.  Generated keys are
given this name as their base.

I<zone-out> is the name of the output zone file.  This file will be a copy
of the I<zone-file> zone file.  The signed zone file will be this name,
appended with I<.signed>.

The I<zone-out> argument may be left out, in which case the input zone file
will be used as the base for all operations. 

I<keyrec> files retain information about previous key-generation and
zone-signing operations.  If a I<keyrec> file is not specified (by way of the
I<-krfile> option), then a default I<keyrec> file is used.  If this default
in not specified in the system's B<dnssec-tools> configuration file, the name
B<default.krf> will be used.  If the I<-nokrfile> option is given, then no
I<keyrec> file will be consulted or saved.

The zone file is modified to have include commands, which will include the
KSK and ZSK keys.  These lines are placed at the end of the file and should
not be modified by the user.  If the zone file already includes any key files,
those inclusions will be deleted.  These lines are distinguished by starting
with "$INCLUDE" and end with ".key".  Only the actual include lines are
deleted; any related comment lines are left untouched.

=head1 OPTIONS

Three types of options may be given, based on the command for which they are
intended.  These commands are  I<dnssec-keygen>,
I<dnssec-signzone>, and I<zonesigner>.

=head2 I<zonesigner>-specific Options

=over 4

=item -nokrfile

No I<keyrec> file will be consulted or created.

=item -krfile

I<keyrec> file to use in processing options.  See the man page for
I<Net::DNS::SEC::Tools::tooloptions> for more details about this file.

=item -reuseksk

Re-use the zone's current KSK.

=item -reusezsk

Re-use the zone's current ZSK.

=item -zone

Name of the zone that will be signed.  This zone name may be given with this
option or as the first non-option command line argument.

=item -help

Display a usage message.

=item -verbose

Verbose output will be given.  As more instances of I<-verbose> are given on
the command line, additional levels of verbosity are achieved.

=back

=head2 I<dnssec-keygen>-specific Options

=over 4

=item -algorithm

Cryptographic algorithm used to generate the zone's keys.
The default value is RSASHA1.

=item -ksklength

Bit length of the zone's KSK key.
The default is 1024.

=item -random

Source of randomness used to generate the zone's keys.	(/dev/urandom)

=item -zsklength

Bit length of the zone's ZSK key.
The default is 512.

=item -kgopts

Additional options for I<dnssec-keygen> may be specified using this option.
The additional options are passed as a single string value as an argument to
the I<-kgopts> option.

=back

=head2 I<dnssec-signzone>-specific Options

=over 4

=item -endtime

Time that the zone expires, measured in seconds.  See the man page for
I<dnssec-signzone> for the valid format of this field.
The default value is 259200 seconds (30 days.)

=item -gends

Force I<dnssec-signzone> to generate DS records for the zone.  This option is
translated into I<-g> when passed to I<dnssec-signzone>.

=item -ksdir

Specify a directory for storing keysets.  This is passed to I<dnssec-signzone>
as the I<-d> option.

=item -szopts

Additional options for I<dnssec-signzone> may be specified using this option.
The additional options are passed as a single string value as an argument to
the I<-szopts> option.

=back

=head1 Examples

Example 1.

In the first example, an existing I<keyrec> file is used to assist in signing
the portrigh.com domain.  Zone data are stored in B<portrigh.com>, and the
keyrec is in B<portrigh.keyrec>.  The output zone file and final signed zone
file will use B<db.portrigh.com> as a base.  Using this execution:

    # zonesigner -krfile portrigh.keyrec portrigh.com db.portrigh.com

the following files are created:

    Kportrigh.com.+005+45842.private
    Kportrigh.com.+005+45842.key
    Kportrigh.com.+005+50186.private
    Kportrigh.com.+005+50186.key
    Kportrigh.com.+005+59143.key
    Kportrigh.com.+005+59143.private

    dsset-portrigh.com.
    keyset-portrigh.com.

    db.portrigh.com
    db.portrigh.com.signed


The first six files are the KSK and ZSK keys required for the zone.  The next
two files are created by the zone-signing process.  The last two are the zone
file used as input to the zone-signing process and the final signed zone.

Example 2.

In the second example, an existing I<keyrec> file is used to assist in signing
the portrigh.com domain.  Zone data are stored in B<portrigh.com>, and the
keyrec is in B<portrigh.keyrec>.  The generated keys, output zone file, and
final signed zone file will use B<portrigh.com> as a base.  Using this
execution:

    # zonesigner -krfile portrigh.keyrec db.portrigh.com

the following files are created:

    Kdb.portrigh.com.+005+12354.key
    Kdb.portrigh.com.+005+12354.private
    Kdb.portrigh.com.+005+82197.key
    Kdb.portrigh.com.+005+82197.private
    Kdb.portrigh.com.+005+55888.key
    Kdb.portrigh.com.+005+55888.private

    dsset-db.portrigh.com.
    keyset-db.portrigh.com.

    db.portrigh.com.signed

The first six files are the KSK and ZSK keys required for the zone.  The next
two files are created by the zone-signing process.  The last file is file is
the final signed zone.

=head1 AUTHOR

Wayne Morrison, tewok@users.sourceforge.net

=head1 SEE ALSO

Net::DNS::SEC::Tools::conf.pm(3), Net::DNS::SEC::Tools::keyrec.pm(3), Net::DNS::SEC::Tools::tooloptions.pm(3)

=cut
