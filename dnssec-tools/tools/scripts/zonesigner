#!/usr/bin/perl
#
# Copyright 2005 SPARTA, Inc.  All rights reserved.  See the COPYING
# file distributed with this software for details
#
# zonesigner
#
#	This script combines a lot of actions required to sign a zone into a
#	single command.  The command is used in this way:
#
#		zonesigner [options] <zone> <zoneout>
#
#		where:
#			zone	 - the input zone file to be signed.  This is
#				   a zone file to which the $INCLUDE ksk and
#				   $INCLUDE zsk lines are added
#			zoneout	 - the name of the output zone file
#
#
#	Options are described in the POD at the end of this file.
#

use strict;

use Net::DNS::SEC::Tools::keyrec;
use Net::DNS::SEC::Tools::timetrans;
use Net::DNS::SEC::Tools::tooloptions;

#
# Verbose values.
#
my $VERBOSE_LOW	   = 1;			# Lowest verbosity level.
my $VERBOSE_MEDIUM = 2;			# Middlin' verbosity level.
my $VERBOSE_HIGH   = 3;			# High verbosity level.

#
# Set some path variables.
#
my $CP		= "/bin/cp";
my $DATE	= "/bin/date";
my $MKDIR	= "/bin/mkdir";
my $MV		= "/bin/mv";

#
# Default names for the dnssec- commands.
#
my $DEF_CHECKZONE	= "named-checkzone";
my $DEF_KEYGEN		= "dnssec-keygen";
my $DEF_SIGNZONE	= "dnssec-signzone";

#
# Default arguments to zonesigner and dnssec-* commands.
#
my $DEF_ALGORITHM	= "rsasha1";		# Encryption algorithm.
my $DEF_ENDDATE		= "+604800";		# Zone life, in seconds.
my $DEF_ENTROPYMSG	= 1;			# Display of entropy message.
my $DEF_KSKLENGTH	= 1024;			# Length of KSK key.
my $DEF_RANDOM		= "/dev/urandom";	# Random no. generator device.
my $DEF_REUSEKSK	= 0;			# Re-use KSK.
my $DEF_REUSEZSK	= 0;			# Re-use ZSK.
my $DEF_SAVEKEYS	= 0;			# Archive keys.
my $DEF_ZSKLENGTH	= 1024;			# Length of ZSK key.

#
# Arguments for updzonerec().
#
my $UPD_ALLKEYS	= 1;				# Update all keyrecs.
my $UPD_KSK	= 2;				# Only update KSK keyrec.
my $UPD_ZSK	= 3;				# Only update ZSK keyrec.

#
# Options fields.
#
my $alg;				# Encryption algorithm.
my $enddate;				# End-time for zone signing.
my $entropymsg = $DEF_ENTROPYMSG;	# Display flag for entropy message.
my $gends;				# Generate DS records in zone signing.
my $help = 0;				# Help flag.
my $kgopts;				# Additional dnssec-keygen options.
my $ksdir;				# Directory to hold keysets.
my $ksize;				# Size of KSK.
my $kskdir;				# Directory to hold KSK.
my $nokrfile;				# Flag for not using a keyrec file.
my $random;				# Random number generation method.
my $szopts;				# Additional dnssec-signzone options.
my $verbose = 0;			# Turn off verbosity.
my $zsize;				# Size of ZSK.
my $zskdir;				# Directory to hold ZSK.

my $archdir;				# Archive directory for old keys.
my $savekeys = 0;			# Flag for saving old keys.

my $ksk;				# KSK we've generated.
my $kskpath;				# Path to the KSK.
my $genksk;				# Generate a new KSK.

my $zskcur;				# Current ZSK.
my $zskpub;				# Published ZSK.
my $zskcurpath;				# Path to the published KSK.
my $zskpubpath;				# Path to the current KSK.
my $genzsk;				# Generate a new ZSK.

my $zone;				# Zone to play with.
my $zonefile;				# Input zone file.
my $zoneout;				# Output zone file.
my $krfile;				# User-specified keyrec file.

my $status;				# Zone-signing status.
my @zonestat;				# stat() buffer for zone file.

#
# Some path variables to be set from the config file.
#
my $checkzone;
my $keygen;
my $signzone;

my %opts;				# Options.
our @saveargs = @ARGV;			# Copy of argument vector.

#
# Zonesigner-specific command line arguments.
#
my @zsopts = ( '',
	       ['GUI:separator',	'Tool specific options:'],
	       ["forceroll",		'Force the roll-over of zone keys']
	     );

my $forceroll = 0;			# Force-a-roll-over flag.


#
# Do our work.
#
$status = main();
exit($status);

#######################################################################
#
# Routine:	main()
#
# Purpose:	Yeah, yeah, a main() isn't necessary.  However, it offends my
#		sense of aesthetics to have great gobs of code on the same
#		level as a pile of globals.
#
#		But what about all those globals, you ask...
#
sub main
{
	my $statlen;				# Length of stat() buffer.
	my $status;				# Status of zone-signing.

	#
	# If help was specified, give the usage and exit.
	#
	helpchk();

	#
	# Munch on the options and arguments.  Print out our options,
	# according to our verbosity level.
	#
	optsandargs();
	printopts();

	#
	# If help was specified, give the usage and exit.
	#
	if($help == 1)
	{
		usage(1);
	}

	#
	# Ensure that the required data were specified.
	#
	if(($zone eq "") || ($zonefile eq "") || ($zoneout eq ""))
	{
		print STDERR "no zone specified\n";
		usage(2);
	}

	#
	# Ensure the zone file is okay before proceeding.
	#
	vprint("initial zone verification\n");
	$status = system("$checkzone -q $zone $zonefile");
	if($status != 0)
	{
		$status = system("$checkzone $zone $zonefile");
		exit($status);
	}
	vmed_print("zone verified\n\n");

	#
	# Ensure that the zone file exists and open it.
	#
	$statlen = @zonestat = stat($zonefile);
	if($statlen == 0)
	{
		print STDERR "zone file $zonefile does not exist\n";
		exit(1);
	}
	open(ZF,"+< $zonefile") or die "unable to open zone file $zonefile";

	#
	# Ensure that the zone file has not been signed yet.
	#
	if(presigned())
	{
		print STDERR "zone file $zonefile already signed\n";
		exit(1);
	}

	#
	# Generate the KSK and ZSK key files.
	#
	genkeys();

	#
	# Create the key directories and move the key files into the
	# appropriate repositories.
	#
	keydirs();

	#
	# Set some short-hand variables.
	#
	$kskpath    = "$kskdir/$ksk.key";
	$zskcurpath = "$zskdir/$zskcur.key";
	$zskpubpath = "$zskdir/$zskpub.key";

	#
	# Create the unsigned zone file and add include lines for the key files.
	#
	zoneincludes();

	#
	# Sign the zone with the new keys and ensure the signing succeeded.
	#
	$status = zonesign();
	return($status);
}

#######################################################################
#
# Routine:	optsandargs()
#
# Purpose:	Parse the command line for options and arguments.
#
sub optsandargs()
{
	my $argc;			# Number of arguments.
	my $ropts;			# Reference to the option hash.

	vprint("checking options and arguments\n");

	#
	# Make sure we have arguments.
	#
	$argc = @ARGV;
	usage(3) if($argc == 0);

	#
	# Set the options, try to use the config file, the command line
	# options and a keyrec file.  We'll take the following steps in
	# trying to get a good set of options.
	#
	#  1. Set options from config file, command line, and a keyrec.
	#     Look in the options for -krfile and -keyrec to find the keyrec.
	#  2. Set options from config file, command line, and a keyrec.
	#     Use our first argument is a zone name, and assume there's
	#     a -krfile.  (Previous step showed there isn't a -keyrec.)
	#  3. Set options from the config file and command line.  No keyrec
	#     will be used.
	#
	opts_setcsopts(@zsopts);
	opts_createkrf();
	$ropts = opts_zonekr();
	if($ropts == undef)
	{
		$zonefile = $ARGV[0];
		$ropts = opts_zonekr("",$zonefile);
		if($ropts == undef)
		{
			$ropts = tooloptions("","");
		}
	}
	if($ropts != undef)
	{
		%opts = %$ropts;
	}

	#
	# Get the KSK- and ZSK-related arguments.
	#
	$ksize	  = $opts{'ksklength'}	  || $DEF_KSKLENGTH;
	$zsize	  = $opts{'zsklength'}	  || $DEF_ZSKLENGTH;
	$kskdir	  = $opts{'kskdirectory'} || '.';
	$zskdir	  = $opts{'zskdirectory'} || '.';
	$kskpath  = $opts{'kskpath'}	  || "";
	$genksk	  = $opts{'genksk'}	  || $DEF_REUSEKSK;
	$genzsk	  = $opts{'genzsk'}	  || $DEF_REUSEZSK;

	#
	# Get the rest of the options.
	#
	$alg	  = $opts{'algorithm'}	|| $DEF_ALGORITHM;
	$archdir  = $opts{'archivedir'}	|| "";
	$enddate  = $opts{'endtime'}	|| $DEF_ENDDATE;
	$gends	  = $opts{'gends'}	|| "";
	$random   = $opts{'random'}	|| $DEF_RANDOM;
	$kgopts   = $opts{'kgopts'}	|| "";
	$ksdir	  = $opts{'ksdir'}	|| "";
	$savekeys = $opts{'savekeys'}	|| $DEF_SAVEKEYS;
	$szopts   = $opts{'szopts'}	|| "";
	$krfile   = $opts{'krfile'}	|| "";
	$nokrfile = $opts{'nokrfile'}	|| "";
	$zone	  = $opts{'zone'};

	#
	# If -genkeys was given, then we'll set -genksk and -genzsk.
	#
	if(defined($opts{'genkeys'}))
	{
		$genksk = 1;
		$genzsk = 1;
	}

	#
	# Check for the key roll-over flag.
	#
	$forceroll = 0;
	if(defined($opts{'forceroll'}))
	{
		$forceroll = 1;
	}

	#
	# Set up options and values, saving to global scalars and also
	# saving to %opts for use when saving the new keyrec.
	#
	if($ksize ne "")
	{
		$opts{'ksklength'} = $ksize;
		$ksize = "-b $ksize";
	}

	if($zsize ne "")
	{
		$opts{'zsklength'} = $zsize;
		$zsize = "-b $zsize";
	}

	if($alg ne "")
	{
		$opts{'algorithm'} = $alg;
		$alg = "-a $alg";
	}

	if($enddate ne "")
	{
		$opts{'enddate'} = $enddate;
		$enddate = "-e $enddate";
	}

	if($ksdir ne "")
	{
		$opts{'ksdir'} = $ksdir;
		$ksdir = "-d $ksdir";
	}

	if($random ne "")
	{
		$opts{'random'} = $random;
		$random = "-r $random";
	}

	$gends	 = "-g"		 if($gends ne "");

	#
	# Ensure that the ZSK archive directory is a real directory,
	# if it already exists.
	#
	if($archdir ne "")
	{
		if((-e $archdir) && (! -d $archdir))
		{
			print STDERR "ZSK archive directory $archdir is not a directory\n";
			exit(1);
		}
	}

	#
	# Set up flags for various helpful messages.
	#
	if(defined($opts{'entropy_msg'}))
	{
		$entropymsg = $opts{'entropy_msg'};
	}
	$help	 = $opts{'help'};
	$verbose = $opts{'verbose'};


	#
	# Get the paths to the external commands.  If they aren't defined,
	# use the default command names.
	#
	$checkzone  = $opts{'checkzone'}   || $DEF_CHECKZONE;
	$keygen	    = $opts{'keygen'}	   || $DEF_KEYGEN;
	$signzone   = $opts{'signzone'}	   || $DEF_SIGNZONE;

	#
	# Ensure that we were given the zone file and the zone output file.
	#
	$argc = @ARGV;
	usage(4) if($argc != 2);

	#
	# Set variables for the arguments.
	#
	$zonefile = $ARGV[0];
	$zoneout  = $ARGV[1];

	#
	# If the -zone option wasn't specified, we'll use the zone filename
	# as the zone name.
	#
	if(!defined($opts{'zone'}))
	{
		$zone = $zonefile;
		$opts{'zone'} = $zonefile;
	}

	#
	# If the keyrec file is empty, we'll create a keyrec for
	# the zone.
	#
	chkkrf();

	#
	# Ensure that two mutually exclusive keyrec file options aren't given.
	#
	if(defined($opts{'krfile'}) && defined($opts{'nokrfile'}))
	{
		print STDERR "-krfile and -nokrfile are mutually exclusive\n";
		usage(5);
	}
}

#######################################################################
#
# Routine:	presigned()
#
# Purpose:	Ensure that the specified zone file is not a signed zone file.
#		We'll check for the presence of a signed-specific record.
#
#		Returns:
#			0 - Zone not previously signed.
#			1 - Zone previously signed.
#
sub presigned
{
	my $file = "";				# Contents of zone file.
	my $flen = 0;				# Length of zone file.
	my $hitcnt;				# Number of RRSIGs in file.
	my @hits;				# RRSIG hits.

	#
	# Get the zone file's length and contents.
	#
	$flen = $zonestat[7];
	seek(ZF,0,0);
	read(ZF,$file,$flen);

	$hitcnt = @hits = $file =~ /RRSIG/mg;

	#
	# If we found some RRSIG records, return a true value.  If not,
	# return a false value.
	#
	if($hitcnt > 0)
	{
		return(1);
	}
	return(0);
}

#######################################################################
#
# Routine:	genkeys()
#
# Purpose:	Generate new KSK and ZSK keys.  New keyrecs for the new keys
#		are added to the keyrec file.
#
sub genkeys
{
	vprint("generating key files\n");

	#
	# Generate the KSK key.
	#
	genksk();

	#
	# Generate the ZSK keys.
	#
	if($forceroll)
	{
		forceroll();
	}
	else
	{
		$zskcur = genzsk("cur");
		$zskpub = genzsk("pub");

		#
		# Save the keyrec file.
		#
		updzonerec($UPD_ZSK);

	}

	vmed_print("\n");
}

#######################################################################
#
# Routine:	genksk()
#
# Purpose:	Generate a new KSK key.
#
sub genksk
{
	my $cmdopts;			# Options for dnssec-keygen.
	my $zskdir;			# ZSK directory for saving.

	#
	# If we're reusing the KSK, ensure it's been created and return.
	#
	if($genksk == 0)
	{
		if($opts{'kskkey'} eq "")
		{
			print STDERR "\nunable to re-use a non-existent KSK\n";
			exit(1);
		}

		$ksk = $opts{'kskkey'};
		vprint("reusing existing KSK - $ksk\n");

		return;
	}

	vmed_print("generating new KSK\n");

	#
	# Generate the new KSK.
	#
	$cmdopts = "$kgopts $random $alg $ksize";
	vhigh_print("$keygen $cmdopts -n zone -f KSK $zone\n");
	$ksk = `$keygen $cmdopts -n zone -f KSK $zone`;
	if($? != 0)
	{
		print STDERR "unable to generate KSK key file;\n";
		print STDERR "dnssec-keygen returned $?\n" if($verbose);
		exit(1);
	}
	chomp $ksk;
	vmed_print("new KSK - $ksk\n\n");

	#
	# Save the ZSK directory.
	#
	$zskdir = $opts{'zskdirectory'};
	delete $opts{'zskdirectory'};

	#
	# Add the KSK's keyrec to the keyrec file.
	#
	$opts{'keyrec_type'} = "ksk";
	$opts{'keypath'}     = "$kskdir/$ksk.key";
	$opts{'kgopts'}      = $kgopts if($kgopts ne "");
	keyrec_add('key',$ksk,\%opts);

	#
	# Restore the ZSK directory and dump the keyrec type.
	#
	$opts{'zskdirectory'} = $zskdir;
	delete $opts{'keyrec_type'};

	#
	# Save the keyrec file.
	#
	updzonerec($UPD_KSK);
}

#######################################################################
#
# Routine:	genzsk()
#
sub genzsk
{
	my $cmdopts;			# Options for dnssec-keygen.
	my $keytype = shift;		# ZSK type:  cur, new, pub.
	my $kskdir;			# KSK directory for saving.
	my $zskkey;			# Hash key for this ZSK.
	my $zsk;			# Generated key.

	#
	# Get the hash key for the ZSK we're going to generate.
	#
	$zskkey = "zsk" . $keytype;

	#
	# If we're reusing the ZSK, ensure it's already defined and return.
	#
	if($genzsk == 0)
	{
		if(keyrec_fullrec($opts{$zskkey}) eq "")
		{
			print STDERR "\n$keytype ZSK keyrec does not exist; unable to re-use non-existent $keytype ZSK\n";
			exit(1);
		}

		$zsk = $opts{$zskkey};
		vprint("reusing existing $keytype ZSK - $zsk\n");

		return($zsk);
	}
	
	vmed_print("generating new \"$keytype\" ZSK\n");

	#
	# Generate a ZSK key.
	#
	$cmdopts = "$kgopts $random $alg $zsize";
	vhigh_print("$keygen $cmdopts -n zone $zone\n");
	$zsk = `$keygen $cmdopts -n zone $zone`;
	if($? != 0)
	{
		print STDERR "unable to generate $keytype ZSK key file;\n";
		print STDERR "dnssec-keygen returned $?\n" if($verbose > $VERBOSE_LOW);
		exit(1);
	}
	chomp $zsk;
	vmed_print("new \"$keytype\" ZSK - $zsk\n");

	#
	# Save the KSK directory.
	#
	$kskdir = $opts{'kskdirectory'};
	delete $opts{'kskdirectory'};

	#
	# Add the ZSK's keyrec to the keyrec file.
	#
	$opts{'keyrec_type'} = "$zskkey";
	$opts{'keypath'}     = "$zskdir/$zsk.key";
	$opts{'kgopts'}	     = $kgopts if($kgopts ne "");
	keyrec_add('key',$zsk,\%opts);
	$opts{"$zskkey"} = $zsk;

	#
	# Restore the KSK directory and dump the keyrec type.
	#
	$opts{'kskdirectory'} = $kskdir;
	delete $opts{'keyrec_type'};
	delete $opts{'kgopts'} if($kgopts ne "");

	return($zsk);
}

#######################################################################
#
# Routine:	keydirs()
#
# Purpose:	Check the validity of the key directories and move the newly
#		generated key in.  Don't do anything if the directory is '.' 
#
sub keydirs
{
	vmed_print("checking key directories\n");

	#
	# Ensure the KSK key directory exists and is actually a directory.
	#
	if($genksk)
	{
		if($kskdir ne ".")
		{
			if(! -e $kskdir)
			{
				vprint("creating KSK directory - $kskdir\n");
				mkdir($kskdir);
			}
			elsif(! -d $kskdir)
			{
				print STDERR "KSK repository ($kskdir) is not a directory\n";
				exit(3);
			}
			system("$MV $ksk.* $kskdir");
		}
	}

	#
	# Ensure the ZSK key directory exists and is a directory.
	#
	if($genzsk)
	{
		if($zskdir ne ".")
		{
			if(! -e $zskdir)
			{
				vprint("creating ZSK directory - $zskdir\n");
				mkdir($zskdir);
			}
			elsif(! -d $zskdir)
			{
				print STDERR "ZSK repository ($zskdir) is not a directory\n";
				exit(3);
			}

			system("$MV $zskcur.* $zskdir");
			system("$MV $zskpub.* $zskdir");
		}
	}

	vmed_print("\n");
}

#######################################################################
#
# Routine:	zoneincludes()
#
# Purpose:	Add include statements to the zone file for the key files.
#
sub zoneincludes
{
	my $file;				# Zone's contents.
	my $flen;				# Zone file's length.
	my $newserial;				# Zone's new serial number.

	vhigh_print("\n");
	vprint("adding key includes to zone file\n");

	#
	# Update the zone data's serial number.
	#
	$newserial = serialincr();
	if($newserial == -1)
	{
		print STDERR "unable to update serial number in $zonefile\n";
		exit(3);
	}
	vmed_print("$zone\'s new serial number - $newserial\n\n");

	#
	# If there are already include lines in the zone file, we'll
	# adjust the lines to get the current files.
	#
	if(hasincludes())
	{
		my $newfile = "";		# New zone contents.
		my $tail;			# Tail end of zone searches.

		#
		# Get the data from the zone file.
		#
		seek(ZF,0,0);
		@zonestat = stat($zonefile);
		$flen = $zonestat[7];
		read(ZF,$file,$flen);

		#
		# Find our region of the file.  If we've messed with this
		# file once before, we'll adjust the existing lines.  If we
		# haven't, we'll get rid of any existing key inclusions and
		# then add our own.
		#
		#
		if($file =~ /manipulated by dnssec-tools./s)
		{
			$newfile = $` . $&;
			$tail = $';
		}
		else
		{
			my $incpat;			# Pattern for includes.

			#
			# Delete any existing key inclusions already in
			# the zone file.  This is just the inclusions
			# themselves; no related comments are removed.
			#
			$incpat = '\$INCLUDE.*?\.key.*?\n';
			while($file =~ /$incpat/si)
			{
				my $matchline = $&;	# Matching line.
				my $matchkey;		# Key from matchline.

				$file =~ s/$incpat//;

				if($verbose > $VERBOSE_LOW)
				{
					$matchline =~ /(".*")/;
					$matchkey = $1;
					print "deleting include line for $matchkey\n";
				}
			}

			#
			# Append our include lines to the very end of the
			# zone file.
			#
			$newfile = $file;
			$tail = getincl();
		}

		#
		# Adjust the KSK key.
		#
		$tail =~ /ksk\n/m;
		$newfile .= $` . $&;
		$tail = $';
		$tail =~ s/\$INCLUDE ".*?"/\$INCLUDE "$kskpath"/;

		#
		# Adjust the current ZSK key.
		#
		$tail =~ /current zsk\n/m;
		$newfile .= $` . $&;
		$tail = $';
		$tail =~ s/\$INCLUDE ".*?"/\$INCLUDE "$zskcurpath"/;

		#
		# Adjust the published ZSK key.
		#
		$tail =~ /published zsk\n/m;
		$newfile .= $` . $&;
		$tail = $';
		$tail =~ s/\$INCLUDE ".*?"/\$INCLUDE "$zskpubpath"/;

		#
		# ... and add the modified end of the file to our saved end.
		#
		$newfile .= $tail;

		#
		# If the new file has a length of zero, we've got a problem,
		# Houston.
		#
		if(length($newfile) == 0)
		{
			print STDERR "strange error -- the massaged zone file has a length of zero; stopping\n";
			exit(1);
		}

		#
		# Re-write the zone file.
		#
		seek(ZF,0,0);
		truncate(ZF,0);
		print ZF $newfile;
		close(ZF);

		#
		# Copy the zone data to a new file.
		#
		system("$CP $zonefile $zoneout") if($zonefile ne $zoneout);
		open(ZF,"+< $zonefile");
		@zonestat = stat($zonefile);
	}
	else
	{
		my $incstr;			# Include section.

		#
		# Copy the zone data to a new file.
		#
		system("$CP $zonefile $zoneout") if($zonefile ne $zoneout);

		#
		# Get the include-keys section.
		#
		$incstr = getincl();

		#
		# Add lines to include the KSK and ZSK files.
		#
		open(ZF,">> $zoneout");
		print ZF $incstr;

		close(ZF);
	}
}

#######################################################################
#
# Routine:	zonesign()
#
# Purpose:	Sign the zone with the new keys and ensure that the signing
#		succeeded.
#
sub zonesign
{
	my $chron;			# Today's date.
	my $ktag;			# Tag value from KSK.
	my $zcurtag;			# Tag value from current ZSK.
	my $zpubtag;			# Tag value from published ZSK.
	my $szone;			# Result from dnssec-signzone execution.
	my $cmdopts;			# Options for dnssec-signzone.
	my $status;			# Execution return code.

	#
	# Build a set of options for dnssec-signzone.  This isn't strictly
	# necessary, but it does keep the dnssec-signzone execution a bit
	# cleaner than it would be otherwise.
	#
	$cmdopts = "$szopts $gends $ksdir -k $kskpath -o $zone $enddate";

	#
	# Sign the zone with the new keys.
	#
	vprint("signing zone\n");

	#
	# Maybe display the warning about potential entropy hangs.
	#
	if($entropymsg)
	{
		print "if zonesigner appears hung, strike keys until the program completes\n";
		print "(see the \"Entropy\" section in the man page for details)\n\n";
	}

	vhigh_print("$signzone $cmdopts $zoneout $zskcurpath\n");
	$szone = `$signzone $cmdopts $zoneout $zskcurpath`;
	if($szone eq "")
	{
		print STDERR "unable to sign zone\n";
		exit(1);
	}

	#
	# Ensure the signing succeeded.
	#
	vprint("checking zone\n");
	$status = system("$checkzone -q $zone $szone");
	if($status != 0)
	{
		print STDERR "problems with zone signing\n";
		system("$checkzone $zone $szone");
		return($status);
	}

	#
	# Add the ZSK's keyrec to the keyrec file.
	#
	updzonerec($UPD_ALLKEYS);

	#
	# Get the tag values.
	#
	$ksk =~ /.*\+.*\+([0-9][0-9]*)/;
	$ktag = $1;
	$zskcur =~ /.*\+.*\+([0-9][0-9]*)/;
	$zcurtag = $1;
	$zskpub =~ /.*\+.*\+([0-9][0-9]*)/;
	$zpubtag = $1;

	#
	# Get today's date.
	#
	$chron = `$DATE +"%m/%d/%y"`;
	$chron =~ s/\n//;

	#
	# Give success message and zone info.
	#
	print "\nzone signed successfully\n\n";
	print "${zone}:\n";
	print "	ZSK (cur) $zcurtag  $zsize  $chron	KSK  $ktag  $ksize  $chron\n";
	print "	ZSK (pub) $zpubtag  $zsize  $chron\n";

	#
	# Inform user when the zone will expire.
	#
	if($enddate)
	{
		my $edcopy = $enddate;		# Copy of the zone end date.
		my $datestr;			# Translated end date.

		$edcopy =~ s/^\-e \+//;
		$datestr = timetrans($edcopy);

		print "\n";
		print "zone will expire in $datestr\n";
		print "DO NOT delete the keys until this time has passed.\n";
	}
	return(0);
}

#######################################################################
#
# Routine:	updzonerec()
#
# Purpose:	Add the zone's keyrec to the keyrec file.  Also, we'll add the
#		zone's name to the keyrecs of its keys.
#
sub updzonerec
{
	my $updflag = shift;			# Update flag.
	my $chronosecs;				# Current time in seconds.
	my $chronostr;				# Current time string.
	my $kr;					# Zone's keyrec reference.
	my %keyrec;				# Zone's keyrec.

	if($verbose > $VERBOSE_LOW)
	{
		if(($verbose == $VERBOSE_HIGH)	||
		   ($updflag == $UPD_ALLKEYS))
		{
			print "\tupdating the keyrec file for the zone\n";
		}
	}

	#
	# Set some fields we've got to have -- in case they aren't
	# set in the options.
	#
	$opts{'zonefile'}	= $zoneout;
	$opts{'signedfile'}	= $zoneout . ".signed";
	$opts{'kskdirectory'}	= $kskdir;
	$opts{'kskkey'}		= $ksk;
	$opts{'kskpath'}	= $kskpath;
	$opts{'zskcur'}		= $zskcur;
	$opts{'zskpub'}		= $zskpub;
	$opts{'zskdirectory'}	= $zskdir;
	$opts{'zskcurpath'}	= $zskcurpath;
	$opts{'zskpubpath'}	= $zskpubpath;
	$opts{'szopts'}		= $szopts if($szopts ne "");

	#
	# Save the zone end time and delete the option prefix.
	#
	$opts{'endtime'} = $enddate;
	$opts{'endtime'} =~ s/^-e //;

	#
	# Get the keyrec for the zone.  If there isn't one, it's a new
	# zone and we'll create a new keyrec.
	#
	$kr = keyrec_fullrec($zone);
	if(!defined($kr))
	{
		keyrec_add('zone',$zone,\%opts);
	}
	else
	{

		#
		# If there is a keyrec for the zone, we'll make sure the
		# defined zone keyrec fields are set.
		#
		foreach my $field (keyrec_zonefields())
		{
			if(defined($opts{$field}))
			{
				keyrec_setval('zone',$zone,$field,$opts{$field});
			}
		}
	}

	#
        # Set a timestamp for the zone entry.
	#
	$chronosecs = time();
	$chronostr  = gmtime($chronosecs);
	keyrec_setval('zone',$zone,'keyrec_signsecs',$chronosecs);
	keyrec_setval('zone',$zone,'keyrec_signdate',$chronostr);

	#
	# Set the zone name in the keyrecs of our keys.
	#
	keyrec_setval('key',$ksk,'zonename',$zone)    if($updflag != $UPD_ZSK);
	keyrec_setval('key',$zskcur,'zonename',$zone) if($updflag != $UPD_KSK);
	keyrec_setval('key',$zskpub,'zonename',$zone) if($updflag != $UPD_KSK);

	#
	# Save the keyrec file.
	#
	keyrec_write();
}

#######################################################################
#
# Routine:	hasincludes
#
# Purpose:	This routine returns a flag indicating if the zone file
#		includes any keys.
#
#		0 - zone file does not include keys
#		1 - zone file includes keys
#
sub hasincludes
{
	my $file = "";				# Contents of zone file.
	my $flen = 0;				# Length of zone file.
	my $keyname;				# Name of key from include.

	#
	# Get the zone file's length and contents.
	#
	seek(ZF,0,0);
	$flen = $zonestat[7];
	read(ZF,$file,$flen);

	#
	# Look for the key inclusion.
	#
	$file =~ /^\$INCLUDE \"(.+?)\"$/m;
	$keyname = $1;

	#
	# Give the appropriate response.
	#
	if($keyname eq "")
	{
		return(0);
	}
	return(1);
}

#######################################################################
#
# Routine:	serialincr
#
# Purpose:	This routine increments the serial number of an SOA record in
#		a zone file.  The serial number is found in both the multi-
#		line parenthesize form and the single line unparenthesize form.
#
#		On success, the new serial number is returned.
#		On failure, -1 is returned.
#
sub serialincr
{
	my $file = "";				# Contents of zone file.
	my $flen = 0;				# Length of zone file.

	my $remnant;				# Contents after the SOA line.
	my $soafields;				# SOA's fields.
	my $serialnum;				# Current serial number.
	my $serialnew;				# New serial number.

	#
	# Get the zone file's length and contents.
	#
	$flen = $zonestat[7];
	seek(ZF,0,0);
	read(ZF,$file,$flen);

	#
	# Find the SOA line and save everything after it.
	#
	$file =~ /\s+IN\s+SOA\s+/si;
	$remnant = $';

	#
	# Find the SOA's parenthesized fields.
	#
	$remnant =~ /\(.*?\)/s;
	$soafields = $&;

	#
	# Get the SOA's serial number and increment it.
	#
	$soafields =~ /([0-9]+)/;
	$serialnum = $1;

	#
	# We assumed the serial number was parenthesized.  If we didn't
	# find it, we'll look for it in an unparenthesized line.
	#
	if($serialnum eq "")
	{
		#
		# Pick up the SOA line.
		#
		$file =~ /\s+IN\s+SOA\s+/si;
		$remnant = $';

		#
		# Snork out the serial number.
		#
		$remnant =~ /\S+\s+\S+\s+(\S+)\s+/;
		$serialnum = $1;

		#
		# If we didn't find the serial number here either,
		# return a failure.
		#
		if($serialnum eq "")
		{
			return(-1);
		}
	}

	#
	# Increment the serial number and change it in the file contents.
	#
	$serialnew = $serialnum + 1;
	$file =~ s/$serialnum/$serialnew/;

	#
	# Write the new file contents and close the file.
	#
	seek(ZF,0,0);
	truncate(ZF,0);
	print ZF $file;
	close(ZF);

	#
	# Re-open the zone file with the latest info.
	#
	@zonestat = stat($zonefile);
	open(ZF,"+< $zonefile");

	return($serialnew);
}

#######################################################################
#
# Routine:	chkkrf()
#
# Purpose:	If we have a new keyrec file, we'll add a new keyrec
#		for the specified zone.  We'll set a few basic keyrec
#		files in the entry.
#
#		Condition order is important!  Don't re-arrange or condense
#		unless you know what you're doing!
#
sub chkkrf
{
	my %zoneopts;				# Initial fields for zone.

	#
	# If no keyrec file should be created, we'll return now.
	#
	if($nokrfile)
	{
		vprint("not using a keyrec file\n");
		return;
	}

	#
	# If no keyrec file was specified and we haven't been told not
	# to use a keyrec file, we'll use the default.
	#
	if($krfile eq "")
	{
		my $defkrf;			# Default keyrec file.

		#
		# Get the default keyrec file.  If there isn't one,
		# we'll use the zone name.
		#
		$defkrf = keyrec_defkrf();
		$defkrf = $zone . ".krf"  if($defkrf eq "");

		#
		# Put the default keyrec file onto the argument vector
		# and redo the argument checking.
		#
		@ARGV = @saveargs;
		unshift(@ARGV,$defkrf);
		unshift(@ARGV,"-krfile");
		vprint("using default keyrec file $defkrf\n");

		#
		# Rescan our arguments.
		#
		opts_reset();
		optsandargs();
		return;
	}

	#
	# If the keyrec file is of non-zero length, we'll return now.
	#
	if(-s $krfile)
	{
		return;
	}

	#
	# Set the basic zone keyrec fields and add the keyrec.
	#
	$zoneopts{'keyrec_type'} = "zone";
	$zoneopts{'zonefile'}	 = $zoneout;

	keyrec_add('zone',$zone,\%zoneopts);

	vprint("using keyrec file $krfile\n");
}

#######################################################################
#
# Routine:	getincl()
#
# Purpose:	Return the text used in the include lines.
#
sub getincl
{
	my $incstr;				# Include section.

	$incstr = <<EOF;

;;
;;
;; DO NOT DIRECTLY MODIFY ANYTHING BELOW THIS LINE.
;;
;;	All subsequent lines are added and manipulated by dnssec-tools.
;;

;; ksk
\$INCLUDE \"$kskpath\"

;; current zsk
\$INCLUDE \"$zskcurpath\"

;; published zsk
\$INCLUDE \"$zskpubpath\"

EOF

	return($incstr);
}

#######################################################################
#
# Routine:	forceroll()
#
# Purpose:	Force a roll-over of the ZSK keys.  The current ZSK is
#		marked as obsolete.  The published ZSK is moved to being
#		the current ZSK.  If the zone has a new ZSK, it is
#		moved to being the published ZSK; if not, a new published
#		ZSK is generated.  Finally, a new ZSK is generated.
#
#		This should only be used if you know what you're doing.
#
sub forceroll
{
	my $zsknew;				# Name of new ZSK key.
	my $zskkey;				# ZSK key.
	my $krref;				# Reference to key's keyrec.
	my $zoneref;				# Reference to zone's keyrec.

	vprint("forcing a key roll-over\n");

	#
	# We're rolling KSKs, so make sure they'll be generated.
	#
	$genzsk = 1;

	#
	# Ensure that a roll-over makes sense.
	#
	if($opts{'zskpub'} eq "")
	{
		print STDERR "zone $zone has no published ZSK to roll-over to a current ZSK\n";
		exit(1);
	}

	#
	# Get the zone's keyrec.
	#
	$zoneref = keyrec_fullrec($zone);

	#
	# Render the current ZSK obsolete.
	#
	$krref = keyrec_fullrec($opts{'zskcur'});
	$krref->{'keyrec_type'}	= "zskobs";
	keyrec_setval("key",$krref->{'keyrec_name'},"keyrec_type","zskobs");
	keyrec_setval("key",$krref->{'keyrec_name'},"keypath",$zoneref->{'zskcurpath'});
	vmed_print("current ZSK ($krref->{'keyrec_name'}) now obsolete\n");

	#
	# If we're supposed to archive the keys, we'll move the obsolete
	# key off to the archive directory.
	#
	if($savekeys)
	{
		my $kn = $krref->{'keyrec_name'};	# Base name of keys.

		if(! -e $archdir)
		{
			vmed_print("creating ZSK archive directory $archdir\n\n");
			system("$MKDIR -p -m 0700 $archdir");
		}
		else
		{
			if(! -d $archdir)
			{
				print STDERR "ZSK archive directory $archdir is not a directory; not archiving old ZSK key\n";
			}
		}

		vhigh_print("moving $kn to $archdir\n\n");
		system("$MV $kn.* $archdir");
	}

	#
	# Convert the published ZSK into the current ZSK.
	#
	$krref = keyrec_fullrec($opts{'zskpub'});
	$krref->{'keyrec_type'} = 'zskcur';
	$opts{'zskcur'} = $krref->{'keyrec_name'};
	$zskcur = $krref;
	$zskcur = $opts{'zskcur'};
	keyrec_setval("key",$zskcur,"keyrec_type","zskcur");
	vmed_print("published ZSK ($krref->{'keyrec_name'}) now current\n");

	#
	# If we have a new ZSK, we'll make that the current published ZSK.
	# If not, we'll generate a published ZSK.
	#
	if(defined($opts{'zsknew'}))
	{
		$krref = keyrec_fullrec($opts{'zsknew'});
		$krref->{'keyrec_type'} = "zskpub";
		$opts{'zskpub'} = $krref->{'keyrec_name'};
		$zskpub = $krref;
		$zskpub = $opts{'zskpub'};

		vmed_print("new ZSK ($krref->{'keyrec_name'}) now published\n");
	}
	else
	{
		$zskpub = genzsk("pub");
		$krref = keyrec_fullrec($opts{'zskpub'});
		$opts{'zskpub'} = $krref->{'keyrec_name'};

		vmed_print("published ZSK ($krref->{'keyrec_name'}) created\n");
	}

	keyrec_setval("key",$zskpub,"keyrec_type","zskpub");

	#
	# Generate a new ZSK.
	#
	$zsknew = genzsk("new");
	vmed_print("new ZSK ($zsknew) created\n");
	keyrec_setval("key",$zsknew,"keyrec_type","zsknew");
	keyrec_setval("key",$zsknew,"zonename",$zone);
}

#######################################################################
#
# Routine:	printopts()
#
# Purpose:	Display the value of our options.
#
sub printopts
{
	return if($verbose < $VERBOSE_MEDIUM);

	print "\n";
	print "\targuments:\n";
	print "\t\tzone     - $zone\n";
	print "\t\tzonefile - $zonefile\n";
	print "\t\tzoneout  - $zoneout\n\n";

	return if($verbose < $VERBOSE_HIGH);

	print "\tzonesigner arguments:\n";
	print "\t\tkrfile		- <$krfile>\n";
	print "\t\tnokrfile	- <$nokrfile>\n";
	print "\t\tentropymsg	- <$entropymsg>\n";
	print "\t\tsavekeys	- <$savekeys>\n";
	print "\t\tarchdir         - <$archdir>\n";
	print "\n";

	print "\tkey-signing parameters:\n";
	print "\t\talgorithm	- <$alg>\n";
	print "\t\trandom		- <$random>\n";
	print "\t\tksize		- <$ksize>\n";
	print "\t\tkskdir		- <$kskdir>\n";
	print "\t\tgenksk		- <$genksk>\n";
	print "\t\tzsize		- <$zsize>\n";
	print "\t\tzskdir		- <$zskdir>\n";
	print "\t\tgenzsk		- <$genzsk>\n";
	print "\t\tkgopts		- <$kgopts>\n";
	print "\n";

	print "\tzone-signing parameters:\n";
	print "\t\tenddate		- <$enddate>\n";
	print "\t\tgends		- <$gends>\n";
	print "\t\tksdir		- <$ksdir>\n";
	print "\t\tszopts		- <$szopts>\n";
	print "\n";

	print "\texternal commands:\n";
	print "\t\tcheckzone	- <$checkzone>\n";
	print "\t\tkeygen		- <$keygen>\n";
	print "\t\tsignzone	- <$signzone>\n";
	print "\n";
}

#######################################################################
#
# Routine:	vprint()
#
sub vprint
{
	my $out = shift;			# Output string.

	print "    $out" if($verbose);
}

#######################################################################
#
# Routine:	vmed_print()
#
sub vmed_print
{
	my $out = shift;			# Output string.

	print "\t$out" if($verbose > $VERBOSE_LOW);
}

#######################################################################
#
# Routine:	vhigh_print()
#
sub vhigh_print
{
	my $out = shift;			# Output string.

	print "\t\t$out" if($verbose == $VERBOSE_HIGH);
}


#######################################################################
#
# Routine:	helpchk()
#
# Purpose:	Explicit argument checks for the help option.
#
sub helpchk
{
	my $argc = @ARGV;			# Length of @ARGV.
	my $ind;				# Index for @ARGV.

	for($ind=0; $ind<$argc; $ind++)
	{
		my $arg = $ARGV[$ind];

		if(($arg eq "-h")	|| ($arg eq "--h")	||
		   ($arg eq "-he")	|| ($arg eq "--he")	||
		   ($arg eq "-hel")	|| ($arg eq "--hel")	||
		   ($arg eq "-help")	|| ($arg eq "--help"))
		{
			usage(1);
		}
	}
}

#######################################################################
#
# Routine:	usage()
#
# Purpose:	Give usage message and exit.
#
sub usage
{
	my $whence = shift;			# Location of call.

	print STDERR "usage:  zonesigner [options] <zone-file> <zone-out>\n";
	print STDERR "\n";

	print STDERR "\t\tzonesigner options:\n";
	print STDERR "\t\t\t-krfile keyrec-file\n";
	print STDERR "\t\t\t-nokrfile\n";
	print STDERR "\t\t\t-genkeys\n";
	print STDERR "\t\t\t-genksk\n";
	print STDERR "\t\t\t-genzsk\n";
	print STDERR "\t\t\t-zone zone-name\n";
	print STDERR "\t\t\t-help\n";
	print STDERR "\t\t\t-verbose\n";
	print STDERR "\n";

	print STDERR "\t\tdnssec-keygen options:\n";
	print STDERR "\t\t\t-algorithm algorithm\n";
	print STDERR "\t\t\t-ksklength KSK-size\n";
	print STDERR "\t\t\t-zsklength ZSK-size\n";
	print STDERR "\t\t\t-random random-path\n";
	print STDERR "\t\t\t-kgopts dnssec-keygen-options\n";
	print STDERR "\n";

	print STDERR "\t\tdnssec-signzone options:\n";
	print STDERR "\t\t\t-endtime end-time\n";
	print STDERR "\t\t\t-gends\n";
	print STDERR "\t\t\t-ksdir keyset-directory\n";
	print STDERR "\t\t\t-szopts dnssec-signzone-options\n";
	print STDERR "\n";

#	print "\ncalled from $whence\n" if($verbose && ($whence > 0));

	exit(1);
}

1;

##############################################################################
#

=pod

=head1 NAME

zonesigner - Generates encryption keys and signs a DNS zone.

=head1 SYNOPSIS

  zonesigner [options] <zone-file> <zone-out>

=head1 DESCRIPTION

This script combines into a single command many actions that are required to
sign a DNS zone.  It generates the required KSK and ZSK keys, adds the key
data to a zone record file, signs the zone file, and runs checks to ensure
that everything worked properly.

Using I<keyrec> files, defined and maintained by B<dnssec-tools>,
I<zonesigner> can automatically gather many of the options used to previously
sign and generate a zone and its keys.  This allows the zone to be maintained
using the same key lengths and expiration times, for example, without an
administrator needing to manually track these fields.

=head1 KEYREC FILES

I<keyrec> files retain information about previous key-generation and
zone-signing operations.  If a I<keyrec> file is not specified (by way of the
I<-krfile> option), then a default I<keyrec> file is used.  If this default
in not specified in the system's B<dnssec-tools> configuration file, the
filename will be the zone name appended with B<.krf>.  If the I<-nokrfile>
option is given, then no I<keyrec> file will be consulted or saved.

I<keyrec> files contain two types of entries:  zone I<keyrec>s and key
I<keyrec>s.  Each I<keyrec> contains a set of "key/value" entries, one per
line.  Example 4 below contains the contents of a sample I<keyrec> file.

=head1 USING ZONESIGNER

I<zonesigner> is used in this way:

    zonesigner [options] <zone-file> <zone-out>

The I<zone-file> and I<zone-out> arguments are required.

I<zone-file> is the name of the zone file from which a signed zone file will
be created.  If the I<-zone> option is not given, then I<zone-file> will be
used as the name of the zone that will be signed.  Generated keys are given
this name as their base.

The zone file is modified to have B<include> commands, which will include the
KSK and ZSK keys.  These lines are placed at the end of the file and should
not be modified by the user.  If the zone file already includes any key files,
those inclusions will be deleted.  These lines are distinguished by starting
with "$INCLUDE" and end with ".key".  Only the actual include lines are
deleted; any related comment lines are left untouched.

I<zone-out> is the name of the output zone file.  This file will be a copy
of the I<zone-file> zone file, with some modifications.  Several $INCLUDE
lines will be added at the end of the file and the SOA serial number will be
incremented.

The signed zone file will be this name, appended with I<.signed>.

Unless the I<-genkeys>, I<-genksk>, or I<-genzsk> options are specified, the
last keys generated for a particular zone will be used in subsequent
I<zonesigner> executions.

=head1 ENTROPY

On some systems, the implementation of the pseudo-random number generator
requires keyboard activity.  This keyboard activity is used to fill a buffer
in the system's random number generator.  If zonesigner appears hung, you may
have to add entropy to the random number generator by randomly striking keys
until the program completes.  Display of this message is controlled by the
B<entropy_msg> configuration file parameter.

=head1 DETERMINING OPTION VALUES

I<zonesigner> checks four places in order to determine option values.  
In descending order of precedence, these places are:

    -ksklength command line options

    keyrec file

    dnssec-tools configuration file

    zonesigner defaults

Each is checked until a value is found.  That value is then used for that
I<zonesigner> execution and the value is stored in the I<keyrec> file.

=head2 Example

For example, the KSK length has the following values:

    -ksklength command line option:    	8192

    keyrec file:               		1024

    dnssec-tools configuration file:	2048

    zonesigner defaults:    		512

If all are present, then the KSK length will be 8192.

If the I<-ksklength> command line option wasn't given, the KSK length
will be 1024.

If the KSK length wasn't given in the configuration file, it will be 8192.

If the KSK length wasn't in the I<keyrec> file or the configuration file,
the KSK length will be 8192.

If the I<-ksklength> command line option wasn't given and the KSK length
wasn't in the configuration file, it'll be 1024.

If the command line option wasn't given, the KSK length wasn't in the
I<keyrec> file, and it wasn't in the configuration file, then the KSK
length will be 512.

=head1 OPTIONS

Three types of options may be given, based on the command for which they are
intended.  These commands are  I<dnssec-keygen>, I<dnssec-signzone>, and
I<zonesigner>.

=head2 I<zonesigner>-specific Options

=over 4

=item -nokrfile

No I<keyrec> file will be consulted or created.

=item -krfile

I<keyrec> file to use in processing options.  See the man page for
I<Net::DNS::SEC::Tools::tooloptions> for more details about this file.

=item -genkeys

Generate a new KSK and ZSK for the zone.

=item -genksk

Generate a new KSK for the zone.  By default, the last KSK generated for this
zone will be used.

=item -genzsk

Generate a new ZSK for the zone.  By default, the last ZSK generated for this
zone will be used.

=item -forceroll

Force a roll-over of the ZSK keys.  The I<keyrec>s of the ZSK keys are
adjusted as follows:

    The current ZSK key is marked as obsolete.
    The published ZSK key is marked as current.
    The new ZSK key, if it exists, is marked as published.
    A new ZSK key is generated.

This should only be used if you know what you're doing.

=item -zone

Name of the zone that will be signed.  This zone name may be given with this
option or as the first non-option command line argument.

=item -help

Display a usage message.

=item -verbose

Verbose output will be given.  As more instances of I<-verbose> are given on
the command line, additional levels of verbosity are achieved.

    level	output
    -----	------
      1		operations being performed
		  (e.g., generating key files, signing zone) 
      2		details on operations and some operation results
		  (e.g., new key names, zone serial number)
      3		operations' parameters and additional details
		  (e.g., key lengths, encryption algorithm,
		  executed commands)

Higher levels of verbosity are cumulative.  Specifying two instances of
I<-verbose> will get the output from the first and second levels of output.

=back

=head2 I<dnssec-keygen>-specific Options

=over 4

=item -algorithm

Cryptographic algorithm used to generate the zone's keys.
The default value is RSASHA1.

=item -ksklength

Bit length of the zone's KSK key.
The default is 1024.

=item -random

Source of randomness used to generate the zone's keys.	(/dev/urandom)

=item -zsklength

Bit length of the zone's ZSK key.
The default is 512.

=item -kgopts

Additional options for I<dnssec-keygen> may be specified using this option.
The additional options are passed as a single string value as an argument to
the I<-kgopts> option.

=back

=head2 I<dnssec-signzone>-specific Options

=over 4

=item -endtime

Time that the zone expires, measured in seconds.  See the man page for
I<dnssec-signzone> for the valid format of this field.
The default value is 259200 seconds (30 days.)

=item -gends

Force I<dnssec-signzone> to generate DS records for the zone.  This option is
translated into I<-g> when passed to I<dnssec-signzone>.

=item -ksdir

Specify a directory for storing keysets.  This is passed to I<dnssec-signzone>
as the I<-d> option.

=item -szopts

Additional options for I<dnssec-signzone> may be specified using this option.
The additional options are passed as a single string value as an argument to
the I<-szopts> option.

=back

=head1 Examples

Example 1.

In the first example, an existing I<keyrec> file is used to assist in signing
the example.com domain.  Zone data are stored in B<example.com>, and the
keyrec is in B<example.krf>.  The output zone file and final signed zone
file will use B<db.example.com> as a base.  Using this execution:

    # zonesigner -krfile example.krf example.com db.example.com

the following files are created:

    Kexample.com.+005+45842.private
    Kexample.com.+005+45842.key
    Kexample.com.+005+50186.private
    Kexample.com.+005+50186.key
    Kexample.com.+005+59143.key
    Kexample.com.+005+59143.private

    dsset-example.com.
    keyset-example.com.

    db.example.com
    db.example.com.signed


The first six files are the KSK and ZSK keys required for the zone.  The next
two files are created by the zone-signing process.  The last two are the zone
file used as input to the zone-signing process and the final signed zone.

Example 2.

In the second example, an existing I<keyrec> file is used to assist in signing
the example.com domain.  Zone data are stored in B<example.com>, and the
keyrec is in B<example.krf>.  The generated keys, output zone file, and final
signed zone file will use B<example.com> as a base.  Using this execution:

    # zonesigner -krfile example.krf example.com db.example.com

the following files are created:

    Kdb.example.com.+005+12354.key
    Kdb.example.com.+005+12354.private
    Kdb.example.com.+005+82197.key
    Kdb.example.com.+005+82197.private
    Kdb.example.com.+005+55888.key
    Kdb.example.com.+005+55888.private

    dsset-db.example.com.
    keyset-db.example.com.

    db.example.com.signed

The first six files are the KSK and ZSK keys required for the zone.  The next
two files are created by the zone-signing process.  The last file is file is
the final signed zone.

Example 3.

In the third example, no I<keyrec> file is specified for the signing of
the example.com domain.  In addition to files created as shown in previous
examples, a new I<keyrec> file is created.  The new I<keyrec> file uses the
domain name as its base.  Using this execution:

    # zonesigner example.com db.example.com

the following I<keyrec> file is created:

    example.com.krf

Example 4.

This example shows a I<keyrec> file generated by I<zonesigner>.

The command executed is:

    # zonesigner example.com db.example.com

The generated I<keyrec> file contains three I<keyrec>s:  a zone I<keyrec>,
one KSK I<keyrec>, and two ZSK I<keyrec>s.  

    zone	"example.com"
	zskpubpath	"./Kexample.com.+005+13531.key"
	zskpub		"Kexample.com.+005+13531"
	zskdirectory	"."
	zskcurpath	"./Kexample.com.+005+53135.key"
	zskcur		"Kexample.com.+005+53135"
	signedfile	"db.example.com.signed"
	kskpath		"./Kexample.com.+005+24082.key"
	kskkey		"Kexample.com.+005+24082"
	kskdirectory	"."
	endtime		"+259200"
	zonefile	"db.example.com"
	keyrec_type	"zone"
	keyrec_signsecs	"1115166642"
	keyrec_signdate	"Wed May  4 00:30:42 2005"

    key		"Kexample.com.+005+24082"
	zonename	"example.com"
	keyrec_type	"ksk"
	algorithm	"rsasha1"
	random		"/dev/urandom"
	keypath		"./Kexample.com.+005+24082.key"
	ksklength	"1024"
	keyrec_gensecs	"1115166638"
	keyrec_gendate	"Wed May  4 00:30:38 2005"

    key		"Kexample.com.+005+53135"
	zonename	"example.com"
	keyrec_type	"zskcur"
	algorithm	"rsasha1"
	random		"/dev/urandom"
	keypath		"./Kexample.com.+005+53135.key"
	zsklength	"512"
	keyrec_gensecs	"1115166638"
	keyrec_gendate	"Wed May  4 00:30:38 2005"

    key		"Kexample.com.+005+13531"
	zonename	"example.com"
	keyrec_type	"zskpub"
	algorithm	"rsasha1"
	random		"/dev/urandom"
	keypath		"./Kexample.com.+005+13531.key"
	zsklength	"512"
	keyrec_gensecs	"1115166638"
	keyrec_gendate	"Wed May  4 00:30:38 2005"


=head1 NOTES

=over 4

=item 1.  SOA Serial Numbers

Serial numbers in SOA records are merely incremented in this version.  Future
plans are to allow for more flexible serial number manipulation.

=back

=head1 AUTHOR

Wayne Morrison, tewok@users.sourceforge.net

=head1 SEE ALSO

Net::DNS::SEC::Tools::conf.pm(3), Net::DNS::SEC::Tools::keyrec.pm(3), Net::DNS::SEC::Tools::tooloptions.pm(3)

=cut
