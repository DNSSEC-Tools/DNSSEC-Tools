#!/usr/bin/perl
#
# Copyright 2005 Sparta, Inc.  All rights reserved.  See the COPYING
# file distributed with this software for details
#
# zonesigner
#
#	This script combines a lot of actions required to sign a zone into a
#	single command.  The command is used in this way:
#
#		zonesigner [options] <zone> <zone-data> <zone-file>
#
#		where:
#			zone	 - the zone to be signed.  This may also be
#				   specified with the -zone option.
#			zonedata - a zone file to which the $INCLUDE ksk and
#				   $INCLUDE zsk lines are added
#			zonefile - is the name of the output zone file
#
#
#	Options, their meanings, and default values are given below.
#
#	Options passed to dnssec-keygen:
#		-algorithm	crypto algorithm	(RSASHA1)
#		-random		source of randomness	(/dev/urandom)
#		-ksklength	size of KSK key		(1024)
#		-zsklength	size of ZSK key		(512)
#
#	Options passed to dnssec-signzone:
#		-endtime	end-time		(259200)
#		-gends		generate DS records	(not given)
#
#	Other options:
#		-krfile		keyrec file to use
#		-keyrec		keyrec to search for in specified keyrec file
#		-zone		zone name
#
#		-reuseksk	re-use the zone's current KSK
#		-reusezsk	re-use the zone's current ZSK
#
#		-kgopts		additional options to pass to dnssec-keygen
#		-szopts		additional options to pass to dnssec-signzone
#
#		-help		display usage message
#		-verbose	verbose output

use strict;

use Net::DNS::SEC::Tools::keyrec;
use Net::DNS::SEC::Tools::tooloptions;


#
# Options fields.
#
my $alg;				# Encryption algorithm.
my $enddate;				# End-time for zone signing.
my $gends;				# Generate DS records in zone signing.
my $help = 0;				# Help flag.
my $ksize;				# Size of KSK.
my $kskdir;				# Directory to hold KSK.
my $random;				# Random number generation method.
my $verbose = 0;			# Turn off verbosity.
my $zsize;				# Size of ZSK.
my $zskdir;				# Directory to hold ZSK.
my $kgopts;				# Additional dnssec-keygen options.
my $szopts;				# Additional dnssec-signzone options.

my $ksk;				# KSK we've generated.
my $kskpath;				# Path to the KSK.
my $reuseksk;				# Reuse the existing KSK.
my $zskcur;				# Current ZSK.
my $zskpub;				# Published ZSK.
my $zskcurpath;				# Path to the published KSK.
my $zskpubpath;				# Path to the current KSK.
my $reusezsk;				# Reuse the existing ZSK.

my $zone;				# Zone to play with.
my $zonedata;				# Zone data (input) file.
my $zonefile;				# Zone file (output.)
my $krfile;				# User-specified keyrec file.

my $status;				# Zone-signing status.

my %opts;				# Options.


#
# Set some path variables.
#
my $CHECKZONE	= "/usr/local/sbin/named-checkzone";
my $CP		= "/bin/cp";
my $DATE	= "/bin/date";
my $KEYGEN	= "/usr/local/sbin/dnssec-keygen";
my $MV		= "/bin/mv";
my $SIGNZONE	= "/usr/local/sbin/dnssec-signzone";


#
# Do our work.
#
$status = main();
exit($status);

#######################################################################
#
# Routine:	main()
#
# Purpose:	Yeah, yeah, a main() isn't necessary.  However, it offends my
#		sense of aesthetics to have great gobs of code on the same
#		level as a pile of globals.
#
#		But what about all those globals, you ask...
#
sub main
{
	my $status;				# Status of zone-signing.

	#
	# Munch on the options and arguments.
	#
	optsandargs();

	if($verbose)
	{
		print "options\n";
		foreach my $k (sort(keys(%opts)))
		{
			print "\t$k - $opts{$k}\n";
		}

		print "\narguments:\n";
		print "\tzone	  - $zone\n";
		print "\tzonedata - $zonedata\n";
		print "\tzonefile - $zonefile\n";
	}

	#
	# If help was specified, give the usage and exit.
	#
	if($help == 1)
	{
		usage();
	}

	#
	# Ensure that the required data were specified.
	#
	if(($zone eq "") || ($zonedata eq "") || ($zonefile eq ""))
	{
		print STDERR "no zone specified\n";
		usage();
	}

	#
	# Generate the KSK and ZSK key files.
	#
	genkeys();

	#
	# Create the key directories and move the key files into the appropriate
	# repositories.
	#
	keydirs();

	#
	# Set some short-hand variables.
	#
	$kskpath = "$kskdir/$ksk.key";
	$zskcurpath = "$zskdir/$zskcur.key";
	$zskpubpath = "$zskdir/$zskpub.key";

	#
	# Create the unsigned zone file and add include lines for the key files.
	#
	zoneincludes();

	#
	# Sign the zone with the new keys and ensure the signing succeeded.
	#
	$status = zonesign();
	return($status);
}

#######################################################################
#
# Routine:	optsandargs()
#
# Purpose:	Parse the command line for options and arguments.
#
sub optsandargs()
{
	my $argc;			# Number of arguments.
	my $ropts;			# Reference to the option hash.

	#
	# Set the options, try to use the config file, the command line
	# options and a keyrec file.  We'll take the following steps in
	# trying to get a good set of options.
	#
	#  1. Set options from config file, command line, and a keyrec.
	#     Look in the options for -krfile and -keyrec to find the keyrec.
	#  2. Set options from config file, command line, and a keyrec.
	#     Use our first argument is a zone name, and assume there's
	#     a -krfile.  (Previous step showed there isn't a -keyrec.)
	#  3. Set options from the config file and command line.  No keyrec
	#     will be used.
	#
	opts_createkrf();
	$ropts = opts_zonekr();
	if($ropts == undef)
	{
		$zone = $ARGV[0];
		$ropts = opts_zonekr("",$zone);
		if($ropts == undef)
		{
			$ropts = tooloptions("","");
		}
	}
	if($ropts != undef)
	{
		%opts = %$ropts;
	}

	#
	# Get the KSK- and ZSK-related arguments.
	#
	$ksize	  = $opts{'ksklength'}	  || "";
	$zsize	  = $opts{'zsklength'}	  || "";
	$kskdir	  = $opts{'kskdirectory'} || '.';
	$zskdir	  = $opts{'zskdirectory'} || '.';
	$reuseksk = $opts{'reuseksk'}	  || 0;
	$reusezsk = $opts{'reusezsk'}	  || 0;

	#
	# Get the rest of the options.
	#
	$alg	 = $opts{'algorithm'}	|| "";
	$enddate = $opts{'endtime'}	|| "";
	$gends	 = $opts{'gends'}	|| "";
	$random  = $opts{'random'}	|| "";
	$kgopts  = $opts{'kgopts'}	|| "";
	$szopts  = $opts{'szopts'}	|| "";
	$krfile  = $opts{'krfile'}	|| "";

	#
	# Set up options and values, if they've been given.
	#
	$ksize	 = "-b $ksize"	 if($ksize ne "");
	$zsize	 = "-b $zsize"	 if($zsize ne "");
	$alg	 = "-a $alg"	 if($alg ne "");
	$enddate = "-e $enddate" if($enddate ne "");
	$random	 = "-r $random"	 if($random ne "");

	$help	 = $opts{'help'};
	$verbose = $opts{'verbose'};

	#
	# If the verbose flag was set, we'll print out the options we're
	# using.
	#
	if($verbose)
	{
		print "key-signing parameters:\n";
		print "\talgorithm	- <$alg>\n";
		print "\trandom		- <$random>\n";
		print "\tksize		- <$ksize>\n";
		print "\tkskdir		- <$kskdir>\n";
		print "\treuseksk	- <$reuseksk>\n";
		print "\tzsize		- <$zsize>\n";
		print "\tzskdir		- <$zskdir>\n";
		print "\treusezsk	- <$reusezsk>\n";
		print "\tkgopts		- <$kgopts>\n";
		print "\n";

		print "zone-signing parameters:\n";
		print "\tenddate	- <$enddate>\n";
		print "\tgends		- <$gends>\n";
		print "\tszopts		- <$szopts>\n";
		print "\n";
	}

	#
	# Check that we don't have too many arguments.
	#
	$argc = @ARGV;
	usage() if($argc > 3);

	#
	# If we've got two arguments (after option removal) we'll look for
	# the zone name in the arguments.  If we find it, we'll add the
	# zone name to the argument list.
	#
	if($argc == 2)
	{
		$zone = $opts{'zone'};
		usage() if(!defined($zone));

		unshift(@ARGV,$zone);
	}

	#
	# Set variables for the arguments.
	#
	$zone	  = $ARGV[0];
	$zonedata = $ARGV[1];
	$zonefile = $ARGV[2];

	#
	# If the keyrec file is empty, we'll create a keyrec for
	# the zone.
	#
	chkkrf();
}

#######################################################################
#
# Routine:	genkeys()
#
# Purpose:	Generate new KSK and ZSK keys.  New keyrecs for the new keys
#		are added to the keyrec file.
#
sub genkeys
{
	print "\ngenerating key files:\n" if ($verbose);

	genksk();
	$zskcur = genzsk("cur");
	$zskpub = genzsk("pub");
}

#######################################################################
#
# Routine:	genksk()
#
# Purpose:	Generate a new KSK key.
#
sub genksk
{
	#
	# If we're going to reuse the KSK, ensure it's been created and
	# return.
	#
	if($reuseksk == 1)
	{
		if($opts{'kskkey'} eq "")
		{
			print STDERR "unable to re-use a non-existent KSK\n";
			exit(1);
		}

		$ksk = $opts{'kskkey'};
		print "\treusing existing KSK - $ksk\n" if ($verbose);

		return;
	}

	#
	# Generate the new KSK.
	#
	print "\t$KEYGEN $kgopts $random $alg $ksize -n zone -f KSK $zone\n" if ($verbose);
	$ksk = `$KEYGEN $kgopts $random $alg $ksize -n zone -f KSK $zone`;
	if($? != 0)
	{
		print STDERR "unable to generate KSK key file;\n";
		print STDERR "dnssec-keygen returned $?\n" if($verbose);
		exit(1);
	}
	chomp $ksk;
	print "\t\tnew KSK - $ksk\n" if ($verbose);

	#
	# Add the KSK's keyrec to the keyrec file.
	#
	$opts{'keyrec_type'} = "ksk";
	keyrec_add('key',$ksk,\%opts);

	delete $opts{'keyrec_type'};
}

#######################################################################
#
# Routine:	genzsk()
#
sub genzsk
{
	my $keytype = shift;		# ZSK type:  cur, new, pub.
	my $zskkey;			# Hash key for this ZSK.
	my $zsk;			# Generated key.

	#
	# Get the hash key for the ZSK we're going to generate.
	#
	$zskkey = "zsk" . $keytype;

	#
	# If we're reusing the ZSK, ensure it's already defined and return.
	#
	if($reusezsk == 1)
	{
		if(keyrec_fullrec($opts{$zskkey}) eq "")
		{
			print STDERR "$keytype ZSK keyrec does not exist; unable to re-use non-existent $keytype ZSK\n";
			exit(1);
		}

		$zsk = $opts{$zskkey};
		print "\treusing existing $keytype ZSK - $zsk\n" if ($verbose);

		return($zsk);
	}

	#
	# Generate a ZSK key.
	#
	print "\t$KEYGEN $kgopts $random $alg $zsize -n zone $zone\n" if ($verbose);
	$zsk = `$KEYGEN $kgopts $random $alg $zsize -n zone $zone`;
	if($? != 0)
	{
		print STDERR "unable to generate $keytype ZSK key file;\n";
		print STDERR "dnssec-keygen returned $?\n" if($verbose);
		exit(1);
	}
	chomp $zsk;
	print "\t\tnew $keytype ZSK - $zsk\n" if ($verbose);

	#
	# Add the ZSK's keyrec to the keyrec file.
	#
	$opts{'keyrec_type'} = "$zskkey";
	keyrec_add('key',$zsk,\%opts);

	delete $opts{'keyrec_type'};

	return($zsk);
}

#######################################################################
#
# Routine:	keydirs()
#
# Purpose:	Check the validity of the key directories and move the newly
#		generated key in.  Don't do anything if the directory is '.' 
#
sub keydirs
{
	#
	# Ensure the KSK key directory exists and is actually a directory.
	#
	print "checking key directories\n" if ($verbose);

	if($kskdir ne ".")
	{
		if(! -e $kskdir)
		{
			mkdir($kskdir);
		}
		elsif(! -d $kskdir)
		{
			print STDERR "KSK repository ($kskdir) is not a directory\n";
			exit(3);
		}
		system("$MV $ksk.* $kskdir");
	}

	#
	# Ensure the ZSK key directory exists and is a directory.
	#
	if($zskdir ne ".")
	{
		if(! -e $zskdir)
		{
			mkdir($zskdir);
		}
		elsif(! -d $zskdir)
		{
			print STDERR "ZSK repository ($zskdir) is not a directory\n";
			exit(3);
		}

		system("$MV $zskcur.* $zskdir");
		system("$MV $zskpub.* $zskdir");
	}
}

#######################################################################
#
# Routine:	zoneincludes()
#
# Purpose:	Add include statements to the zone file for the key files.
#
sub zoneincludes
{
	print "adding key includes to zone file\n" if ($verbose);

	#
	# Copy the zone data to a new file.
	#
	system("$CP $zonedata $zonefile");

	#
	# Add lines to include the KSK and ZSK files.
	#
	open(ZD,">> $zonefile");
	print ZD <<EOF;


;;
;;
;; DO NOT DIRECTLY MODIFY ANYTHING BELOW THIS LINE.
;;
;;	All subsequent lines are added and manipulated by dnssec-tools.
;;

;; ksk
\$INCLUDE \"$kskpath\"

;; current zsk
\$INCLUDE \"$zskcurpath\"

;; published zsk
\$INCLUDE \"$zskpubpath\"

EOF
	close(ZD);
}

#######################################################################
#
# Routine:	zonesign()
#
# Purpose:	Sign the zone with the new keys and ensure that the signing
#		succeeded.
#
sub zonesign
{
	my $chron;			# Today's date.
	my $ktag;			# Tag value from KSK.
	my $zcurtag;			# Tag value from current ZSK.
	my $zpubtag;			# Tag value from published ZSK.
	my $szone;			# Result from dnssec-signzone execution.
	my $cmdopts;			# Options for dnssec-signzone.
	my $status;			# Execution return code.

	#
	# Build a set of options for dnssec-signzone.  This isn't strictly
	# necessary, but it does keep the dnssec-signzone execution a bit
	# cleaner than it would be otherwise.
	#
	$cmdopts = "$szopts $gends -k $kskpath -o $zone $enddate";

	#
	# Sign the zone with the new keys.
	#
	print "signing zone\n" if ($verbose);
	print "\t$SIGNZONE $cmdopts $zonefile $zskcurpath\n" if ($verbose);
	$szone = `$SIGNZONE $cmdopts $zonefile $zskcurpath`;
	if($szone eq "")
	{
		print STDERR "unable to sign zone\n";
		exit(1);
	}

	#
	# Ensure the signing succeeded.
	#
	print "checking zone\n" if ($verbose);
	$status = system("$CHECKZONE -q $zone $szone");
	if($status != 0)
	{
		print STDERR "problems with zone signing\n";
		system("$CHECKZONE $zone $szone");
		return($status);
	}

	#
	# Add the ZSK's keyrec to the keyrec file.
	#
	updzonerec($szone);

	#
	# Get the tag values.
	#
	$ksk =~ /.*\+.*\+([0-9][0-9]*)/;
	$ktag = $1;
	$zskcur =~ /.*\+.*\+([0-9][0-9]*)/;
	$zcurtag = $1;
	$zskpub =~ /.*\+.*\+([0-9][0-9]*)/;
	$zpubtag = $1;

	#
	# Get today's date.
	#
	$chron = `$DATE +"%m/%d/%y"`;
	$chron =~ s/\n//;

	print "zone signed successfully\n";
	print "${zone}:\n";
	print "	ZSK  $zcurtag  $zsize  $chron	KSK  $ktag  $ksize  $chron\n";
	print "	ZSK  $zpubtag  $zsize  $chron\n";
	return(0);
}

#######################################################################
#
# Routine:	updzonerec()
#
# Purpose:	Add the zone's keyrec to the keyrec file.  Also, we'll add the
#		zone's name to the keyrecs of its keys.
#
sub updzonerec
{
	my $zfile = shift;			# New zone file.

	my $chronosecs;				# Current time in seconds.
	my $chronostr;				# Current time string.
	my $kr;					# Zone's keyrec reference.
	my %keyrec;				# Zone's keyrec.

	print "updating the keyrec file for the zone\n" if ($verbose);

	#
	# Set some fields we've got to have -- in case they aren't
	# set in the options.
	#
	$opts{'zonefile'} = $zonefile;
	$opts{'kskkey'}	  = $ksk;
	$opts{'kskpath'}  = $kskpath;
	$opts{'zskcur'}	  = $zskcur;
	$opts{'zskpub'}	  = $zskpub;
	$opts{'zskcurpath'}  = $zskcurpath;
	$opts{'zskpubpath'}  = $zskpubpath;

	#
	# Get the keyrec for the zone.  If there isn't one, it's a new
	# zone and we'll create a new keyrec.
	#
	$kr = keyrec_fullrec($zone);
	if(!defined($kr))
	{

		keyrec_add('zone',$zone,\%opts);
		return;
	}

	#
	# If there is a keyrec for the zone, we'll add
	#
	foreach my $field (keyrec_zonefields())
	{
		if(defined($opts{$field}))
		{
			keyrec_setval('zone',$zone,$field,$opts{$field});
		}
	}

	#
        # Set a timestamp for the zone entry.
	#
	$chronosecs = time();
	$chronostr  = gmtime($chronosecs);
	keyrec_setval('zone',$zone,'keyrec_signsecs',$chronosecs);
	keyrec_setval('zone',$zone,'keyrec_signdate',$chronostr);

	#
	# Set the zone name in the keyrecs of our keys.
	#
	keyrec_setval('key',$ksk,'zonename',$zone);
	keyrec_setval('key',$zskcur,'zonename',$zone);
	keyrec_setval('key',$zskpub,'zonename',$zone);

	#
	# Save the keyrec file.
	#
	keyrec_write();
}

#######################################################################
#
# Routine:	chkkrf()
#
# Purpose:	If we have a new keyrec file, we'll add a new keyrec
#		for the specified zone.  We'll set a few basic keyrec
#		files in the entry.
#
sub chkkrf
{
	my %zoneopts;				# Initial fields for zone.

	#
	# If a keyrec file wasn't specified or is of non-zero length,
	# we'll return now.
	#
	if(!defined($krfile) || (-s $krfile))
	{
		return;
	}

	#
	# Set the basic zone keyrec fields and add the keyrec.
	#
	$zoneopts{'keyrec_type'} = "zone";
	$zoneopts{'zonefile'}	 = $zonefile;

	keyrec_add('zone',$zone,\%zoneopts);
}

#######################################################################
#
# Routine:	usage()
#
# Purpose:	Give usage message and exit.
#
sub usage
{
	print STDERR "usage:  zonesigner [options] <zone> <zonedata> <zonefile>\n";
	print STDERR "\toptions:\n";
	print STDERR "\t\t-algorithm algorithm\n";
	print STDERR "\t\t-random random-path\n";
	print STDERR "\t\t-ksklength KSK-size\n";
	print STDERR "\t\t-zsklength ZSK-size\n";
	print STDERR "\t\t-endtime end-time\n";
	print STDERR "\t\t-krfile keyrec-file\n";
	print STDERR "\t\t-keyrec keyrec-name\n";
	print STDERR "\t\t-kgopts dnssec-keygen-options\n";
	print STDERR "\t\t-szopts dnssec-signszone-options\n";
	print STDERR "\t\t-zone zone-name\n";
	print STDERR "\t\t-gends\n";
	print STDERR "\t\t-reuseksk\n";
	print STDERR "\t\t-reusezsk\n";
	print STDERR "\t\t-help\n";
	print STDERR "\t\t-verbose\n";

	exit(1);
}

1;

##############################################################################
#

=pod

=head1 NAME

zonesigner - Check a dnssec-tools keyrec file for problems and consistency.

=head1 SYNOPSIS

  zonesigner [options] <zone> <zone-data> <zone-file>

=head1 DESCRIPTION

This script combines into a single command many actions that are required to
sign a zone.  It generates the required KSK and ZSK keys, adds the key data
to a zone file, signs the zone, and runs checks to ensure that everything
worked properly.

Using I<keyrec> files, defined and maintained by I<dnssec-tools>,
I<zonesigner> can automatically gather many of the options used to previously
sign and generate a zone and its keys.  This allows the zone to be maintained
using the same key lengths and expiration times, for example, without an
administrator needing to manually track these fields.

I<zonesigner> is used in this way:

=over 4

zonesigner [options] <zone> <zone-data> <zone-file>

=back

I<zone>	is the name of the zone that will be signed.  This may also be
specified with the I<-zone> option.

I<zonedata> is a template zone file to which several lines are added to
include required KSK and ZSK key files.  This file will look B<exactly> like
the I<zonefile> zone file, except without the $INCLUDE lines added at the end.

I<zonefile> is the name of the output zone file.  This file will look
B<exactly> like the I<zonedata> zone file, except with the $INCLUDE lines
added at the end.


=head1 OPTIONS

Three types of options may be specified:  I<dnssec-keygen> options,
I<dnssec-signzone> options, and options specific to I<zonesigner>.

=head2 I<dnssec-keygen> Options

=over 4

=item -algorithm

Cryptographic algorithm used to generate the zone's keys.
The default value is RSASHA1.

=item -ksklength

Bit length of the zone's KSK key.
The default is 1024.

=item -random

Source of randomness used to generate the zone's keys.	(/dev/urandom)

=item -zsklength

Bit length of the zone's ZSK key.
The default is 512.

=item -kgopts

Additional options for I<dnssec-keygen> may be specified using this option.
The additional options are passed as a single string value as an argument to
the I<-kgopts> option.

=back

=head2 I<dnssec-signzone> Options

=over 4

=item -endtime

Time that the zone expires, measured in seconds.  See the man page for
I<dnssec-signzone> for the valid format of this field.
The default value is 259200 seconds (30 days.)

=item -gends

Force I<dnssec-signzone> to generate DS records for the zone.  This option is
translated into I<-g> when passed to I<dnssec-signzone>.

=item -szopts

Additional options for I<dnssec-signzone> may be specified using this option.
The additional options are passed as a single string value as an argument to
the I<-szopts> option.

=back

=head2 I<zonesigner>-specific Options

=over 4

=item -krfile

I<keyrec> file to use in processing options.  See the man page for
I<Net::DNS::SEC::Tools::tooloptions> for more details about this file.

=item -keyrec

I<keyrec> to search for in the specified I<keyrec> file.  This option may be
used when re-signing zones in order to use the same options as had been
previously used to sign the zone.

=item -reuseksk

Re-use the zone's current KSK.

=item -reusezsk

Re-use the zone's current ZSK.

=item -zone

Name of the zone that will be signed.  This zone name may be given with this
option or as the first non-option command line argument.

=item -help

Display a usage message.

=item -verbose

Verbose output will be given.

=back

=head1 AUTHOR

Wayne Morrison, tewok@users.sourceforge.net

=head1 SEE ALSO

Net::DNS::SEC::Tools::conf.pm(3), Net::DNS::SEC::Tools::keyrec.pm(3), Net::DNS::SEC::Tools::tooloptions.pm(3)

=cut
