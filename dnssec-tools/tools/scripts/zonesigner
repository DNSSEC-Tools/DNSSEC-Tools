#!/usr/bin/perl
#
# Copyright 2004-2006 SPARTA, Inc.  All rights reserved.  See the COPYING
# file distributed with this software for details
#
# DNSSEC-Tools:  zonesigner
#
#	This script combines a number of actions required to sign a zone
#	into a single command.
#
#	The command is used in this way:
#
#		zonesigner [options] <zonefile> [signed-zonefile]
#
#		where:
#			zonefile	 - The input zone file to be signed.
#					   This is a zone file to which the
#					   $INCLUDE ksk and $INCLUDE zsk lines
#					   are added.
#			signed-zonefile	 - The name of the signed zone file,
#					   with keys included.
#
#	Options are described in the POD at the end of this file.
#

use strict;

use Net::DNS::SEC::Tools::conf;
use Net::DNS::SEC::Tools::defaults;
use Net::DNS::SEC::Tools::keyrec;
use Net::DNS::SEC::Tools::timetrans;
use Net::DNS::SEC::Tools::tooloptions;

#
# Version information.
#
my $NAME   = "zonesigner";
my $VERS   = "$NAME version: 1.0";
my $DTVERS = "DNSSEC-Tools Version: 1.0";

#
# Verbose values.
#
my $VERBOSE_LOW	   = 1;			# Lowest verbosity level.
my $VERBOSE_MEDIUM = 2;			# Middlin' verbosity level.
my $VERBOSE_HIGH   = 3;			# High verbosity level.

#
# Set some path variables.
#
my $CP		= "/bin/cp";
my $DATE	= "/bin/date";
my $MKDIR	= "/bin/mkdir";
my $MV		= "/bin/mv";
my $RM		= "/bin/rm";


#
# Default arguments to zonesigner.
#
my $DEF_ENTROPYMSG	= 1;			# Display of entropy message.
my $DEF_SAVEKEYS	= 1;			# Archive keys.
my $DEF_REUSEKSK	= 0;			# Re-use KSK.
my $DEF_REUSEZSK	= 0;			# Re-use ZSKs.

#
# Arguments for updzonerec().
#
my $UPD_KSKS	= 0x01;				# Only update KSK keyrecs.
my $UPD_ZSKS	= 0x10;				# Only update ZSK keyrecs.
my $UPD_ALLKEYS	= 0x11;				# Update all keyrecs.

#
# Debug flags.  These must be turned on here.
#
my $DEBUG_ZONETMP = 0;			# Saves the zone tempfile before delete.

#
# Options fields.
#
my $alg;				# Encryption algorithm.
my $enddate;				# End-time for zone signing.
my $entropymsg = $DEF_ENTROPYMSG;	# Display flag for entropy message.
my $gends;				# Generate DS records in zone signing.
my $help = 0;				# Help flag.
my $version = 0;			# Version flag.
my $kgopts;				# Additional dnssec-keygen options.
my $ksdir;				# Directory to hold keysets.
my $nokrfile;				# Flag for not using a keyrec file.
my $random;				# Random number generation method.
my $szopts;				# Additional dnssec-signzone options.
my $verbose = 0;			# Turn off verbosity.

my $archdir;				# Archive directory for old keys.
my $savekeys = 1;			# Flag for saving old keys.

my $kskcnt;				# Number of KSKs.
my $kskdir;				# Directory to hold KSK.
my $ksklife;				# Time between KSK rollovers.
my $ksize;				# Size of KSK.
my $genksk;				# Generate a new KSK.
my $ksignset;				# KSK signing set.

my $zskcur;				# Current ZSK.
my $zskpub;				# Published ZSK.
my $zskcurpath;				# Path to the published KSK.
my $zskpubpath;				# Path to the current KSK.
my $zskdir;				# Directory to hold ZSK.
my $zsklife;				# Time between ZSK rollovers.
my $zskcnt;				# Number of current ZSKs.
my $zsize;				# Size of ZSK.
my $genzsk;				# Generate a new ZSK.
my $signset;				# ZSK signing set.
my $lastset;				# Zone's last signing set.

my $ksksetname;				# Name of KSK signing set.
my @ksklist = ();			# New KSKs.
my $zskcursetname;			# Name of current ZSK signing set.
my $zskpubsetname;			# Name of published ZSK signing set.
my $zsknewsetname;			# Name of new ZSK signing set.
my @zskcurlist = ();			# Current ZSKs.
my @zskpublist = ();			# Published ZSKs.
my @zsknewlist = ();			# New ZSKs.

my $zone;				# Zone to play with.
my $zonefile;				# Input zone file.
my $zoneftmp;				# Intermediate zone file.
my $zoneout;				# Output zone file.
my $zftmp = 0;				# Intermediate file-specified flag.
my $krfile;				# User-specified keyrec file.

my $status;				# Zone-signing status.
my @zonestat;				# stat() buffer for zone file.

#
# Some path variables to be set from the config file.
#
my $keygen;
my $zonecheck;
my $zonesign;

my %opts;				# Options.
our @saveargs = @ARGV;			# Copy of argument vector.

#
# Zonesigner-specific command line arguments.
#
my @zsopts = ( '',
	       ['GUI:separator',	'Tool-specific options:'],
	       ["forceroll",		'Force the rollover of ZSK keys.'],
	       ["useboth",		'Use Current and Published ZSK for signing.'],
	       ["usepub",		'Use Published ZSK for signing.'],
	       ["intermediate=s",	'Intermediate zone file.'],
	       ["nosave",		'Do not save old keys.'],
	     );

my $forceroll	= 0;			# Force-a-ZSK-rollover flag.
my $useboth	= 0;			# Use-current-and-published-ZSK flag.
my $usepub	= 0;			# Use-published-ZSK flag.

#
# Do our work.
#
$status = main();
exit($status);

#----------------------------------------------------------------------
# Routine:	main()
#
# Purpose:	Yeah, yeah, a main() isn't necessary.  However, it offends my
#		sense of aesthetics to have great gobs of code on the same
#		level as a pile of globals.
#
#		But what about all those globals, you ask...
#
sub main
{
	my $status;				# Status of zone-signing.

	#
	# Give the usage and exit if help was specified.
	#
	helpchk();

	#
	# Munch on the options and arguments.  Print out our options,
	# according to our verbosity level.  Make sure our BIND commands
	# are available.
	#
	optsandargs();
	printopts();
	cmdcheck(\%opts);

	#
	# Ensure that the required data were specified.
	#
	if(($zone eq "") || ($zonefile eq "") || ($zoneout eq ""))
	{
		print STDERR "no zone specified\n";
		usage(2);
	}

	#
	# Ensure the zone file is okay before proceeding.
	#
	verify_zonefile();

	#
	# Maybe display the warning about potential entropy hangs.
	# We'll also force output to be flushed at write-time.
	#
	$| = 1;
	if($entropymsg)
	{
		print "\n\tif zonesigner appears hung, strike keys until the program completes\n";
		print "\t(see the \"Entropy\" section in the man page for details)\n\n";
	}

	#
	# Generate the KSK and ZSK key files.
	#
	genkeys();

	#
	# Create the key directories and move the key files into the
	# appropriate repositories.
	#
	keydirs();

	#
	# Create the unsigned zone file and add include lines for the key files.
	#
	zoneincludes();

	#
	# Sign the zone with the new keys and ensure the signing succeeded.
	#
	$status = zonesign();
	return($status);
}

#----------------------------------------------------------------------
# Routine:	optsandargs()
#
# Purpose:	Parse the command line for options and arguments.
#
sub optsandargs()
{
	my $argc;			# Number of arguments.
	my $ropts;			# Reference to the option hash.

	vprint("checking options and arguments\n");

	#
	# Make sure we have arguments.
	#
	$argc = @ARGV;
	usage(3) if($argc == 0 && !(eval {require Getopt::GUI::Long;}));

	#
	# Set the options, try to use the config file, the command line
	# options and a keyrec file.  We'll take the following steps in
	# trying to get a good set of options.
	#
	#  1. Set options from config file, command line, and a keyrec.
	#     Look in the options for -krfile and -keyrec to find the keyrec.
	#  2. Set options from config file, command line, and a keyrec.
	#     Use our first argument is a zone name, and assume there's
	#     a -krfile.  (Previous step showed there isn't a -keyrec.)
	#  3. Set options from the config file and command line.  No keyrec
	#     will be used.
	#
	opts_setcsopts(@zsopts);
	opts_createkrf();
	$ropts = opts_zonekr();
	%opts = %$ropts    if($ropts != undef);

	#
	# Get the KSK- and ZSK-related arguments.
	#
	$ksize	  = $opts{'ksklength'}	  || dnssec_tools_default("ksklength");
	$zsize	  = $opts{'zsklength'}	  || dnssec_tools_default("zsklength");
	$ksklife  = $opts{'ksklife'}	  || dnssec_tools_default("ksklife");
	$zsklife  = $opts{'zsklife'}	  || dnssec_tools_default("zsklife");
	$kskdir	  = $opts{'kskdirectory'} || '.';
	$zskdir	  = $opts{'zskdirectory'} || '.';
	$genksk	  = $opts{'genksk'}	  || $DEF_REUSEKSK;
	$genzsk	  = $opts{'genzsk'}	  || $DEF_REUSEZSK;
	$useboth  = $opts{'useboth'}	  || 0;
	$usepub	  = $opts{'usepub'}	  || 0;

	if(defined($opts{'kskcount'}))	{ $kskcnt = $opts{'kskcount'}; }
	else				{ $kskcnt = 1; }

	if(defined($opts{'zskcount'}))	{ $zskcnt = $opts{'zskcount'}; }
	else				{ $zskcnt = 1; }

	#
	# Get the rest of the options.
	#
	$alg	  = $opts{'algorithm'}	|| dnssec_tools_default("algorithm");
	$archdir  = $opts{'archivedir'}	|| "";
	$enddate  = $opts{'endtime'}	|| dnssec_tools_default("enddate");
	$gends	  = $opts{'gends'}	|| "";
	$random   = $opts{'random'}	|| dnssec_tools_default("random");
	$kgopts   = $opts{'kgopts'}	|| "";
	$ksdir	  = $opts{'ksdir'}	|| "";
	$savekeys = $DEF_SAVEKEYS;
	$savekeys = 0 if(defined($opts{'nosave'}));
#	$savekeys = $opts{'savekeys'}	|| $DEF_SAVEKEYS;
	$ksignset = $opts{'ksignset'}	|| "";
	$signset  = $opts{'signset'}	|| "";
	$szopts   = $opts{'szopts'}	|| "";
	$krfile   = $opts{'krfile'}	|| "";
	$nokrfile = $opts{'nokrfile'}	|| "";
	$zone	  = $opts{'zone'};

	#
	# If -genkeys was given, then we'll set -genksk and -genzsk.
	#
	if(defined($opts{'genkeys'}))
	{
		$genksk = 1;
		$genzsk = 1;
	}

	#
	# Check for the ZSK rollover flag.
	#
	$forceroll = 0;
	$forceroll = 1 if(defined($opts{'forceroll'}));

	#
	# Set up options and values, saving to global scalars and also
	# saving to %opts for use when saving the new keyrec.
	#
	if($ksize ne "")
	{
		$opts{'ksklength'} = $ksize;
		$ksize = "-b $ksize";
	}

	if($zsize ne "")
	{
		$opts{'zsklength'} = $zsize;
		$zsize = "-b $zsize";
	}

	if($kskcnt < 1)
	{
		print STDERR "KSK count ($zskcnt) must be positive\n";
		exit(1);
	}
	$opts{'kskcount'} = $kskcnt;

	if($zskcnt < 1)
	{
		print STDERR "ZSK count ($zskcnt) must be positive\n";
		exit(1);
	}
	$opts{'zskcount'} = $zskcnt;

	if($alg ne "")
	{
		$opts{'algorithm'} = $alg;
		$alg = "-a $alg";
	}

	if($enddate ne "")
	{
		$opts{'enddate'} = $enddate;
		$enddate = "-e $enddate";
	}

	if($ksdir ne "")
	{
		$opts{'ksdir'} = $ksdir;
		$ksdir = "-d $ksdir";
	}

	if($random ne "")
	{
		$opts{'random'} = $random;
		$random = "-r $random";
	}

	$gends	 = "-g"		 if($gends ne "");

	#
	# Ensure that the ZSK archive directory is a real directory,
	# if it already exists.  This is only checked if -forceroll was
	# given, since the only time the archive directory is used is
	# when zonesigner is doing a rollover.
	#
	if($forceroll)
	{
		if($archdir ne "")
		{
			if((-e $archdir) && (! -d $archdir))
			{
				print STDERR "ZSK archive directory $archdir is not a directory\n";
				exit(1);
			}
		}
		else
		{
			if($savekeys)
			{
				print STDERR "no ZSK archive directory specified\n";
				exit(1);
			}
		}
	}

	#
	# Ensure that we weren't told to both save and not save old keys.
	#
	if(defined($opts{'nosave'}) && defined($opts{'savekeys'}))
	{
		print STDERR "-savekeys and -nosave are mutually exclusive\n";
		exit(1);
	}

	#
	# Set up flags for various helpful messages.
	#
	if(defined($opts{'entropy_msg'}))
	{
		$entropymsg = $opts{'entropy_msg'};
	}
	$help	 = $opts{'help'};
	$version = $opts{'Version'};
	$verbose = $opts{'verbose'};

	version() if ($version);

	#
	# Get the paths to the external commands.  If they aren't defined,
	# use the default command names.
	#
	$keygen	   = $opts{'keygen'}    || dnssec_tools_default("keygen");
	$zonecheck = $opts{'zonecheck'} || dnssec_tools_default("zonecheck");
	$zonesign  = $opts{'zonesign'}  || dnssec_tools_default("zonesign");

	#
	# Turn off the usepub flag if -useboth was given.
	#
	$usepub = 0	if($useboth);

	#
	# Ensure that we were given the zone file and the zone output file.
	#
	$argc = @ARGV;
	usage(4) if(($argc != 1) && ($argc != 2));

	#
	# Get the zone file name.
	#
	$zonefile = $ARGV[0];

	#
	# Get the intermediate file name.  If -intermediate was specified,
	# we'll use it.  If not, we'll append ".zs" to the zone file name.
	#
	if(exists($opts{'intermediate'}))
	{
		$zoneftmp = $opts{'intermediate'};
		$zftmp = 1;
	}
	else
	{
		$zoneftmp = $zonefile . ".zs";
		$zoneftmp =~ s/\.\.zs"/.zs/;
		$zftmp = 0;
	}

	#
	# Get the file name for the signed zone.
	#
	if(exists($ARGV[1]))
	{
		$zoneout = $ARGV[1];
	}
	else
	{
		$zoneout = $zonefile . ".signed";
		$zoneout =~ s/\.\.zs"/.zs/;
	}

	#
	# Ensure that the zone file, signed zone file, and intermediate
	# zone file are all distinct.
	#
	if(($zonefile eq $zoneftmp)	||
	   ($zonefile eq $zoneout)	||
	   ($zoneftmp eq $zoneout))
	{
		print STDERR "the zone file, output file, and intermediate file must have distinct names\n";
		print STDERR "\tzone file	  -	$zonefile\n";
		print STDERR "\toutput file	  -	$zoneout\n";
		print STDERR "\tintermediate file -	$zoneftmp\n";
		exit(8);
	}

	#
	# If the -zone option wasn't specified, we'll use the zone filename
	# as the zone name.
	#
	if(!defined($opts{'zone'}))
	{
		$zone = $zonefile;
		$opts{'zone'} = $zonefile;
	}

	#
	# If the keyrec file is empty, we'll create a keyrec for
	# the zone.
	#
	chkkrf();

	#
	# Ensure that two mutually exclusive keyrec file options aren't given.
	#
	if(defined($opts{'krfile'}) && defined($opts{'nokrfile'}))
	{
		print STDERR "-krfile and -nokrfile are mutually exclusive\n";
		usage(5);
	}

}

#----------------------------------------------------------------------
# Routine:	verify_zonefile()
#
# Purpose:	Ensure that the specified zone file is valid.  The BIND
#		dnssec-checkzone program is run to verify it, the length and
#		non-nullity are checked, and then a check is made to ensure
#		it hasn't been signed already.
#		If this routine returns, the zone file is fine.
#
sub verify_zonefile
{
	my $statlen;				# Length of stat() buffer.
	my $status;				# Status of zone checking.

	vprint("check existence of zone file\n");
	if(! -f $zonefile)
	{
		print STDERR "zone file \"$zonefile\" does not exist\n";
		exit(1);
	}

	vprint("initial zone verification\n");
	$status = system("$zonecheck -q $zone $zonefile");
	if($status != 0)
	{
		$status = system("$zonecheck $zone $zonefile");
		exit($status);
	}
	system("$zonecheck $zone $zonefile") if($verbose > $VERBOSE_LOW);
	vmed_print("zone verified\n\n");

	#
	# Ensure that the zone file isn't empty and open it.
	#
	$statlen = @zonestat = stat($zonefile);
	if($statlen == 0)
	{
		print STDERR "zone file $zonefile is empty\n";
		exit(1);
	}
	open(ZF,"+< $zonefile") or die "unable to open zone file $zonefile";

	#
	# Ensure that the zone file has not been signed yet.
	#
	if(presigned())
	{
		print STDERR "zone file $zonefile already signed\n";
		exit(1);
	}
}

#----------------------------------------------------------------------
# Routine:	presigned()
#
# Purpose:	Ensure that the specified zone file is not a signed zone file.
#		We'll check for the presence of a signed-specific record.
#
#		Returns:
#			0 - Zone not previously signed.
#			1 - Zone previously signed.
#
sub presigned
{
	my $file = "";				# Contents of zone file.
	my $flen = 0;				# Length of zone file.
	my $hitcnt;				# Number of RRSIGs in file.
	my @hits;				# RRSIG hits.

	#
	# Get the zone file's length and contents.
	#
	$flen = $zonestat[7];
	seek(ZF,0,0);
	read(ZF,$file,$flen);

	$hitcnt = @hits = $file =~ /RRSIG/mg;

	#
	# If we found some RRSIG records, return a true value.  If not,
	# return a false value.
	#
	return(1) if($hitcnt > 0);
	return(0);
}

#----------------------------------------------------------------------
# Routine:	genkeys()
#
# Purpose:	Generate new KSK and ZSK keys.  New keyrecs for the new keys
#		are added to the keyrec file.
#
sub genkeys
{
	vprint("generating key files\n");

	#
	# Generate the set of ZSK keys.
	#
	genzsks();

	#
	# Generate the set of KSK keys.
	#
	genksks();
}

#----------------------------------------------------------------------
# Routine:	genzsks()
#
# Purpose:	Generate the set of ZSK keys.  New keyrecs for the new keys
#		are added to the keyrec file.
#
sub genzsks
{
	my $setname;				# Name of signing set.
	my $keyset;				# Keys in signing set.

	#
	# Handle a ZSK rollover.
	#
	if($forceroll)
	{
		#
		# Get the current ZSK list.
		#
		$setname = $opts{'zskcur'};
		$keyset  = keyrec_recval($setname,'keys');
		$zskcursetname = $setname;
		@zskcurlist = split / /, $keyset;

		#
		# Get the published ZSK list.
		#
		$setname = $opts{'zskpub'};
		$keyset  = keyrec_recval($setname,'keys');
		$zskpubsetname = $setname;
		@zskpublist = split / /, $keyset;

		#
		# Get the new ZSK list.
		#
		$setname = $opts{'zsknew'};
		$keyset  = keyrec_recval($setname,'keys');
		$zsknewsetname = $setname;
		@zsknewlist = split / /, $keyset;

		#
		# Do the rollover.
		#
		forceroll();
		vmed_print("\n");
		return;
	}

	#
	# If we're reusing the ZSKs, ensure they're already defined and return.
	#
	if($genzsk == 0)
	{
		my $keyset;			# Keys in signing set.
		my $setname;			# Name of signing set.
		my $curstr;			# Name of current ZSK hashkey.

		#
		# Get the name of the current ZSK set -- either from the
		# -signset command line option or from the keyrec file itself.
		#
		if($signset)
		{
			#
			# Ensure that this is a valid signing set.
			#
			if(!keyrec_exists($signset))
			{
				print STDERR "signing set \"$signset\" does not exist\n";
				exit(2);
			}

			$zskcursetname	 = $signset;
			$opts{'zskcur'}  = $zskcursetname;
			$opts{'lastset'} = $zskcursetname;
			keyrec_setval('zone',$zone,'lastset',$zskcursetname);

			$curstr = "Signing Set $zskcursetname";
		}
		else
		{
			$zskcursetname = $opts{'zskcur'};
			$curstr  = 'cur ZSK';
		}

		#
		# Ensure that we've got a Current ZSK set.
		#
		if($opts{'zskcur'} eq "")
		{
			print STDERR "\n$curstr does not exist; unable to re-use non-existent cur ZSK\n";
			exit(1);
		}

		#
		# Get the Current ZSKs.
		#
		$keyset  = keyrec_recval($zskcursetname,'keys');
		@zskcurlist = split / /, $keyset;

		#
		# Ensure that we've got a Current ZSK set.
		#
		if($opts{'zskcur'} eq "")
		{
			print STDERR "\npub ZSK does not exist; unable to re-use non-existent pub ZSK\n";
			exit(1);
		}

		#
		# Get the Published ZSK set name.
		#
		$zskpubsetname = $opts{'zskpub'};
		vprint("reusing existing pub ZSK set - $zskpubsetname\n");

		#
		# Get the Published ZSKs.
		#
		$keyset  = keyrec_recval($zskpubsetname,'keys');
		@zskpublist = split / /, $keyset;

		return;
	}

	#
	# If no signing set was specified, we'll generate new keys and use
	# them as the only keys for signing.
	#
	# If a signing set was specified we'll do one of the following:
	#	- use those keys (if the set already exists),
	#	- generate new keys (if that set doesn't already exist).
	#
	if($signset ne "")
	{

		if(keyrec_fullrec($signset) ne "")
		{
			print STDERR "\nSigning set named \"$signset\" already exists\n";
			exit(1);
		}

		$zskpubsetname = $signset;
		$zskcursetname = keyrec_signset_newname($zone);
	}
	else
	{
		$zskcursetname = keyrec_signset_newname($zone);
		$zskpubsetname = keyrec_signset_newname($zone);
	}

	#
	# Create the new signing sets.
	#
	keyrec_signset_new($zone,$zskcursetname);
	keyrec_signset_new($zone,$zskpubsetname);
	$lastset = keyrec_recval($zone,'lastset');

	#
	# Generate a set of current ZSKs and save their names.
	#
	for(my $ind=0; $ind < $zskcnt; $ind++)
	{
		my $key = genzsk("cur");		# Name of new key.
		push @zskcurlist, $key;
	}

	#
	# Generate a set of published ZSKs and save their names.
	#
	for(my $ind=0; $ind < $zskcnt; $ind++)
	{
		my $key = genzsk("pub");		# Name of new key.
		push @zskpublist, $key;
	}

	#
	# Save the keyrec file.
	#
	updzonerec($UPD_ZSKS);
	vmed_print("\n");
}

#----------------------------------------------------------------------
# Routine:	genksks()
#
# Purpose:	Generate the set of KSK keys.  New keyrecs for the new keys
#		are added to the keyrec file.
#
sub genksks
{
	my $setname;				# Name of signing set.
	my $keyset;				# Keys in signing set.

	#
	# If we're reusing the KSKs, ensure they're already defined and return.
	#
	if($genksk == 0)
	{
		my $keyset;			# Keys in signing set.
		my $setname;			# Name of signing set.

		#
		# Ensure that we've got a KSK set.
		#
		if($opts{'kskkey'} eq "")
		{
			print STDERR "\nKSK does not exist; unable to re-use non-existent KSK\n";
			exit(1);
		}

		#
		# Get the KSK set name.
		#
		$ksksetname = $opts{'kskkey'};
		if(!keyrec_exists($ksksetname))
		{
			print STDERR "\nKSK keyrec \"$ksksetname\" does not exist; unable to re-use non-existent KSK\n";
			exit(1);
		}

		vprint("reusing existing KSK set - $ksksetname\n");

		#
		# Get the KSKs.
		#
		$keyset  = keyrec_recval($ksksetname,'keys');
		@ksklist = split / /, $keyset;

		return;
	}

	#
	# Get the name of the KSK set -- either from the -ksignset command
	# line option or from the keyrec file itself.
	#
	if($ksignset)
	{
		#
		# Get the KSK set name and ensure it exists.
		#
		$ksksetname = $ksignset;
		if(!keyrec_exists($ksksetname))
		{
			print STDERR "\nKSK signing set \"$ksksetname\" does not exist; unable to re-use non-existent KSK\n";
			exit(1);
		}
	}
	else
	{
		if(defined($opts{'kskkey'}))
		{
			$ksksetname = $opts{'kskkey'};
		}
		else
		{
			$ksksetname = keyrec_signset_newname($zone)
		}
	}

	#
	# Create the new signing sets.
	#
	keyrec_signset_new($zone,$ksksetname);
	$lastset = keyrec_recval($zone,'lastset');

	#
	# Generate a set of KSKs and save their names.
	#
	for(my $ind=0; $ind < $kskcnt; $ind++)
	{
		my $key = genksk();			# Generate new key.
		push @ksklist, $key;
	}

	#
	# Save the keyrec file.
	#
	updzonerec($UPD_KSKS);
	vmed_print("\n");
}

#----------------------------------------------------------------------
# Routine:	genksk()
#
# Purpose:	Generate a new KSK key.
#
sub genksk
{
	my $ksk;				# KSK name.
	my $cmdopts;				# Options for dnssec-keygen.
	my $zskdir;				# ZSK directory for saving.

	#
	# If we're reusing the KSK, ensure it's been created and return.
	#
	if($genksk == 0)
	{
		if($opts{'kskkey'} eq "")
		{
			print STDERR "\nunable to re-use a non-existent KSK for zone \"$opts{'zone'}\"\n";
			exit(1);
		}

		$ksk = $opts{'kskkey'};
		vprint("reusing existing KSK - $ksk\n");

		return;
	}

	vmed_print("generating new KSK\n");

	#
	# Generate the new KSK.
	#
	$cmdopts = "$kgopts $random $alg $ksize";
	vhigh_print("$keygen $cmdopts -n zone -f KSK $zone\n");
	$ksk = `$keygen $cmdopts -n zone -f KSK $zone`;
	if($? != 0)
	{
		print STDERR "unable to generate KSK key file;\n";
		print STDERR "dnssec-keygen returned $?\n" if($verbose);
		exit(1);
	}
	chomp $ksk;
	vmed_print("new KSK - $ksk\n\n");

	#
	# Save and kill the ZSK directory.
	#
	$zskdir = $opts{'zskdirectory'};
	delete $opts{'zskdirectory'};

	#
	# Add the KSK's keyrec to the keyrec file.
	#
	$opts{'keyrec_type'} = "ksk";
	$opts{'keypath'}     = "$kskdir/$ksk.key";
	$opts{'kgopts'}      = $kgopts if($kgopts ne "");
	keyrec_add('key',$ksk,\%opts);

	#
	# Restore the ZSK directory and dump the keyrec type.
	#
	$opts{'zskdirectory'} = $zskdir;
	delete $opts{'keyrec_type'};

	#
	# Save the keyrec file.
	#
	updzonerec($UPD_KSKS);
	return($ksk);
}

#----------------------------------------------------------------------
# Routine:	genzsk()
#
sub genzsk
{
	my $keytype = shift;		# ZSK type:  cur, new, pub.

	my $cmdopts;			# Options for dnssec-keygen.
	my $kskdir;			# KSK directory for saving.
	my $zskkey;			# Hash key for this ZSK.
	my $zsk;			# Generated key.

	#
	# Get the hash key for the ZSK we're going to generate.
	#
	$zskkey = "zsk" . $keytype;

	#
	# If we're reusing the ZSK, ensure it's already defined and return.
	#
	if($genzsk == 0)
	{
		if(keyrec_fullrec($opts{$zskkey}) eq "")
		{
			print STDERR "\n$keytype ZSK keyrec does not exist; unable to re-use non-existent $keytype ZSK\n";
			exit(1);
		}

		$zsk = $opts{$zskkey};
		vprint("reusing existing $keytype ZSK - $zsk\n");

		return($zsk);
	}

	vmed_print("generating new \"$keytype\" ZSK\n");

	#
	# Generate a ZSK key.
	#
	$cmdopts = "$kgopts $random $alg $zsize";
	vhigh_print("$keygen $cmdopts -n zone $zone\n");
	$zsk = `$keygen $cmdopts -n zone $zone`;
	if($? != 0)
	{
		print STDERR "unable to generate $keytype ZSK key file;\n";
		print STDERR "dnssec-keygen returned $?\n" if($verbose > $VERBOSE_LOW);
		exit(1);
	}
	chomp $zsk;
	vmed_print("new \"$keytype\" ZSK - $zsk\n");

	#
	# Save and kill the KSK directory.
	#
	$kskdir = $opts{'kskdirectory'};
	delete $opts{'kskdirectory'};

	#
	# Add the ZSK's keyrec to the keyrec file.
	#
	$opts{'keyrec_type'} = "$zskkey";
	$opts{'keypath'}     = "$zskdir/$zsk.key";
	$opts{'kgopts'}	     = $kgopts if($kgopts ne "");
	keyrec_add('key',$zsk,\%opts);
	$opts{"$zskkey"} = $zsk;

	#
	# Restore the KSK directory and dump the keyrec type.
	#
	$opts{'kskdirectory'} = $kskdir;
	delete $opts{'keyrec_type'};
	delete $opts{'kgopts'} if($kgopts ne "");

	return($zsk);
}

#----------------------------------------------------------------------
# Routine:	keydirs()
#
# Purpose:	Check the validity of the key directories and move the newly
#		generated key in.  Don't do anything if the directory is '.' 
#
sub keydirs
{
	vmed_print("checking key directories\n");

	#
	# Ensure the KSK key directory exists and is actually a directory.
	#
	if($genksk && ($kskdir ne "."))
	{
		if(! -e $kskdir)
		{
			vprint("creating KSK directory - $kskdir\n");
			mkdir($kskdir);
		}
		elsif(! -d $kskdir)
		{
			print STDERR "KSK repository ($kskdir) is not a directory\n";
			exit(3);
		}

		foreach my $ksk (@ksklist)
		{
			system("$MV $ksk.* $kskdir");
		}
	}

	#
	# Ensure the ZSK key directory exists and is a directory.
	#
	if($genzsk && ($zskdir ne "."))
	{
		if(! -e $zskdir)
		{
			vprint("creating ZSK directory - $zskdir\n");
			mkdir($zskdir);
		}
		elsif(! -d $zskdir)
		{
			print STDERR "ZSK repository ($zskdir) is not a directory\n";
			exit(3);
		}

		system("$MV $zskcur.* $zskdir");
		system("$MV $zskpub.* $zskdir");
	}

	vmed_print("\n");
}

#----------------------------------------------------------------------
# Routine:	zoneincludes()
#
# Purpose:	Add include statements to the zone file for the key files.
#
sub zoneincludes
{
	my $file;				# Zone's contents.
	my $flen;				# Zone file's length.
	my $newserial;				# Zone's new serial number.

	vhigh_print("\n");
	vprint("adding key includes to zone file\n");

	#
	# Update the zone data's serial number.
	#
	$newserial = serialincr();
	if($newserial == -1)
	{
		print STDERR "unable to update serial number in $zonefile\n";
		exit(3);
	}
	vmed_print("$zone\'s new serial number - $newserial\n\n");

	#
	# If there are already include lines in the zone file, we'll
	# adjust the lines to get the current files.
	#
	if(hasincludes())
	{
		my $newfile = "";		# New zone contents.
		my $tail    = "";		# Tail end of zone searches.

		#
		# Get the data from the zone file.
		#
		seek(ZF,0,0);
		@zonestat = stat($zonefile);
		$flen = $zonestat[7];
		read(ZF,$file,$flen);

		#
		# Find our region of the file.  If we've messed with this
		# file once before, we'll adjust the existing lines.  If we
		# haven't, we'll get rid of any existing key inclusions and
		# then add our own.
		#
		#
		if($file =~ /manipulated by DNSSEC-Tools./si)
		{
			$newfile = $` . $&;
		}
		else
		{
			my $incpat;			# Pattern for includes.

			#
			# Delete any existing key inclusions already in
			# the zone file.  This is just the inclusions
			# themselves; no related comments are removed.
			#
			$incpat = '\$INCLUDE.*?\.key.*?\n';
			while($file =~ /$incpat/si)
			{
				my $matchline = $&;	# Matching line.
				my $matchkey;		# Key from matchline.

				$file =~ s/$incpat//;

				if($verbose > $VERBOSE_LOW)
				{
					$matchline =~ /(".*")/;
					$matchkey = $1;
					print "deleting include line for $matchkey\n";
				}
			}

			#
			# The new file is the old file, minus include lines.
			#
			$newfile = $file;
		}

		#
		# Generate our include lines.
		#
		$tail = getincl();

		#
		# ... and add the modified end of the file to our saved end.
		#
		$newfile .= $tail . "\n";

		#
		# If the new file has a length of zero, we've got a problem,
		# Houston.
		#
		if(length($newfile) == 0)
		{
			print STDERR "strange error -- the massaged zone file has a length of zero; stopping\n";
			exit(1);
		}

		#
		# Re-write the zone file.
		#
		seek(ZF,0,0);
		truncate(ZF,0);
		print ZF $newfile;
		close(ZF);

		#
		# Copy the zone data to a new file.
		#
		system("$CP $zonefile $zoneftmp") if($zonefile ne $zoneftmp);
		open(ZF,"+< $zonefile");
		@zonestat = stat($zonefile);
	}
	else
	{
		my $incstr;			# Include section.

		#
		# Copy the zone data to a new file.
		#
		system("$CP $zonefile $zoneftmp") if($zonefile ne $zoneftmp);

		#
		# Get the include-keys section.
		#
		$incstr = getincl();

		#
		# Add lines to include the KSK and ZSK files.
		#
		open(ZF,">> $zoneftmp");
		print ZF $incstr;

		close(ZF);
	}
}

#----------------------------------------------------------------------
# Routine:	zonesign()
#
# Purpose:	Sign the zone with the new keys and ensure that the signing
#		succeeded.
#
sub zonesign
{
	my $chron;			# Today's date.
	my $keytag;			# Tag value from keys.
	my $szone;			# Result from dnssec-signzone execution.
	my $useksks;			# KSKs to use in zone-signing.
	my @usekeys;			# Keys to use in zone-signing.
	my $cmdopts;			# Options for dnssec-signzone.
	my $status;			# Execution return code.

	#
	# Build the collection of KSKs.
	#
	$useksks = join " -k ", @ksklist;
	$useksks = "-k $useksks";

	#
	# Build a set of options for dnssec-signzone.  This isn't strictly
	# necessary, but it does keep the dnssec-signzone execution a bit
	# cleaner than it would be otherwise.
	#
	$cmdopts = "$szopts $gends $ksdir $useksks -o $zone $enddate -f $zoneout";

	#
	# Normally, we'll use the Current ZSKs; however, we'll use the
	# Published ZSKs if the user gave -usepub.  We'll use both
	# Current and Published ZSKs if the user gave -useboth.
	#
	@usekeys = sort(@zskcurlist);
	@usekeys = sort(@zskpublist)	 if($usepub);
	push @usekeys, sort(@zskpublist) if($useboth);

	#
	# Sign the zone with the new keys.
	#
	vprint("signing zone\n");
	vhigh_print("$zonesign $cmdopts $zoneftmp @usekeys\n");

	$szone = `$zonesign $cmdopts $zoneftmp @usekeys`;
	if($szone eq "")
	{
		print STDERR "unable to sign zone\n";
		exit(1);
	}

	#
	# Ensure the signing succeeded.
	#
	vprint("checking zone\n");
	$status = system("$zonecheck -q $zone $szone");
	if($status != 0)
	{
		print STDERR "problems with zone signing\n";
		system("$zonecheck $zone $szone");
		return($status);
	}

	#
	# Add the ZSK's keyrec to the keyrec file.
	#
	updzonerec($UPD_ALLKEYS);

	#
	# Get today's date.
	#
	$chron = `$DATE +"%m/%d/%y"`;
	$chron =~ s/\n//;

	#
	# Give success message and zone info.
	#
	print "\nzone signed successfully\n\n";
	print "${zone}:\n";

	#
	# Get the KSK tag values.
	#
	foreach my $ksk (sort(@ksklist))
	{
		$ksk =~ /.*\+.*\+([0-9][0-9]*)/;
		$keytag = $1;
		print "\tKSK       $keytag  $ksize  $chron\n";
	}

	#
	# Get the current ZSK tag values.
	#
	foreach my $zskcur (sort(@zskcurlist))
	{
		$zskcur =~ /.*\+.*\+([0-9][0-9]*)/;
		$keytag = $1;
		print "\tZSK (cur) $keytag  $zsize  $chron\n";
	}

	#
	# Get the published ZSK tag values.
	#
	foreach my $zskpub (sort(@zskpublist))
	{
		$zskpub =~ /.*\+.*\+([0-9][0-9]*)/;
		$keytag = $1;
		print "\tZSK (pub) $keytag  $zsize  $chron\n";
	}

	#
	# Inform user when the zone will expire.
	#
	if($enddate)
	{
		my $edcopy = $enddate;		# Copy of the zone end date.
		my $datestr;			# Translated end date.

		$edcopy =~ s/^\-e \+//;
		$datestr = timetrans($edcopy);

		print "\n";
		print "zone will expire in $datestr\n";
		print "DO NOT delete the keys until this time has passed.\n";
	}

	#
	# If the intermediate zone file wasn't specified, we'll delete
	# the temporary zone file.  If a debug flag is set, we'll copy
	# the zone temporary file before deleting it.
	#
	if(!$zftmp)
	{
		if($DEBUG_ZONETMP)
		{
			my $now = time();
			my $newzftmp = "$zoneftmp.$now";
			system("/bin/cp $zoneftmp $newzftmp");
		}

		system("$RM $zoneftmp");
	}

	return(0);
}

#----------------------------------------------------------------------
# Routine:	updzonerec()
#
# Purpose:	Add the zone's keyrec to the keyrec file.  Also, we'll add the
#		zone's name to the keyrecs of its keys.
#
sub updzonerec
{
	my $updflag = shift;			# Update flag.
	my $chronosecs;				# Current time in seconds.
	my $chronostr;				# Current time string.
	my $kr;					# Zone's keyrec reference.
	my %keyrec;				# Zone's keyrec.
	my $setnames;				# Signing set contents.

	if($verbose > $VERBOSE_LOW)
	{
		if(($verbose == $VERBOSE_HIGH) || ($updflag == $UPD_ALLKEYS))
		{
			print "\tupdating the keyrec file for the zone\n";
		}
	}

	#
	# Generate some signing-set names if we need them.
	#
	if((($updflag & $UPD_KSKS) == $UPD_KSKS) && ($ksksetname eq ""))
	{
		$ksksetname = keyrec_signset_newname($zone);
	}
	if(($updflag & $UPD_ZSKS) == $UPD_ZSKS)
	{
		$zskcursetname = keyrec_signset_newname($zone) if($zskcursetname eq "");
		$zskpubsetname = keyrec_signset_newname($zone) if($zskpubsetname eq "");
	}

	#
	# Set some fields we've got to have -- in case they aren't
	# set in the options.
	#
	if(!$zftmp) { $opts{'zonefile'} = $zonefile; }
	else	    { $opts{'zonefile'} = $zoneftmp; }
	$opts{'signedzone'}	= $zoneout;
	$opts{'kskdirectory'}	= $kskdir;
	$opts{'kskkey'}		= $ksksetname if(defined($ksksetname));
	$opts{'zskcount'}	= $zskcnt;
	$opts{'zskdirectory'}	= $zskdir;
	$opts{'szopts'}		= $szopts if($szopts ne "");
	$opts{'zskcur'}		= $zskcursetname;
	$opts{'zskpub'}		= $zskpubsetname;
	$opts{'lastset'}	= keyrec_recval($zone,'lastset');

	#
	# Save the zone end time and delete the option prefix.
	#
	$opts{'endtime'} = $enddate;
	$opts{'endtime'} =~ s/^-e //;

	#
	# Get the keyrec for the zone.  If there isn't one, it's a new
	# zone and we'll create a new keyrec.
	#
	$kr = keyrec_fullrec($zone);
	if(!defined($kr))
	{
		keyrec_add('zone',$zone,\%opts);
	}
	else
	{

		#
		# If there is a keyrec for the zone, we'll make sure the
		# defined zone keyrec fields are set.
		#
		foreach my $field (keyrec_zonefields())
		{
			if(defined($opts{$field}))
			{
				keyrec_setval('zone',$zone,$field,$opts{$field});
			}
		}
	}

	#
        # Set a timestamp for the zone entry.
	#
	$chronosecs = time();
	$chronostr  = gmtime($chronosecs);
	keyrec_setval('zone',$zone,'keyrec_signsecs',$chronosecs);
	keyrec_setval('zone',$zone,'keyrec_signdate',$chronostr);

	#
	# Save the signing-set names and set the zone owners for KSKs.
	#
	if(($updflag & $UPD_KSKS) == $UPD_KSKS)
	{
		$setnames = join ' ', @ksklist;
		keyrec_setval('set',$ksksetname,'keys',$setnames);

		foreach my $ksk (@ksklist)
		{
			keyrec_setval('key',$ksk,'zonename',$zone)
		}
	}

	#
	# Save the signing-set names and set the zone owners for ZSKs.
	#
	if(($updflag & $UPD_ZSKS) == $UPD_ZSKS)
	{
		$setnames = join ' ', @zskcurlist;
		keyrec_setval('set',$zskcursetname,'keys',$setnames);
		$setnames = join ' ', @zskpublist;
		keyrec_setval('set',$zskpubsetname,'keys',$setnames);

		foreach my $zsk (@zskcurlist)
		{
			keyrec_setval('key',$zsk,'zonename',$zone)
		}
		foreach my $zsk (@zskpublist)
		{
			keyrec_setval('key',$zsk,'zonename',$zone)
		}
	}

	#
	# Save the keyrec file.
	#
	keyrec_write();
}

#----------------------------------------------------------------------
# Routine:	hasincludes
#
# Purpose:	This routine returns a flag indicating if the zone file
#		includes any keys.
#
#		0 - zone file does not include keys
#		1 - zone file includes keys
#
sub hasincludes
{
	my $file = "";				# Contents of zone file.
	my $flen = 0;				# Length of zone file.
	my $keyname;				# Name of key from include.

	#
	# Get the zone file's length and contents.
	#
	seek(ZF,0,0);
	$flen = $zonestat[7];
	read(ZF,$file,$flen);

	#
	# Look for the key inclusion.
	#
	$file =~ /^\$INCLUDE \"(.+?)\"$/m;
	$keyname = $1;

	#
	# Give the appropriate response.
	#
	return(0) if($keyname eq "");
	return(1);
}

#----------------------------------------------------------------------
# Routine:	serialincr
#
# Purpose:	This routine increments the serial number of an SOA record in
#		a zone file.  The serial number is found in both the multi-
#		line parenthesize form and the single line unparenthesize form.
#
#		On success, the new serial number is returned.
#		On failure, -1 is returned.
#
sub serialincr
{
	my $file = "";				# Contents of zone file.
	my $flen = 0;				# Length of zone file.

	my $remnant;				# Contents after the SOA line.
	my $soafields;				# SOA's fields.
	my $serialnum;				# Current serial number.
	my $serialnew;				# New serial number.

	#
	# Get the zone file's length and contents.
	#
	$flen = $zonestat[7];
	seek(ZF,0,0);
	read(ZF,$file,$flen);

	#
	# Find the SOA line and save everything after it.
	#
	$file =~ /\s+IN\s+SOA\s+/si;
	$remnant = $';

	#
	# Find the SOA's parenthesized fields.
	#
	$remnant =~ /\(.*?\)/s;
	$soafields = $&;

	#
	# Get the SOA's serial number and increment it.
	#
	$soafields =~ /([0-9]+)/;
	$serialnum = $1;

	#
	# We'll use the larger serial number of the one in the zone file
	# and in the keyrec file.
	#
	if(defined($opts{'serial'}))
	{
		my $serial = $opts{'serial'};

		$serialnum = $serial if($serial > $serialnum);
	}

	#
	# We assumed the serial number was parenthesized.  If we didn't
	# find it, we'll look for it in an unparenthesized line.
	#
	if($serialnum eq "")
	{
		#
		# Pick up the SOA line.
		#
		$file =~ /\s+IN\s+SOA\s+/si;
		$remnant = $';

		#
		# Snork out the serial number.
		#
		$remnant =~ /\S+\s+\S+\s+(\S+)\s+/;
		$serialnum = $1;

		#
		# If we didn't find the serial number here either,
		# return a failure.
		#
		return(-1) if($serialnum eq "");
	}

	#
	# Increment the serial number and change it in the file contents.
	# We'll also save the new serial number in the keyrec.
	#
	$serialnew = $serialnum + 1;
	$file =~ s/$serialnum/$serialnew/;
	keyrec_setval('zone',$zone,'serial',$serialnew);
	$opts{'serial'} = $serialnew;

	#
	# Write the new file contents and close the file.
	#
	seek(ZF,0,0);
	truncate(ZF,0);
	print ZF $file;
	close(ZF);

	#
	# Re-open the zone file with the latest info.
	#
	@zonestat = stat($zonefile);
	open(ZF,"+< $zonefile");

	return($serialnew);
}

#----------------------------------------------------------------------
# Routine:	chkkrf()
#
# Purpose:	If we have a new keyrec file, we'll add a new keyrec
#		for the specified zone.  We'll set a few basic keyrec
#		files in the entry.
#
#		Condition order is important!  Don't re-arrange or condense
#		unless you know what you're doing!
#
sub chkkrf
{
	my %zoneopts;				# Initial fields for zone.

	#
	# If no keyrec file should be created, we'll return now.
	#
	if($nokrfile)
	{
		vprint("not using a keyrec file\n");
		return;
	}

	#
	# If no keyrec file was specified and we haven't been told not
	# to use a keyrec file, we'll use the default.
	#
	if($krfile eq "")
	{
		my $defkrf;			# Default keyrec file.

		#
		# Get the default keyrec file.  If there isn't one,
		# we'll use the zone name.
		#
		$defkrf = keyrec_defkrf();
		if($defkrf eq "")
		{
			$defkrf = $zone . ".krf";

			#
			# Eliminate any double-dotting where the suffix starts.
			#
			if($defkrf =~ /\.\.krf$/)
			{
				$defkrf =~ s/\.\.krf$/.krf/;
			}
		}

		#
		# Put the default keyrec file onto the argument vector
		# and redo the argument checking.
		#
		@ARGV = @saveargs;
		unshift(@ARGV,$defkrf);
		unshift(@ARGV,"-krfile");
		vprint("using default keyrec file $defkrf\n");

		#
		# Rescan our arguments.
		#
		opts_reset();
		optsandargs();
		return;
	}

	#
	# If the keyrec file is of non-zero length, we'll return now.
	#
	return if(-s $krfile);

	#
	# Set the basic zone keyrec fields for a zone.
	#
	$zoneopts{'keyrec_type'} = "zone";
	$zoneopts{'zonefile'}	 = $zonefile;

	#
	# Write the new zone keyrec into the keyrec file.
	#
	keyrec_open($krfile);
	keyrec_add('zone',$zone,\%zoneopts);
	keyrec_write();
	keyrec_close();

	#
	# Read in the keyrec file once more.
	#
	keyrec_read($krfile);

	vprint("using keyrec file $krfile\n");
}

#----------------------------------------------------------------------
# Routine:	getincl()
#
# Purpose:	Return the text used in the include lines.
#
sub getincl
{
	my $incstr;				# Include section.

	$incstr = <<EOF;

;;
;;
;; DO NOT DIRECTLY MODIFY ANYTHING BELOW THIS LINE.
;;
;;	All subsequent lines are added and manipulated by DNSSEC-Tools.
;;

;; KSKs
EOF

	#
	# Add the KSKs.
	#
	foreach my $ksk (sort(@ksklist))
	{
		my $path = keyrec_recval($ksk,'keypath');
		$path = "$path.key" if($path !~ /\.key$/);
		$incstr .= "\$INCLUDE \"$path\"\n";
	}

	#
	# Add the current ZSKs.
	#
	if(!$usepub)
	{
		$incstr .= "\n;; Current ZSKs\n";

		foreach my $zsk (sort(@zskcurlist))
		{
			my $path = keyrec_recval($zsk,'keypath');
			$path = "$path.key" if($path !~ /\.key$/);
			$incstr .= "\$INCLUDE \"$path\"\n";
		}
	}

	$incstr .= "\n;; Published ZSKs\n";

	#
	# Add the published ZSKs.
	#
	foreach my $zsk (sort(@zskpublist))
	{
		my $path = keyrec_recval($zsk,'keypath');
		$path = "$path.key" if($path !~ /\.key$/);
		$incstr .= "\$INCLUDE \"$path\"\n";
	}
	$incstr .= "\n";

	return($incstr);
}

#----------------------------------------------------------------------
# Routine:	forceroll()
#
# Purpose:	Force a rollover of the ZSK keys.  The Current ZSKs are marked
#		as obsolete.  The Published ZSKs are moved to being the Current
#		ZSKs.  If the zone has New ZSKs, they are moved to being the
#		Published ZSKs; if not, a new set of Published ZSKs are created.
#		Finally, a new set of New ZSKs are generated.
#
#		This should only be used if you know what you're doing.
#
sub forceroll
{
	my $krref;				# Reference to key's keyrec.
	my $zoneref;				# Reference to zone's keyrec.
	my $publife;				# Published ZSK's lifespan.
	my $setlist;				# List of key names.

	vprint("forcing a ZSK rollover\n");

	#
	# Ensure that a rollover makes sense.
	#
	if($opts{'zskpub'} eq "")
	{
		print STDERR "zone $zone has no published ZSK to rollover to a current ZSK\n";
		exit(1);
	}

	#
	# We're rolling ZSKs, so make sure they'll be generated.
	#
	$genzsk = 1;

	#
	# Get the zone's keyrec.
	#
	$zoneref = keyrec_fullrec($zone);

	#
	# Render the current ZSKs obsolete.  Their keyrecs will be marked as
	# zskobs and the keys will (may) be moved to the archive directory.
	#
	foreach my $k (@zskcurlist)
	{
		my $me;						# Key name.

		$krref = keyrec_fullrec($k);
		$me = $krref->{'keyrec_name'};

		#
		# Change the keyrec's type to obsolete ZSK.
		#
		$krref->{'keyrec_type'}	= "zskobs";
		keyrec_setval("key",$me,"keyrec_type","zskobs");

		#
		# If we're supposed to archive the keys, we'll move the obsolete
		# key off to the archive directory.
		#
		if($savekeys)
		{
			my $error = 0;				# Error flag.

			#
			# Make sure the archive directory exists and is
			# actually a directory.
			#
			if(! -e $archdir)
			{
				vmed_print("creating ZSK archive directory $archdir\n\n");
				system("$MKDIR -p -m 0700 $archdir");
			}
			else
			{
				if(! -d $archdir)
				{
					print STDERR "ZSK archive directory $archdir is not a directory; not archiving old ZSK key\n";
					$error = 1;
				}
			}

			#
			# If the archive directory exists, we'll move each of
			# this key's files into the directory.  We'll also add
			# a timestamp to the end of the filename, to prevent
			# potential collisions.
			#
			if($error == 0)
			{
				my $kronos = time;		# Timestamp.

				vhigh_print("moving $me to $archdir\n\n");

				foreach my $archfn (glob("$me.*"))
				{
					my $newname;		# New key name.

					$newname = "$archdir/$kronos.$archfn";

					system("$MV $archfn $newname");
				}
			}
		}

		vmed_print("current ZSK ($me) now obsolete\n");
	}
	@zskcurlist = ();

	#
	# Convert the published ZSKs into current ZSKs.
	#
	foreach my $k (@zskpublist)
	{
		my $me;						# Key name.

		#
		# Get the key's keyrec and name.
		#
		$krref = keyrec_fullrec($k);
		$me = $krref->{'keyrec_name'};

		#
		# Set the keyrec's type to ZSK current.
		#
		$krref->{'keyrec_type'} = 'zskcur';
		keyrec_setval("key",$me,"keyrec_type","zskcur");

		#
		# Set the time for this key.
		#
		$publife = $krref->{'zsklife'};
		keyrec_settime("key",$me);

		#
		# Save the key to the list of current ZSK.
		#
		push @zskcurlist, $k;
		vmed_print("published ZSK ($me) now current\n");
	}

	#
	# Generate and save a new signing set name.
	#
	$zskcursetname = $zskpubsetname;
	keyrec_signset_new($zone,$zskcursetname);
	$opts{'zskcur'} = $zskcursetname;
	keyrec_setval('zone',$zone,'zskcur',$zskcursetname);

	#
	# Save the current ZSK list in the signing sets.
	#
	$setlist = join ' ', @zskcurlist;
	keyrec_setval('set',$zskcursetname,"keys",$setlist);

	@zskpublist = ();

	#
	# If we have any new ZSKs, we'll make them the current published ZSKs.
	# If not, we'll generate a published ZSK.
	#
	if(defined($opts{'zsknew'}))
	{
		my $keylist;					# List of keys.

		$zsknewsetname = $opts{'zsknew'};
		$keylist = keyrec_recval($zsknewsetname,'keys');
		@zsknewlist = split ' ', $keylist;

		#
		# Convert the new ZSKs into published ZSKs.
		#
		foreach my $k (@zsknewlist)
		{
			my $me;					# Key name.

			#
			# Get the key's keyrec.
			#
			$krref = keyrec_fullrec($k);
			$me = $krref->{'keyrec_name'};

			#
			# Move the keyrec to published.
			#
			$krref->{'keyrec_type'} = "zskpub";
			keyrec_setval("key",$me,"keyrec_type","zskpub");

			#
			# Save the key to the list of current ZSK.
			#
			push @zskpublist, $k;
			vmed_print("new ZSK ($me) now published\n");
		}

		#
		# Add the new set to the keyrecs and zap the old new list.
		#
		$zskpubsetname = $zsknewsetname;
		$zsknewsetname = "";
		@zsknewlist = ();

	}
	else
	{
		#
		# Create a set of published keys.
		#
		for(my $ind=0; $ind < $zskcnt; $ind++)
		{
			my $krref;			# Keyrec reference.

			#
			# Create a new key and save its name.
			#
			$zskpub = genzsk("pub");
			push @zskpublist, $zskpub;

			#
			# Set the new key's lifetime.
			#
			$krref = keyrec_fullrec($zskpub);
			keyrec_setval("key",$zskpub,"zsklife",$publife);
			$opts{'zsklife'} = $publife;

			vmed_print("published ZSK ($zskpub) created\n");
		}

		#
		# Add the new set to the keyrecs.
		#
		$zskpubsetname = keyrec_signset_newname($zone);
	}

	#
	# Save the published ZSK name info.
	#
	$opts{'zskpub'} = $zskpubsetname;
	keyrec_setval('zone',$zone,'zskpub',$zskpubsetname);

	#
	# Create a set of new ZSK keys.
	#
	for(my $ind=0; $ind < $zskcnt; $ind++)
	{
		my $zsknew = genzsk("new");
		push @zsknewlist, $zsknew;

		keyrec_setval("key",$zsknew,"zonename",$zone);
		keyrec_setval("key",$zsknew,"zsklife",$publife);
		$opts{'zsklife'} = $publife;

		vmed_print("new ZSK ($zsknew) created\n");
	}

	#
	# Add the new set to the keyrecs.
	#
	$zsknewsetname = keyrec_signset_newname($zone);
	keyrec_signset_new($zone,$zsknewsetname);
	$opts{'zsknew'} = $zsknewsetname;
	keyrec_setval('zone',$zone,'zsknew',$zsknewsetname);
	$setlist = join ' ', @zsknewlist;
	keyrec_setval('set',$zsknewsetname,'keys',$setlist);
}

#----------------------------------------------------------------------
# Routine:	printopts()
#
# Purpose:	Display the value of our options.
#
sub printopts
{
	return if($verbose < $VERBOSE_MEDIUM);

	print "\n";
	print "\targuments:\n";
	print "\t\tzone     - $zone\n";
	print "\t\tzonefile - $zonefile\n";
	print "\t\tzoneftmp - $zoneftmp\n";
	print "\t\tzoneout  - $zoneout\n\n";

	return if($verbose < $VERBOSE_HIGH);

	print "\tzonesigner options:\n";
	print "\t\tkrfile		- <$krfile>\n";
	print "\t\tnokrfile	- <$nokrfile>\n";
	print "\t\tentropymsg	- <$entropymsg>\n";
	print "\t\tsavekeys	- <$savekeys>\n";
	print "\t\tarchdir         - <$archdir>\n";
	print "\n";

	print "\tkey-signing options:\n";
	print "\t\talgorithm	- <$alg>\n";
	print "\t\trandom		- <$random>\n";
	print "\t\tksize		- <$ksize>\n";
	print "\t\tkskcount     	- <$kskcnt>\n";
	print "\t\tkskdir		- <$kskdir>\n";
	print "\t\tksklife		- <$ksklife>\n";
	print "\t\tgenksk		- <$genksk>\n";
	print "\t\tsignset		- <$signset>\n";
	print "\t\tuseboth		- <$useboth>\n";
	print "\t\tusepub		- <$usepub>\n";
	print "\t\tzsize		- <$zsize>\n";
	print "\t\tzskcount     	- <$zskcnt>\n";
	print "\t\tzskdir		- <$zskdir>\n";
	print "\t\tzsklife		- <$zsklife>\n";
	print "\t\tgenzsk		- <$genzsk>\n";
	print "\t\tkgopts		- <$kgopts>\n";
	print "\n";

	print "\tzone-signing options:\n";
	print "\t\tenddate		- <$enddate>\n";
	print "\t\tgends		- <$gends>\n";
	print "\t\tksdir		- <$ksdir>\n";
	print "\t\tszopts		- <$szopts>\n";
	print "\n";

	print "\texternal commands:\n";
	print "\t\tkeygen		- <$keygen>\n";
	print "\t\tzonecheck	- <$zonecheck>\n";
	print "\t\tzonesign	- <$zonesign>\n";
	print "\n";
}

#----------------------------------------------------------------------
# Routine:	vprint()
#
sub vprint
{
	my $out = shift;			# Output string.

	print "    $out" if($verbose);
}

#----------------------------------------------------------------------
# Routine:	vmed_print()
#
sub vmed_print
{
	my $out = shift;			# Output string.

	print "\t$out" if($verbose > $VERBOSE_LOW);
}

#----------------------------------------------------------------------
# Routine:	vhigh_print()
#
sub vhigh_print
{
	my $out = shift;			# Output string.

	print "\t\t$out" if($verbose == $VERBOSE_HIGH);
}


#----------------------------------------------------------------------
# Routine:	helpchk()
#
# Purpose:	Explicit argument checks for the help option.
#
sub helpchk
{
	my $argc = @ARGV;			# Length of @ARGV.
	my $ind;				# Index for @ARGV.

	for($ind=0; $ind<$argc; $ind++)
	{
		my $arg = $ARGV[$ind];

		if(($arg eq "-h")	|| ($arg eq "--h")	||
		   ($arg eq "-he")	|| ($arg eq "--he")	||
		   ($arg eq "-hel")	|| ($arg eq "--hel")	||
		   ($arg eq "-help")	|| ($arg eq "--help"))
		{
			usage(1);
		}
	}
}

#----------------------------------------------------------------------
# Routine:	version()
#
# Purpose:	Print the version number(s) and exit.
#
sub version
{
	print STDERR "$VERS\n";
	print STDERR "$DTVERS\n";
	exit(1);
}

#----------------------------------------------------------------------
# Routine:	usage()
#
# Purpose:	Give usage message and exit.
#
sub usage
{
	my $whence = shift;			# Location of call.

	print STDERR "usage:  zonesigner [options] <zone-file> [signed-zone]\n";
	print STDERR "\n";

	print STDERR "\t\tzonesigner options:\n";
	print STDERR "\t\t\t-krfile keyrec-file\n";
	print STDERR "\t\t\t-nokrfile\n";
	print STDERR "\t\t\t-genkeys\n";
	print STDERR "\t\t\t-genksk\n";
	print STDERR "\t\t\t-genzsk\n";
	print STDERR "\t\t\t-useboth\n";
	print STDERR "\t\t\t-usepub\n";
	print STDERR "\t\t\t-archivedir directory\n";
	print STDERR "\t\t\t-nosave\n";
	print STDERR "\t\t\t-kskcount count\n";
	print STDERR "\t\t\t-ksklife lifespan\n";
	print STDERR "\t\t\t-ksignset KSK-set-name\n";
	print STDERR "\t\t\t-zsklife lifespan\n";
	print STDERR "\t\t\t-zskcount count\n";
	print STDERR "\t\t\t-signset ZSK-set-name\n";
	print STDERR "\t\t\t-intermediate tmp-zone-file\n";
	print STDERR "\t\t\t-zone zone-name\n";
	print STDERR "\t\t\t-help\n";
	print STDERR "\t\t\t-version\n";
	print STDERR "\t\t\t-verbose\n";
	print STDERR "\n";

	print STDERR "\t\tdnssec-keygen options:\n";
	print STDERR "\t\t\t-algorithm algorithm\n";
	print STDERR "\t\t\t-ksklength KSK-size\n";
	print STDERR "\t\t\t-zsklength ZSK-size\n";
	print STDERR "\t\t\t-zskcount ZSK-number\n";
	print STDERR "\t\t\t-random random-path\n";
	print STDERR "\t\t\t-kgopts dnssec-keygen-options\n";
	print STDERR "\n";

	print STDERR "\t\tdnssec-signzone options:\n";
	print STDERR "\t\t\t-endtime end-time\n";
	print STDERR "\t\t\t-gends\n";
	print STDERR "\t\t\t-ksdir keyset-directory\n";
	print STDERR "\t\t\t-szopts dnssec-signzone-options\n";
	print STDERR "\n";

	#
	# This is a debugging line.  Uncomment it if you need to know
	# from whence usage() was called.
	#
#	print "\ncalled from $whence\n" if($verbose && ($whence > 0));

	exit(1);
}

1;

##############################################################################
#

=pod

=head1 NAME

zonesigner - Generates encryption keys and signs a DNS zone.

=head1 SYNOPSIS

  zonesigner [options] <zone-file> <signed-zone>

  # get started immediately examples:

  # first run on a zone for example.com:
  zonesigner -genkeys -endtime +2678400 -zone example.com

  # future runs before expiration time (reuses the same keys):
  zonesigner -endtime +2678400 example.com

=head1 DESCRIPTION

This script combines into a single command many actions that are required to
sign a DNS zone.  It generates the required KSK and ZSK keys, adds the key
data to a zone record file, signs the zone file, and runs checks to ensure
that everything worked properly.  It also keeps records about the keys and
how the zone was signed in order to facilitate re-signing of the zone in the
future.

The B<zonesigner>-specific zone-signing records are kept in I<keyrec> files.
Using I<keyrec> files, defined and maintained by DNSSEC-Tools, B<zonesigner>
can automatically gather many of the options used to previously sign and
generate a zone and its keys.  This allows the zone to be maintained using the
same key lengths and expiration times, for example, without an administrator
needing to manually track these fields.

=head1 QUICK START

The following are examples that will allow a quick start on using
B<zonesigner>:

=over 4

=item first run on example.com

The following command will generate keys and sign the zone file for
example.com, giving an expiration date 31 days in the future.  The
zone file is named B<example.com> and the signed zone file will be
named B<example.com.signed>.

    zonesigner -genkeys -endtime +2678400 example.com

=item subsequent runs on example.com

The following command will re-sign example.com's zone file, but will not
generate new keys.  The files and all key-generation and zone-signing
arguments will remain the same.

    zonesigner example.com

=back

=head1 USING ZONESIGNER

B<zonesigner> is used in this way:

    zonesigner [options] <zone-file> <signed-zone>

The I<zone-file> and I<signed-zone> arguments are required.

I<zone-file> is the name of the zone file from which a signed zone file will
be created.  If the I<-zone> option is not given, then I<zone-file> will be
used as the name of the zone that will be signed.  Generated keys are given
this name as their base.

The zone file is modified to have B<include> commands, which will include the
KSK and ZSK keys.  These lines are placed at the end of the file and should
not be modified by the user.  If the zone file already includes any key files,
those inclusions will be deleted.  These lines are distinguished by starting
with "$INCLUDE" and end with ".key".  Only the actual include lines are
deleted; any related comment lines are left untouched.

An intermediate file is used in signing the zone.  I<zone-file> is copied to
the intermediate file and is modified in preparation of signing the zone file.
Several $INCLUDE lines will be added at the end of the file and the SOA serial
number will be incremented.

I<signed-zone> is the name of the signed zone file.  If it is not given on
the command line, the default signed zone filename is the I<zone-file>
appended with ".signed".  Thus, executing B<zonesigner example.com> will
result in the signed zone being stored in I<example.com.signed>.

Unless the I<-genkeys>, I<-genksk>, or I<-genzsk> options are specified, the
last keys generated for a particular zone will be used in subsequent
B<zonesigner> executions.

=head1 KEYREC FILES

I<keyrec> files retain information about previous key-generation and
zone-signing operations.  If a I<keyrec> file is not specified (by way of the
I<-krfile> option), then a default I<keyrec> file is used.  If this default
is not specified in the system's DNSSEC-Tools configuration file, the
filename will be the zone name appended with B<.krf>.  If the I<-nokrfile>
option is given, then no I<keyrec> file will be consulted or saved.

I<keyrec> files contain three types of entries:  zone I<keyrec>s, set
I<keyrec>s, and key I<keyrec>s.  Zone I<keyrec>s contain information
specifically about the zone, such as the number of ZSKs used to sign the zone,
the end-time for the zone, and the key signing set names (names of set
I<keyrecs>.) Set I<keyrec>s contain lists of keys names used for a specific
purpose, such as the current ZSK keys or the published ZSK keys.  Key
I<keyrec>s contain information about the generated keys themselves, such as
encryption algorithm, key length, and key lifetime.

Each I<keyrec> contains a set of "key/value" entries, one per line.  Example 4
below contains the contents of a sample I<keyrec> file.

=head1 ENTROPY

On some systems, the implementation of the pseudo-random number generator
requires keyboard activity.  This keyboard activity is used to fill a buffer
in the system's random number generator.  If B<zonesigner> appears hung, you
may have to add entropy to the random number generator by randomly striking
keys until the program completes.  Display of this message is controlled by
the B<entropy_msg> configuration file parameter.

=head1 DETERMINING OPTION VALUES

B<zonesigner> checks four places in order to determine option values.  
In descending order of precedence, these places are:

    command line options

    keyrec file

    DNSSEC-Tools configuration file

    zonesigner defaults

Each is checked until a value is found.  That value is then used for that
B<zonesigner> execution and the value is stored in the I<keyrec> file.

=head2 Example

For example, the KSK length has the following values:

    -ksklength command line option:    	8192

    keyrec file:               		1024

    DNSSEC-Tools configuration file:	2048

    zonesigner defaults:    		512

If all are present, then the KSK length will be 8192.

If the I<-ksklength> command line option wasn't given, the KSK length
will be 1024.

If the KSK length wasn't given in the configuration file, it will be 8192.

If the KSK length wasn't in the I<keyrec> file or the configuration file,
the KSK length will be 8192.

If the I<-ksklength> command line option wasn't given and the KSK length
wasn't in the configuration file, it'll be 1024.

If the command line option wasn't given, the KSK length wasn't in the
I<keyrec> file, and it wasn't in the configuration file, then the KSK
length will be 512.

=head1 OPTIONS

Three types of options may be given, based on the command for which they are
intended.  These commands are  B<dnssec-keygen>, B<dnssec-signzone>, and
B<zonesigner>.

=head2 B<zonesigner>-specific Options

=over 4

=item -nokrfile

No I<keyrec> file will be consulted or created.

=item -krfile

I<keyrec> file to use in processing options.  See the man page for
B<Net::DNS::SEC::Tools::tooloptions.pm> for more details about this file.

=item -genkeys

Generate a new KSKs and ZSKs for the zone.

=item -genksk

Generate new KSKs for the zone.  By default, the last KSKs generated for this
zone will be used.

=item -genzsk

Generate new ZSKs for the zone.  By default, the last ZSKs generated for this
zone will be used.

=item -useboth

Use the existing Current B<and> Published ZSKs to sign the zone.

=item -usepub

Use the existing Published ZSKs to sign the zone.

=item -archivedir

The key archive directory.  If a key archive directory hasn't been specified
(on the command line or in the DNSSEC-Tools configuration file) and the
I<-nosave> option was B<not> given, an error message will be displayed and 
B<zonesigner> will exit.

When the files are saved into the archive directory, the existing file names
are prepended with a timestamp.  The timestamp indicates when the files are
archived.

=item -nosave

Do not save obsolete keys to the key archive directory.  The default behavior
is to save obsolete keys.

=item -kskcount

The number of KSK keys to generate and with which to sign the zone.  The
default is to use a single KSK key.

=item -ksklife

The time between KSK rollovers.  This is measured in seconds.

=item -ksignset

The name of the KSK signing set to use.  If the signing set does not exist,
then this must be used in conjunction with either I<-genkeys> or I<-genksk>.
The name may contain alphanumerics, underscores, hyphens, periods, and commas.

The default signing set name is "signing-set-I<N>", where I<N> is a number.
If I<-signset> is not specified, then B<zonesigner> will use the default and
increment the number for subsequent signing sets.

=item -zsklife

The time between ZSK rollovers.  This is measured in seconds.

=item -zskcount

The number of ZSK keys to generate and with which to sign the zone.  The
default is to use a single ZSK key.

=item -signset

The name of the ZSK signing set to use as the Current ZSK signing set.  The
zone is signed and the given signing set becomes the zone's new Current ZSK
signing set.  If the signing set does not exist, then this must be used in
conjunction with either I<-genkeys> or I<-genzsk>.

The name may contain alphanumerics, underscores, hyphens, periods, and commas.
The default signing set name is "signing-set-I<N>", where I<N> is a number.
If I<-signset> is not specified, then B<zonesigner> will use the default and
increment the number for subsequent signing sets.

=item -forceroll

Force a rollover of the ZSK keys using the Pre-Publish Key Rollover method.
The rollover process adjusts the keys used to sign the specified zone,
generates new keys, signs the zone with the appropriate keys, and updates the
I<keyrec> file.  The Pre-Publish Key Rollover process is described in the
DNSSEC Operational Practices document.

Three sets of ZSK keys are used in the rollover process:  Current, Published,
and New.  Current ZSKs are those which are used to sign the zone.  Published
ZSKs are available in the zone data, and therefore in cached zone data, but
are not yet used to sign the zone.  New ZSKs are not available in zone data
nor yet used to sign the zone, but are waiting in the wings for future use.

The I<keyrec>s of the ZSK keys are adjusted as follows:

    The Current ZSK keys are marked as obsolete.
    The Published ZSK keys are marked as Current.
    The New ZSK keys, if they exist, are marked as Published.
    Another set of ZSK keys are generated, which will be
        marked as the New ZSK keys.
    The Published ZSK keys' zsklife field is copied to the
        new ZSK keys' keyrecs.
    The obsolete ZSK keys are moved to the archive directory.

The quick summary of proper ZSK rolling (which rollerd does for you if
you use it):

    - wait 2 * max(TTL in zone)
    - run zonesigner using -usepub
    - wait 2 * max(TTL in zone)
    - run zonesigner using -forceroll
    - wait 2 * max(TTL in zone)

B<Warning>:  The timing of key-rolling is critical.  Great care must be taken
when using this option.  B<rollerd> automatees the rollover process and may be
used to safely take care of this aspect of DNSSEC management.  Using the
I<-forceroll> option should only be used if you know what you're doing.

=item -intermediate

Filename to use for the temporary zone file.  The zone file will be copied to
this file and then the key names appended.

=item -zone

Name of the zone that will be signed.  This zone name may be given with this
option or as the first non-option command line argument.

=item -help

Display a usage message.

=item -Version

Display the version information for zonesigner and the DNSSEC-Tools package.

=item -verbose

Verbose output will be given.  As more instances of I<-verbose> are given on
the command line, additional levels of verbosity are achieved.

    level	output
    -----	------
      1		operations being performed
		  (e.g., generating key files, signing zone) 
      2		details on operations and some operation results
		  (e.g., new key names, zone serial number)
      3		operations' parameters and additional details
		  (e.g., key lengths, encryption algorithm,
		  executed commands)

Higher levels of verbosity are cumulative.  Specifying two instances of
I<-verbose> will get the output from the first and second levels of output.

=back

=head2 B<dnssec-keygen>-specific Options

=over 4

=item -algorithm

Cryptographic algorithm used to generate the zone's keys.  The default value
is RSASHA1.  The option value is passed to B<dnssec-keygen> as the the I<-a>
flag.  Consult B<dnssec-keygen>'s manual page for to determine legal values.

=item -ksklength

Bit length of the zone's KSK key.
The default is 1024.

=item -random

Source of randomness used to generate the zone's keys.	(/dev/urandom)

=item -zsklength

Bit length of the zone's ZSK key.
The default is 512.

=item -kgopts

Additional options for B<dnssec-keygen> may be specified using this option.
The additional options are passed as a single string value as an argument to
the I<-kgopts> option.

=back

=head2 B<dnssec-signzone>-specific Options

=over 4

=item -endtime

Time that the zone expires, measured in seconds.  See the man page for
B<dnssec-signzone> for the valid format of this field.
The default value is 2592000 seconds (30 days.)

=item -gends

Force B<dnssec-signzone> to generate DS records for the zone.  This option is
translated into I<-g> when passed to B<dnssec-signzone>.

=item -ksdir

Specify a directory for storing keysets.  This is passed to B<dnssec-signzone>
as the I<-d> option.

=item -szopts

Additional options for B<dnssec-signzone> may be specified using this option.
The additional options are passed as a single string value as an argument to
the I<-szopts> option.

=back

=head1 Examples

Example 1.

In the first example, an existing I<keyrec> file is used to assist in signing
the example.com domain.  Zone data are stored in B<example.com>, and the
keyrec is in B<example.krf>.  The final signed zone file will be
B<db.example.com>.  Using this execution:

    # zonesigner -krfile example.krf example.com db.example.com.signed

the following files are created:

    Kexample.com.+005+45842.private
    Kexample.com.+005+45842.key
    Kexample.com.+005+50186.private
    Kexample.com.+005+50186.key
    Kexample.com.+005+59143.private
    Kexample.com.+005+59143.key

    dsset-example.com.
    keyset-example.com.

    db.example.com.signed

The first six files are the KSK and ZSK keys required for the zone.  The next
two files are created by the zone-signing process.  The last file is the zone
the final signed zone file.

Example 2.

In the second example, an existing I<keyrec> file is used to assist in signing
the example.com domain.  Zone data are stored in B<example.com>, and the
keyrec is in B<example.krf>.  The generated keys, an intermediate zone file,
and final signed zone file will use B<example.com> as a base.
Using this execution:

    # zonesigner -krfile example.krf -intermediate example.zs example.com db.example.com

the following files are created:

    Kdb.example.com.+005+12354.key
    Kdb.example.com.+005+12354.private
    Kdb.example.com.+005+82197.key
    Kdb.example.com.+005+82197.private
    Kdb.example.com.+005+55888.key
    Kdb.example.com.+005+55888.private

    dsset-db.example.com.
    keyset-db.example.com.

    example.zs
    db.example.com

The first six files are the KSK and ZSK keys required for the zone.  The next
two files are created by the zone-signing process.  The second last file is
an intermediate file that will be signed.  The last file is file is the final
signed zone.

Example 3.

In the third example, no I<keyrec> file is specified for the signing of
the example.com domain.  In addition to files created as shown in previous
examples, a new I<keyrec> file is created.  The new I<keyrec> file uses the
domain name as its base.  Using this execution:

    # zonesigner example.com db.example.com

the following I<keyrec> file is created:

    example.com.krf

The signed zone file is created in:

    db.example.com

Example 4.

This example shows a I<keyrec> file generated by B<zonesigner>.

The command executed is:

    # zonesigner example.com db.example.com

The generated I<keyrec> file contains six I<keyrec>s:  a zone I<keyrec>,
two set I<keyrec>s, one KSK I<keyrec>, and two ZSK I<keyrec>s.  

    zone	"example.com"
	zonefile	"db.example.com"
	signedzone	"db.example.com.signed"
	endtime		"+2592000"
	kskkey		"Kexample.com.+005+24082"
	kskdirectory	"."
	zskcur		"signing-set-42"
	zskpub		"signing-set-43"
	zskdirectory	"."
	keyrec_type	"zone"
	keyrec_signsecs	"1115166642"
	keyrec_signdate	"Wed May  4 00:30:42 2005"

    set		"signing-set-42"
	zonename	"example.com"
	keys		"Kexample.com.+005+53135"
	keyrec_setsecs	"1115166640"
	keyrec_setdate	"Wed May  4 00:30:40 2005"

    set		"signing-set-43"
	zonename	"example.com"
	keys		"Kexample.com.+005+13531"
	keyrec_setsecs	"1115166641"
	keyrec_setdate	"Wed May  4 00:30:41 2005"

    key		"Kexample.com.+005+24082"
	zonename	"example.com"
	keyrec_type	"ksk"
	algorithm	"rsasha1"
	random		"/dev/urandom"
	keypath		"./Kexample.com.+005+24082.key"
	ksklength	"1024"
	ksklife		"15768000"
	keyrec_gensecs	"1115166638"
	keyrec_gendate	"Wed May  4 00:30:38 2005"

    key		"Kexample.com.+005+53135"
	zonename	"example.com"
	keyrec_type	"zskcur"
	algorithm	"rsasha1"
	random		"/dev/urandom"
	keypath		"./Kexample.com.+005+53135.key"
	zsklength	"512"
	zsklife		"604800"
	keyrec_gensecs	"1115166638"
	keyrec_gendate	"Wed May  4 00:30:38 2005"

    key		"Kexample.com.+005+13531"
	zonename	"example.com"
	keyrec_type	"zskpub"
	algorithm	"rsasha1"
	random		"/dev/urandom"
	keypath		"./Kexample.com.+005+13531.key"
	zsklength	"512"
	zsklife		"604800"
	keyrec_gensecs	"1115166638"
	keyrec_gendate	"Wed May  4 00:30:38 2005"


=head1 NOTES

=over 4

=item 1.  SOA Serial Numbers

Serial numbers in SOA records are merely incremented in this version.  Future
plans are to allow for more flexible serial number manipulation.

=back

=head1 COPYRIGHT

Copyright 2004-2006 SPARTA, Inc.  All rights reserved.
See the COPYING file included with the DNSSEC-Tools package for details.

=head1 AUTHOR

Wayne Morrison, tewok@users.sourceforge.net

=head1 SEE ALSO

B<dnssec-keygen(8)>,
B<dnssec-signzone(8)>

B<Net::DNS::SEC::Tools::conf.pm(3)>,
B<Net::DNS::SEC::Tools::defaults.pm(3)>,
B<Net::DNS::SEC::Tools::keyrec.pm(3)>,
B<Net::DNS::SEC::Tools::tooloptions.pm(3)>

=cut
