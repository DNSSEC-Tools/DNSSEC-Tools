#!/usr/bin/perl
#
# Copyright 2007 SPARTA, Inc.  All rights reserved.  See the COPYING
# file distributed with this software for details.
#
# DNSSEC-Tools:  dtck
#
#	This script centralizes all the DNSSEC-Tools data validation
#	programs.  It runs dtconfchk, rollchk, and krfcheck.
#
#	The command is used in this way:
#
#		dtck
#
#	NOTES:
#		- allow multiple config files
#		- allow multiple rollrec files
#		- allow multiple keyrec files
#		- records all take an optional directory.  if given, the
#		  check will be executed from that directory
#		- checking program should exit with an error count
#		- all checking programs should have a -count option
#

use strict;

use Cwd;
use Getopt::Long qw(:config no_ignore_case_always);

use Net::DNS::SEC::Tools::conf;
use Net::DNS::SEC::Tools::defaults;
use Net::DNS::SEC::Tools::keyrec;
use Net::DNS::SEC::Tools::rollrec;

#
# Version information.
#
my $NAME   = "dtck";
my $VERS   = "$NAME version: 0.1";
my $DTVERS = "DNSSEC-Tools Version: 1.2";

#######################################################################
#
# Data required for command line options.
#
my @opts =
(
	"count",			# Give final error count.
	"quiet",			# Don't give any output.
	"verbose",			# Give lotsa output.

	"list",				# List files as they're being checked.
	"pretty",			# Give some nice separating lines.

	"Version",			# Display the version number.
	"help",				# Give a usage message and exit.
);

my $count   = 0;			# Give count option flag.
my $quiet   = 0;			# Quiet option flag.
my $verbose = 0;			# Verbose option flag.

my $list   = 0;				# List filenames option flag.
my $pretty = 0;				# Give some separating output.

my $errs = 0;				# Error count.


my %cnfs = ();				# DNSSEC-Tools config files.
my %rrfs = ();				# Rollrec files.
my %krfs = ();				# Keyrec files.

my $cnfchk;				# Config-verification program.
my $krfchk;				# Keyrec-verification program.
my $rrfchk;				# Rollrec-verification program.

my $homedir;				# Initial directory.

my $TYPEDASHES = 78;			# Dashes between type lines for -pretty.
my $FILEDASHES = 55;			# Dashes between file lines for -pretty.

main();
exit($errs);

#-----------------------------------------------------------------------------
# Routine:	main()
#
# Purpose:	Staging area.
#
sub main()
{
	my $mconf;			# The config file to check.

	print STDERR "\n\tdtck is only reading from its __DATA__ input at the moment.\n\tThis is purely a developmental convenience and is temporary.\n\n";

	#
	# Get our options.
	#
	doopts();

	#
	# Get the master config filename to check.
	#
	if($ARGV[0] ne "")
	{
		$mconf = $ARGV[0];
	}

	#
	# Get the current directory and some program paths.
	#
	$homedir = getcwd();
	getpaths();

	#
	# Maybe print the name of the config file we're checking.
	#
	print "checking master config file \"$mconf\"\n" if(!$quiet);

	#
	# Read the master config file.
	#
	readmaster($mconf);

	#
	# Check all our files.
	#
	checkfiles();

	#
	# Give an exit message that depends on the error count.
	#
	if(!$quiet)
	{
		if($errs == 0)
		{
			print "$mconf is valid\n";
		}
		else
		{
			print "$mconf is invalid:  $errs errors\n" if($errs > 1);
			print "$mconf is invalid:  $errs error\n"  if($errs == 1);
		}
	}
}

#-----------------------------------------------------------------------------
# Routine:	doopts()
#
# Purpose:	This routine deals with the command's options.
#
sub doopts
{
	my $ret;				# GetOptions() return code.
	my %options = ();			# Filled option array.

	#
	# Check our options.
	#
	$ret = GetOptions(\%options,@opts);
	exit(1) if(!$ret);

	#
	# Handle some immediate options.
	#
	version() if(defined($options{'Version'}));
	usage()   if(defined($options{'help'}));

	#
	# Save our other options.
	#
	$count	 = $options{'count'};
	$quiet	 = $options{'quiet'};
	$verbose = $options{'verbose'};

	$list	 = $options{'list'};
	$pretty	 = $options{'pretty'};

	#
	# Now some option validation...
	#
	if($quiet && $verbose)
	{
		print STDERR "-quiet and -verbose are mutually exclusive\n";
		exit(1);
	}
}

#-----------------------------------------------------------------------------
# Routine:	getpaths()
#
# Purpose:	This routine collects a bunch of paths we'll need.
#
sub getpaths
{
	$cnfchk	= dnssec_tools_default('dtconfchk');
	$krfchk	= dnssec_tools_default('krfcheck');
	$rrfchk	= dnssec_tools_default('rollchk');
}

#-----------------------------------------------------------------------------
# Routine:	readmaster()
#
# Purpose:	
#
sub readmaster
{
	my $line;				# Line of configuration data.
	my $bkcnt = 0;				# Count of invalid entry keys.
	my %badkeys = ();			# Invalid entry keys.

	#
	# Deconstruct each entry and add it to the appropriate hash.
	#
	while(<DATA>)
	{
		my $key;			# Entry's key.
		my $file;			# Entry's file.
		my $dir;			# Entry's directory.

		#
		# Get the entry and get rid of unwanted whitespace.
		#
		$line = $_;
		chomp $line;
		$line =~ s/^[ \t]*//;
		$line =~ s/[ \t]*$//;

		#
		# Skip empty lines and comments.
		#
		next if($line =~ /^$/);
		next if($line =~ /^#/);

		#
		# Pull out the pieces of the entry.
		#
		$line =~ /^(\S*)\s*(\S*)\s*(\S*)$/;
		$key  = lc($1);
		$file = $2;
		$dir  = $3;

		#
		# Put each entry into the appropriate hash.
		#
		if($key eq 'config')
		{
			$cnfs{$file} = $dir;
		}
		elsif($key eq 'rollrec')
		{
			$rrfs{$file} = $dir;
		}
		elsif($key eq 'keyrec')
		{
			$krfs{$file} = $dir;
		}
		else
		{
			$bkcnt++;
			$badkeys{$key}++;
		}
	}

	#
	# Make sure there weren't any invalid keys.
	#
	if($bkcnt)
	{
		print STDERR "the following invalid lines were given in the master config file:\n";
		foreach my $key (sort(keys(%badkeys)))
		{
			print STDERR "\t$key\n";
		}

		exit(1);
	}

}

#-----------------------------------------------------------------------------
# Routine:	checkfiles()
#
# Purpose:	Check each type of file in turn:  configuration files,
#		rollrec	files, and keyrec files.
#
sub checkfiles
{
	my $cnt;			# Number of each type of config files.

	if(%cnfs)
	{
		lprint("checking config files:\n");

		$cnt = keys(%cnfs);
		foreach my $fn (sort(keys(%cnfs)))
		{
			lprint("\t$fn\n");
			$cnt--;
			if($pretty && $cnt)
			{
				print "\n" . '-' x $FILEDASHES . "\n\n";
			}
		}
		lprint("\n");
	}

	if(%rrfs)
	{
		print "\n" . '-' x $TYPEDASHES . "\n\n" if($pretty);
		lprint("rollrec files:\n");

		$cnt = keys(%rrfs);
		foreach my $fn (sort(keys(%rrfs)))
		{
			lprint("\t$fn\t$rrfs{$fn}\n");
			runner('rollrec',$rrfchk,$fn,$rrfs{$fn});

			$cnt--;
			if($pretty && $cnt)
			{
				print "\n" . '-' x $FILEDASHES . "\n\n";
			}
		}
		lprint("\n");
	}

	if(%krfs)
	{
		print "\n" . '-' x $TYPEDASHES . "\n\n" if($pretty);
		lprint("keyrec files:\n");

		$cnt = keys(%krfs);
		foreach my $fn (sort(keys(%krfs)))
		{
			lprint("\t$fn\t$krfs{$fn}\n");
			runner('keyrec',$krfchk,$fn,$krfs{$fn});

			$cnt--;
			if($pretty && $cnt)
			{
				print "\n" . '-' x $FILEDASHES . "\n\n";
			}
		}
		lprint("\n");
	}

}

#-----------------------------------------------------------------------------
# Routine:	runner()
#
# Purpose:	
#
sub runner
{
	my $type = shift;			# Type of file to check.
	my $cmd	 = shift;			# File-checking command.
	my $file = shift;			# File to check.
	my $dir	 = shift;			# Optional directory.

	my $opt = '';				# Command options.
	my $out;				# Command output.
	my $ret;				# Command return code.

	#
	# If this file has an associated directory, we'll chdir into it.
	#
	chdir($dir) if($dir ne '');

	#
	# If this file exists, run a krfcheck on it.
	#
	if(-e $file)
	{
		#
		# Set up some options.
		#
		$opt = "-count " if($count);
		if($quiet)
		{
			$opt .= ' -quiet';
		}
		elsif($verbose)
		{
			$opt .= ' -verbose';
		}

		#
		# Show the command's output if the user wants it.
		#
		print "$cmd $opt $file\n\n" if($pretty);

		#
		# Execute the command.
		#
		$out = `$cmd $opt $file`;
		$ret = $?;
		chomp $out;

		#
		# Show the command's output if the user wants it.
		#
		if($verbose)
		{
			print "$out\n\n"
		}
		elsif($count)
		{
			$out =~ s/^(.*\n)*//;
			print "$out\n";
		}

	}
	else
	{
		$errs++;
		print "$type \"$file\" does not exist\n" if(!$quiet);
	}

	#
	# Return to our base directory.
	#
	chdir($homedir);
}

#-----------------------------------------------------------------------------
# Routine:	lprint()
#
sub lprint
{
	my $str = shift;				# String to print.

	print "$str" if($list);
}

##############################################################################
#

=pod

=head1 NAME

dtck - Check the DNSSEC-Tools data files for sanity.

=head1 SYNOPSIS

  dtck [options] [master_config_file]

=head1 DESCRIPTION

B<dtck> checks DNSSEC-Tools data files to determine if the
entries are valid.

=head1 MASTER CONFIGURATION FILE

A master configuration file contains a list of the files to be checked by
B<dtck>.  It contains the following types of records:

=over 4

=item comments

Any lines starting with an octothorpe (#) are comment lines and are ignored.

=item I<config>

foo

=item I<keyrec>

foo

=item I<rollrec>

foo

=back

=head1 OPTIONS

B<dtck> takes two types of options.  Options of the first type are handled 
directly by B<dtck>, controlling its output and processing.  Options of the
second type are passed to the file-checking programs and are not further
handled by B<dtck>.

=head2 Options Handled by B<dtck>

=over 4

=item I<-list>

The names of the files will be listed as they are checked.

=item I<-pretty>

Clarifying output is added to the output from B<dtck> and the
file-checking programs.

=item I<-help>

Display a usage message.

=back

=head2 Options Not Handled by B<dtck>

=over 4

=item I<-count>

The file-checking programs will display a final error count.

=item I<-quiet>

No output will be given by the file-checking program.

=item I<-verbose>

Verbose output will be given by the file-checking program.

=back

=head1 COPYRIGHT

Copyright 2007 SPARTA, Inc.  All rights reserved.
See the COPYING file included with the DNSSEC-Tools package for details.

=head1 AUTHOR

Wayne Morrison, tewok@users.sourceforge.net

=head1 SEE ALSO

B<dtconfchk(8)>,
B<krfcheck(8)>,
B<rollchk(8)>

B<dnssec-tools.conf(5)>,
B<keyrec(5)>,
B<rollrec(5)>

=cut

##############################################################################
#

__DATA__

config	/usr/local/etc/dnssec-tools/dt.conf

rollrec	demo.rollrec /Users/tewok/work/dnssec/src/svn.dnssec-tools/dnssec-tools/tools/demos/rollerd-manyzones


keyrec	dummy.com.krf
keyrec	test.com.krf

