#!/usr/bin/perl
#
# Copyright 2005 SPARTA, Inc.  All rights reserved.  See the COPYING
# file distributed with this software for details
#
#
# rollover-manager
#
#	This script manages the roll-over process.
#
#	ZSK roll-over takes place in three phases:
#		- wait until it's time to perform a ZSK roll-over
#		- sign the zone with the existing keys
#		- sign the zone with a newly generated ZSK key
#
#	KSK roll-over also takes place in three phases:
#		- wait until it's time to perform a KSK roll-over
#		- sign the zone with the existing keys
#		- sign the zone with a newly generated ZSK key
#

use strict;

use Date::Format;
use Date::Parse;
use Getopt::Long;

use Net::DNS::SEC::Tools::conf;
use Net::DNS::SEC::Tools::keyrec;
use Net::DNS::SEC::Tools::rollmgr;
use Net::DNS::SEC::Tools::rollrec;
use Net::DNS::SEC::Tools::timetrans;
use Net::DNS::SEC::Tools::tooloptions;

use Net::DNS::RR;
use Net::DNS::ZoneFile::Fast;

#######################################################################

my $KEYGEN	= "/usr/local/sbin/dnssec-keygen";
my $MV		= "/bin/mv";
my $PERL	= "/usr/bin/perl";
my $RNDC	= "/usr/local/sbin/rndc";

my $NAPTIME	= 60;

##########################################
#
# Log levels.
#
my $LOG_TMI	= 1;			# Overly verbose informational message.
my $LOG_INFO	= 4;			# Informational message.
my $LOG_ERR	= 6;			# Error message.
my $LOG_FATAL	= 9;			# Fatal error.

my $loglvl	= $LOG_INFO;		# Current log level.

##########################################
#
# Data required for command line options.
#
my $verbose = 0;			# Verbose option.

my $rollrecfile;			# Rollrec file to be managed.

my %dtconf;				# DNSSEC-Tools config file.

my $OPT_RRFILE	= "rrfile";
my $OPT_HELP	= "help";
my $OPT_VERBOSE	= "verbose";

my %options = ();			# Filled option array.
my @opts =
(
	"rrfile=s",			# Rollrec file.
	"help",				# Give a usage message and exit.
	"verbose",			# Verbose output.
);

#
# Flag values for the various options.  Variable/option connection should
# be obvious.
#

##########################################
#
#  keep these?
#

my $zone;				# Zone to play with.

my %zonerec;				# Zone's keyrec.


#######################################################################

my $ret;				# Return code from main().

$ret = main();
exit($ret);

#-----------------------------------------------------------------------------
#
# Routine:	main()
#
# steps:
#	while rollrec file is not empty
##		read rollrec file
#
#		for each rollrec in the rollrec file
#			handle according to its phase
#
sub main()
{
	my $argc;			# Number of command line arguments.

	my $errors = 0;			# Total error count.

	#
	# Check our options and arguments.
	#
	$rollrecfile = rollrec_default();
	optsandargs();
$verbose = 1;

	#
	# Set up handlers for our external commands.
	#
	controllers();

	#
	# Ensure we're the only manager running and drop a pid file.
	#
	if(rollmgr_dropid() == 0)
	{
		print "another rollover_manager is already running\n";
		exit(0);
	}

	%dtconf = parseconfig();

	print "rollrecfile - \"$rollrecfile\"\n" if($verbose);
	while(42)
	{

		#
		# Clean up and exit if the rollrec file doesn't exist
		# or is empty.
		#
		if(! -e $rollrecfile)
		{
			rmlog($LOG_FATAL,"rollrec file \"$rollrecfile\" does not exist");
		}
		elsif(-z $rollrecfile)
		{
			rmlog($LOG_FATAL,"rollrec file \"$rollrecfile\" is zero length");
		}

		#
		# Get the current contents of the rollrec file.
		#
		rollrec_read($rollrecfile);

		#
		# Check the zones for expired ZSKs.
		#
		zsk_check();

		sleep($NAPTIME);

print "\n--------------------------------------------------------------------------\n";
	}
}

###############################################################################

#-----------------------------------------------------------------------------
#
# Routine:	zsk_check()
#
sub zsk_check()
{
	my @rrfstats;			# Stats for rollrec file.

	foreach my $rname (rollrec_names())
	{
		my $rrr;		# Reference to rollrec.
		my %rr;			# Rollrec hash.
		my $phase;		# Rollrec's phase.

print "\n------------------------------------------------------------\n";
		#
		# Get the rollrec for this name.  If it doesn't
		# have one, whinge and continue to the next.
		#
		$rrr = rollrec_fullrec($rname);
		if(!defined($rrr))
		{
			fprint STDERR "\t\t\t\t\t\tno rollrec defined for $rname\n";
			next;
		}
		%rr = %$rrr;

		#
		# If this zone's current ZSK has expired, we'll get it rolling.
		# 
		if(expired($rname,$rrr,"zskcur"))
		{
print "zone $rname has expired\n";
			zsk_phaser($rname,$rrr);
		}
else
{
print "zone $rname has not expired\n";
}

		print "\n";
	}
	print "\n";

}

#-----------------------------------------------------------------------------
#
# Routine:	zsk_phaser()
#
sub zsk_phaser
{
	my $rname = shift;		# Zone name.
	my $rrr = shift;		# Reference to rollrec.

	my %rr;				# Rollrec hash.
	my $phase;			# Zone's current roll-over phase.

	#
	# Get this rollrec record's current phase.
	#
	%rr = %$rrr;
	$phase = $rr{'curphase'};

	#
	# Work on this rollrec's phase.
	#
	$phase = zsk_phasewait($rname,$rrr,1) if($phase == 1);
	$phase = zsk_phase2($rname,$rrr)      if($phase == 2);
	$phase = zsk_phasewait($rname,$rrr,3) if($phase == 3);
	$phase = zsk_phase4($rname,$rrr)      if($phase == 4);

}

#-----------------------------------------------------------------------------
#
# Routine:	zsk_phase1()
#
sub zsk_phasewait
{
	my $rname = shift;			# Name of rollrec.
	my $rrr	  = shift;			# Reference to rollrec.
	my $phase = shift;			# Roll-over phase.

	my %rr;					# Rollrec hash.

	$rrr = rollrec_fullrec($rname);
	%rr = %$rrr;
print "zsk_phasewait:  phase $phase - $rname\n";

	#
	# Check if we can go to the next roll-over phase.  If not, we'll
	# go to the next rollrec entry and return to this later.
	#
	if(!ttlexpire($rname,$rrr))
	{
		rmlog($LOG_INFO,"zone \"$rname\" roll-over phase $phase; waiting for cache expiration");
		return($phase);
	}

	#
	# Bump this rollrec's phase number and return the new phase.
	#
	$phase++;
	newphase($rname,$rrr,$phase);
	return($phase);
}

#-----------------------------------------------------------------------------
#
# Routine:	zsk_phase2()
#
# Purpose:	Perform the phase 2 steps of the roll-over.  These are:
#
#			- sign the zone with the KSK and published ZSK
#			- reload the zone
#			- wait for old zone data to expire
#
sub zsk_phase2
{
	my $rname = shift;		# Name of rollrec.
	my $rrr = shift;		# Reference to rollrec.

	my %rr;				# Rollrec hash.

	my $krf;			# Rollrec's keyrec name.
	my %krf;			# Keyrec hash.
	my $krr;			# Keyrec reference.

	my $szret;			# Result from dnssec-signzone execution.

	print "zsk_phase2:  $rname\n";

	%rr = %$rrr;

	#
	# Get the rollrec's associated keyrec file and ensure that it
	# exists.
	#
	$krf = $rr{'keyrec'};
	if(!$krf  || ($krf eq ""))
	{
		rmlog($LOG_ERR,"no keyrec for zone \"$rname\" specified");
		return;
	}
	if(! -e $krf)
	{
		rmlog($LOG_ERR,"keyrec \"$krf\" for zone \"$rname\" does not exist");
		return;
	}

	#
	# Get the keyrec.
	#
print "\tkrf is <$krf>\n";
	$krr = opts_zonekr($krf,$rname);
	%krf = %$krr;

	#
	# Sign the zone with the published ZSK.
	#
	$szret = signer($rname,"zskpubpath",$krr);
	if($szret eq "")
	{
		rmlog($LOG_ERR,"unable to sign zone \"$rname\"");
	}

	#
	# Update the timestamp in the zone's keyrec.
	#
	keyrec_settime("zone",$rname);
	keyrec_write();

	#
	# Reload the zone.
	#
	zonereload($rname);

	#
	# Bump this rollrec's phase number and return the new phase.
	#
	newphase($rname,$rrr,3);
	return(3);

}

#-----------------------------------------------------------------------------
#
# Routine:	zsk_phase4()
#
sub zsk_phase4
{
	my $rname = shift;			# Name of rollrec.
	my $rrr = shift;			# Reference to rollrec.

	my %rr;					# Rollrec hash.

	print "zsk_phase4:  $rname\n";
	print "\tdoing nothing\n";

	%rr = %$rrr;

	#
	# Sign the zone with the published ZSK.
	#
	$szret = signer($rname,"zskcurpath",$krr);
	if($szret eq "")
	{
		rmlog($LOG_ERR,"unable to sign zone \"$rname\"");
	}

	#
	# Reload the zone.
	#
	zonereload($rname);

	#
	# Put ourselves back in the pre-roll state.
	#
	newphase($rname,$rrr,0);
	return(0);
}

###############################################################################

#-----------------------------------------------------------------------------
#
# Routine:	expired()
#
# Purpose:	This routine returns a boolean indicating if the specified
#		zone has an expired key of the given type.
#
#		The zone's keyrec file name is taken from the given rollrec
#		entry.  The keyrec file is read and the zone's entry found.
#		The key keyrec of the specified key type ("zskcur" or "ksk") 
#		is pulled from the keyrec file.
#		
#		Key expiration is determined by comparing the key keyrec's
#		gensecs field to the current time.  The key hasn't expired
#		if the current time is less than the gensecs; the key has
#		expired if the current time is greater than the gensecs.
#
sub expired
{
	my $rname = shift;				# Name of rollrec rec.
	my $rrr = shift;				# Reference to rollrec.
	my $key = shift;				# Key to check.

	my %rr;						# Rollrec hash.

	my $krname;					# Name of keyrec.
	my $krec;					# Keyrec reference.
	my %kh;						# Keyrec hash.

	my $krsecs;					# Key's expiration date.
	my $cronus;					# Current time.

	#
	# If this zone is in the middle of roll-over processing, we'll
	# immediately assume the key has expired.
	#
	#	NOTE:	THIS IS LIKELY TO CHANGE A BIT WHEN WE START
	#		LOOKING AT KSKs.
	#
	%rr = %$rrr;
	return(1) if($rr{'curphase'} > 0);

	#
	# Get the keyrec file's name and then read the file.
	#
	$krname = $rr{'keyrec'};
	keyrec_read($krname);

	#
	# Get the keyrec and complain if it doesn't exist.
	#
	$krec = keyrec_fullrec($rname);
	if(!defined($krec))
	{
		rmlog($LOG_ERR,"keyrec file \"$krname\" does not contain a keyrec for zone \"$rname\"\n");
		return(0);
	}
	%kh   = %$krec;

	$key = $kh{$key};
	$krec = keyrec_fullrec($key);
	if(!defined($krec))
	{
		rmlog($LOG_ERR,"keyrec file \"$krname\" does not contain a keyrec for key \"$rname\"\n");
		return(0);
	}
	%kh   = %$krec;

	#
	# Get the key's expiration time and the current time.
	#
	$krsecs	= $kh{"keyrec_gensecs"};
	$cronus	= gmtime;

	#
	# Return success (expired) if the key has passed its end time.
	# Return failure (not expired) if the key's end time is less
	# than the current time.
	#
	return(0) if($cronus < $krsecs);
	return(1);
}

#-----------------------------------------------------------------------------
#
# Routine:	maxttl()
#
# Purpose:	
#
sub maxttl
{
	my $signdb = shift;		# Signed zone's db filename.

	my $rrsref;			# Reference to zone's resource records.
	my @rrs;			# Zone's resource records.
	my $numrrs;			# Number of resource records in zone.
	my $rrref;			# Reference to a resource record.
	my %rr;				# A resource record to examine.
	my $maxttl = -1;		# Zone's maximum time-to-live value.
	my $ttl;			# Time-to-live value from a record.

	#
	# Ensure the zone file exists.
	#
	if(! -e $signdb)
	{
		rmlog($LOG_ERR,"zone file \"$signdb\" does not exist\n");
		return(-1);
	}

	#
	# Get the zone's resource record collection.
	#
	$rrsref = Net::DNS::ZoneFile::Fast::parse(file => $signdb);

	#
	# Get the number of resource records in the zone.
	#
	@rrs = @$rrsref;
	$numrrs = @rrs;

	#
	# Look at each resource record and save the largest value.
	#
	for(my $ind=0;$ind<$numrrs;$ind++)
	{
		$rrref = $rrs[$ind];
		%rr = %$rrref;

		$ttl = $rr{'ttl'};
		$maxttl = $ttl if($ttl > $maxttl);
	}

	#
	# Return the zone's maximum TTL value to our caller.
	#
	return($maxttl);
}

#-----------------------------------------------------------------------------
#
# Routine:	ttlexpire()
#
# Purpose:	Returns a boolean indicating if we can move to the next phase
#		of roll-over.  This is calculated by adding twice the TTL
#		length to the time we entered this phase.  If this is greater
#		than the current time, then we must wait a bit longer.  If
#		this is less than the current time, then we can proceed to
#		the next roll-over phase.
#
# Return Values:
#		0 - Zone's expiry date has not passed.
#		1 - Zone's expiry date has passed.
#
sub ttlexpire
{
	my $rname = shift;			# Name of rollrec.
	my $rrr	  = shift;			# Reference to rollrec.
	my %rr;					# Rollrec hash.

	my $zonefile;				# Zone file.
	my $maxttl;				# Zone's maximum TTL value.
	my $phstart;				# Start of zone's phase.

	my $curtime;				# Current time string.
	my $curtempus;				# Current time in seconds.
	my $endtempus;				# End-date in seconds.

	#
	# Get a few fields from the rollrec.
	#
	%rr = %$rrr;
	$zonefile = $rr{'zonefile'};
	$phstart  = $rr{'phasestart'};
	$maxttl	  = maxttl($rname) * 2;

	#
	# Get the current time in seconds.
	#
	$curtime = gmtime;
	$curtempus = str2time($curtime);

	#
	# Get the end-time (in seconds) and add the TTL.
	#
	$endtempus = str2time($phstart);
	$endtempus += $maxttl;

	#
	# Give any desired verbose output.
	#
	if($verbose)
	{
		my $endtime;				# End-date string.

		$endtime = ctime($endtempus);
		$endtime =~ s/\n$//;

		rmlog($LOG_TMI,"$rname roll-over TTL check");
		rmlog($LOG_TMI,"endtime\t$endtime");
		rmlog($LOG_TMI,"curtime\t$curtime");
	}

	#
	# Return success if we've passed the zone's adjusted end-date.
	# Return failure (not expired) if the zone's adjusted end-date
	# is in the future.
	#
	return(0) if($curtempus < $endtempus);
	return(1);
}

#-----------------------------------------------------------------------------
#
# Routine:	newphase()
#
# Purpose:	Moves a rollrec into the next phase, setting both the
#		phase number and the phase start time.
#
sub newphase
{
	my $rname = shift;				# Name of rollrec.
	my $rrr	  = shift;				# Rollrec reference.
	my $phase = shift;				# New phase.

	my %rr = %$rrr;					# Rollrec hash.

	rmlog($LOG_INFO,"zone \"$rname\" starting roll-over (phase $phase)\n");

	$rr{'curphase'} = $phase;
	rollrec_setval($rname,"curphase",$phase);
	rollrec_settime($rname);
	rollrec_write();
}

#-----------------------------------------------------------------------------
#
# Routine:	signer()
#
# Purpose:	Signs a zone with a specified ZSK.
#
#		On success, the return value of the zone-signing command
#			is returned.
#		On failure, "" is returned.
#
sub signer
{
	my $rname = shift;			# Name of rollrec.
	my $zsk   = shift;			# ZSK to sign with.
	my $rrr	  = shift;			# Reference to rollrec.

	my %rr;					# Rollrec hash.

	my $zonefile;				# Zone file from keyrec.
	my $zonesigned;				# Signed zone file from keyrec.

	#
	# Dig a few data out of the zone's keyrec file.
	#
	$zonefile = getkrval($rname,$rrr,"zonefile");
	return("") if($zonefile eq "");

	$zonesigned = getkrval($rname,$rrr,"signedzone");
	return("") if($zonesigned eq "");

	#
	# Have zonesigner sign the zone for us.
	#
	rmlog($LOG_INFO,"executing \"zonesigner $zonefile $zonesigned\"\n");
	$ret = `zonesigner $zonefile $zonesigned`;

	return($ret);
}

#-----------------------------------------------------------------------------
#
# Routine:	getkrval()
#
# Purpose:	This routine returns the value of a specified field in a
#		keyrec.  Error checking is performed to ensure that the
#		field exists in the keyrec and that it doesn't have an
#		empty value.
#
sub getkrval()
{
	my $kname = shift;				# Keyrec's name.
	my $rrr	  = shift;				# Keyrec reference.
	my $field = shift;				# Keyrec's field.

	my %kh = %$rrr;					# Keyrec hash.
	my $val;					# Field's value.

	#
	# Ensure that the requested field exists.
	#
	if(!defined($kh{$field}))
	{
		rmlog($LOG_ERR,"\"$kname\" keyrec has no entry for \"$field\"\n");
		return("");
	}

	#
	# Get the field from the keyrec.
	#
	$val = $kh{$field};

	#
	# Give an error if the value is empty.
	#
	if($val eq "")
	{
		rmlog($LOG_ERR,"\"$kname\" keyrec has an empty entry for \"$field\"\n");
	}

	return($val);
}

#-----------------------------------------------------------------------------
#
# Routine:	zonereload()
#
sub zonereload()
{
	my $zone = shift;				# Zone to reload.

	system("$RNDC reload $zone > /dev/null");
}

##############################################################################

#-----------------------------------------------------------------------------
#
# Routine:	optsandargs()
#
sub optsandargs()
{
	my $argc = @ARGV;		# Number of arguments.

	#
	# Check our options.
	#
	GetOptions(\%options,@opts);
	$verbose = $options{$OPT_VERBOSE};

	usage() if(defined($options{$OPT_HELP}));

	#
	# Check for a rollrec file name.
	#
	$rollrecfile = $options{$OPT_RRFILE} if(defined($options{$OPT_RRFILE}));

}

#-----------------------------------------------------------------------------
#
# Routine:	controllers()
#
# Purpose:	Initialize handlers for our externally provided commands.
#
sub controllers
{
	#
	# Initialize the signal handlers that will manage the incoming commands.
	#
	$SIG{'HUP'} = \&qproc_handler;
	$SIG{'INT'} = \&halt_handler;
}

#-----------------------------------------------------------------------------
#
# Routine:	qproc_handler()
#
# Purpose:	Handle the "process queue" command.
#
sub qproc_handler
{
	print "roll-over manager:  got a qproc command\n";
}

#-----------------------------------------------------------------------------
#
# Routine:	halt_handler()
#
# Purpose:	Handle the "halt" command.
#
sub halt_handler
{
	print "roll-over manager shutting down...\n";
	rollmgr_rmid();
	exit(0);
}

#-----------------------------------------------------------------------------
#
# Routine:	rollphase()
#
# Purpose:	Return the numeric value of the current roll-over phase.
#
sub rollphase
{
	#
	# If we aren't currently rolling, return zero.
	#
	return(0) if(!defined($zonerec{'rollphase'}));

	#
	# Otherwise, return the phase number.
	#
	return($zonerec{'rollphase'});
}

#-----------------------------------------------------------------------------
#
# Routine:	usage()
#
sub cleanup
{
	print "\ncleaning up...\n";
	exit(0);
}

#-----------------------------------------------------------------------------
#
# Routine:	rmlog()
#
sub rmlog
{
	my $lvl = shift;				# Message log level.
	my $msg = shift;				# Message to log.

	return if($lvl < $loglvl);
	print STDERR "rollover-manager:  $msg\n";

	cleanup() if($lvl == $LOG_FATAL);
}

#-----------------------------------------------------------------------------
#
# Routine:	usage()
#
sub usage
{
	print STDERR "usage:  rollover-manager [-v] [-h] -rrfile <rollrec_file> <zone>\n";
	exit(0);
}

1;

##############################################################################
#

=pod

=head1 NAME

rollover-manager - Daemon to manage DNSSEC key roll-over.

=head1 SYNOPSIS

  rollover-manager [-v] [-h] -rrfile <rollrec_file>

=head1 DESCRIPTION

This is a first pass at a daemon to manage key roll-overs.  Right now, this
only deals with ZSKs.

B<THIS IS NOT READY FOR PRODUCTION USE!!!!!>

=head1 KNOWN PROBLEMS

The following problems (or potential problems) are known:

=over 4

=item -

roll-over phase 4 may not be correct

=item -

insufficient testing

=item -

no testing with zone files and key files not in the process' directory

=item -

only deals with ZSKs

=item -

I<minimal> testing of the routine that checks key expiration

=item -

better logging is needed

=item -

debugging prints not deleted

=back

=head1 OPTIONS

The following options are recognized:

=over 4

=item -rrfile I<rollrec_file>

The name of the I<rollrec> file to be processed.

=item -help

Display a usage message.

=item -verbose

Verbose output will be given.

=back

=head1 ASSUMPTIONS

I<rollover-manager> uses the I<rndc> command to communicate with the BIND
I<named> daemon.  Therefore, it assumes that appropriate measure have been
taken so that this communication is possible.

=head1 AUTHOR

Wayne Morrison, tewok@users.sourceforge.net

=head1 SEE ALSO

named(8),
rndc(8)

keyrec-check(8),
zonesigner(8)

Net::DNS::SEC::Tools::keyrec.pm(3),
Net::DNS::SEC::Tools::rollmgr.pm(3),
Net::DNS::SEC::Tools::rollrec.pm(3)

=cut

#	krf is <test.com.krf>
#		algorithm - <rsasha1>
#		archivedir - </usr/local/etc/dnssec/KEY-SAFE>
#		checkzone - </usr/local/sbin/named-checkzone>
#		endtime - <+2592000>
#		entropy_msg - <1>
#		keygen - </usr/local/sbin/dnssec-keygen>
#		keypath - <./Ktest.com.+005+34380.key>
#		keyrec_name - <test.com>
#		krfile - <test.com.krf>
#		kskdirectory - <.>
#		kskkey - <Ktest.com.+005+34380>
#		ksklength - <2048>
#		kskpath - <./Ktest.com.+005+34380.key>
#		random - </dev/urandom>
#		savekeys - <1>
#		signedfile - <db.test.com.signed>
#		signzone - </usr/local/sbin/dnssec-signzone>
#		zonefile - <db.test.com>
#		zonename - <test.com>
#		zskcur - <Ktest.com.+005+23906>
#		zskcurpath - <./Ktest.com.+005+23906.key>
#		zskdirectory - <.>
#		zsklength - <1024>
#		zskpub - <Ktest.com.+005+26396>
#		zskpubpath - <./Ktest.com.+005+26396.key>
