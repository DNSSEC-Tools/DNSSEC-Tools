#!/usr/bin/perl
#
# Copyright 2005-2007 SPARTA, Inc.  All rights reserved.  See the COPYING
# file distributed with this software for details
#
#
# lskrf
#
#	This script lists the keyrecs in a keyrec file.
#

use strict;

use Getopt::Long qw(:config no_ignore_case_always);

use Net::DNS::SEC::Tools::conf;
use Net::DNS::SEC::Tools::defaults;
use Net::DNS::SEC::Tools::keyrec;
use Net::DNS::SEC::Tools::tooloptions;

#
# Version information.
#
my $NAME   = "lskrf";
my $VERS   = "$NAME version: 1.0";
my $DTVERS = "DNSSEC-Tools Version: 1.1";

#######################################################################

#
# Data required for command line options.
#
my %options = ();			# Filled option array.
my @opts =
(
	"all",				# List all keyrecs.
	"zones",			# List zone keyrecs.
	"sets",				# List set keyrecs.
	"keys",				# List key keyrecs.
	"ksk",				# List KSK keyrecs.
		"kcur",			# List Current KSK key keyrecs.
		"kpub",			# List Published KSK key keyrecs.
		"kobs",			# List obsolete KSK key keyrecs.
	"zsk",				# List ZSK keyrecs.
		"cur",			# List Current ZSK key keyrecs.
		"new",			# List New ZSK key keyrecs.
		"pub",			# List Published ZSK key keyrecs.
		"obs",			# List obsolete ZSK key keyrecs.

	"ref",				# List referenced key keyrecs.
	"unref",			# List unreferenced key keyrecs.
	"valid",			# List unexpired zone keyrecs.
	"expired",			# List expired zone keyrecs.

	"z-archdir",			# List zone's archive directories.
	"z-expdate",			# Show zone's expiration date.
	"z-signdate",			# Show zone's signing date.
	"z-zonefile",			# Show zone's zonefile.

	"k-algorithm",			# Show encryption algorithm.
	"k-enddate",			# Show end date.
	"k-length",			# Show key's length.
	"k-lifespan",			# Show key's lifespan.
	"k-path",			# Show key's path.
	"k-random",			# Show key's random number generator.
	"k-signdate",			# Show key's signing date.
	"k-zone",			# Show key's zonefile.

	"count",			# Only give a count of matching keyrecs.
	"label",			# Give a leading record label.
	"headers",			# Give column headers output.
	"nodate",			# Don't show the date.
	"terse",			# Give terse output.
	"long",				# Give long output.
	"Version",			# Display the version number.

	"help",				# Give a usage message and exit.
);

#
# Flag values for the various options.  Variable/option connection should
# be obvious.
#
my $allflag;
my $zonesflag;
my $archdirflag;
my $setsflag;
my $keysflag;
my $kskflag;
my $kcurflag;
my $kpubflag;
my $kobsflag;
my $zskflag;
my $zcurflag;
my $znewflag;
my $zpubflag;
my $zobsflag;

my $refflag;
my $unrefflag;
my $validflag;
my $expiredflag;

my $cntflag;
my $nodateflag;
my $headerflag;
my $terse;
my $long;

my $count	= 0;			# Record-match count.
my $version	= 0;			# Display the version number.

#########################################
#
# Data for building output.
#
my $COLSPACE	= 4;			# Space between columns.

my $ZONE	= 'Zone';		# Hash key for zones.
my $SET		= 'Set';		# Hash key for sets.
my $KEY		= 'Key Name';		# Hash key for keys.

my $HEADER_KRN	= "<<<header>>>";	# Name for column header "keyrec".
my %lengths	= ();			# Hash hash for lengths of columns;

my $prevkey;				# Previous rollrec key added to output.

my $z_label;				# Print a leading label for zones.
my $z_expdate;				# Print the zone's expiration date.
my $z_signdate;				# Print the zone's signing date.
my $z_zonefile;				# Print the zone's zone file.
my $z_archdir;				# Print the zone's archive directory.

my $s_keys;				# Print the set's key list.
my $s_label = 0;			# Print a leading label for sets.
my $s_setdate;				# Print the set's last mod date.
my $s_zone;				# Print the set's zone.

my $k_algorithm	= 0;			# Key's algorithm
my $k_enddate	= 0;			# Key's end date.
my $k_date	= 0;			# Key's signing date.
my $k_label	= 0;			# Label for output.
my $k_length	= 0;			# Key's length.
my $k_life	= 0;			# Key's lifespan.
my $k_random	= 0;			# Key's random number generator.
my $k_path	= 0;			# Key's path.
my $k_zonename	= 0;			# Key's owning zone.

#######################################################################


my @krnames;				# List of keyrecs in the file.

my %zones    = ();			# Zone keyrecs.
my %sets     = ();			# Set keyrecs.
my %allkeys  = ();			# All key keyrecs.
my %selkeys  = ();			# Keys selected for output.
my %kskkeys  = ();			# KSK keyrecs.
my %zskkeys  = ();			# ZSK keyrecs.
my %kcurkeys = ();			# Current KSK keyrecs.
my %kpubkeys = ();			# Published KSK keyrecs.
my %kobskeys = ();			# Obsolete KSK keyrecs.
my %zcurkeys = ();			# Current ZSK keyrecs.
my %znewkeys = ();			# New ZSK keyrecs.
my %zpubkeys = ();			# Published ZSK keyrecs.
my %zobskeys = ();			# Obsolete ZSK keyrecs.

my $archive;				# Default archive directory.

my $ret;				# Return code from main().

$ret = main();
exit($ret);

#-----------------------------------------------------------------------------
# Routine:	main()
#
sub main()
{
	my $argc = @ARGV;		# Number of command line arguments.
	my $errors = 0;			# Total error count.

	erraction(ERR_EXIT);

	#
	# Check our options.
	#
	doopts($argc);

	#
	# Read the keyrec files.
	#
	while($argc > 0)
	{
		getkeyrecs($ARGV[0]);
		shift @ARGV;
		$argc = @ARGV;
	}

	#
	# Cook up the output:  build a header line and calculate the maximum
	# length of each field.
	#
	makeheaders();
	maxlens();

	#
	# Give the output.
	#
	showzones()	if($zonesflag);
	showsets()	if($setsflag);
	showkeys()	if($keysflag);

	#
	# If the matching-record count should be given, give the count in
	# requested format.
	#
	if($cntflag)
	{
		if($terse)
		{
			print "$count\n";
		}
		else
		{
			my $plural = "s";
			$plural = "" if($count == 1);

			print "$count matching record$plural\n";
		}
	}
	return(0);
}

#-----------------------------------------------------------------------------
# Routine:	doopts()
#
# Purpose:	This routine shakes and bakes our command line options.
#		A bunch of option variables are set according to the specified
#		options.  Then a little massaging is done to make sure that
#		the proper actions are taken.  A few options imply others, so
#		the implied options are set if the implying options are given.
#
sub doopts
{
	my $argc = shift;			# Command line argument count.
	my %dtconf;				# DNSSEC-Tools config values.

	#
	# Parse the options.
	#
	GetOptions(\%options,@opts);


	#
	# Handle a few immediate flags.
	#
	version() if(defined($options{'Version'}));
	usage()   if(defined($options{'help'}));

	#
	# Ensure we were given a keyrec file to check.
	#
	$argc = @ARGV;
	usage() if($argc == 0);

	#
	# Set our option variables based on the parsed options.
	#
	$allflag	= $options{'all'}	|| 0;
	$zonesflag	= $options{'zones'}	|| 0;
	$setsflag	= $options{'sets'}	|| 0;
	$keysflag	= $options{'keys'}	|| 0;
	$kskflag	= $options{'ksk'}	|| 0;
	$kcurflag	= $options{'kcur'}	|| 0;
	$kpubflag	= $options{'kpub'}	|| 0;
	$kobsflag	= $options{'kobs'}	|| 0;
	$zskflag	= $options{'zsk'}	|| 0;
	$zcurflag	= $options{'cur'}	|| 0;
	$znewflag	= $options{'new'}	|| 0;
	$zpubflag	= $options{'pub'}	|| 0;
	$zobsflag	= $options{'obs'}	|| 0;

	$refflag	= $options{'ref'}	|| 0;
	$unrefflag	= $options{'unref'}	|| 0;
	$validflag	= $options{'valid'}	|| 0;
	$expiredflag	= $options{'expired'}	|| 0;

	$cntflag	= $options{'count'}	|| 0;
	$nodateflag	= $options{'nodate'}	|| 0;
	$headerflag	= $options{'headers'}	|| 0;
	$terse		= $options{'terse'}	|| 0;
	$long		= $options{'long'}	|| 0;

	#
	# Get the configuration values.
	#
	%dtconf = parseconfig();
	$archive = $dtconf{'archivedir'};

	#
	# If the valid-zone or the expired-zone option was given, but the
	# zones specifier wasn't, we'll assume they want all the zones listed.
	#
	if($terse && $long)
	{
		print STDERR "lskrf:  only one of -long and -terse may be specified\n";
		exit(1);
	}

	#
	# If the valid-zone or the expired-zone option was given, but the
	# zones specifier wasn't, we'll assume they want all the zones listed.
	#
	if(($validflag || $expiredflag)	 && !$zonesflag)
	{
		$zonesflag = 1;
	}

	#############################################################
	#
	# WARNING:  Code order beyond this point is critical.  Do *NOT* modify
	#	    anything in the rest of this routine if you are an idiot.
	#

	#
	# If none of the normal record selection flags were given but
	# either the referenced or unreferenced record flags were given,
	# then we'll assume the user wants all the referenced sets and keys.
	#
	if(!$allflag && !$zonesflag && !$setsflag && !$keysflag &&
	   !$kskflag && !$kcurflag  && !$kpubflag && !$kobsflag &&
	   !$zskflag && !$zcurflag  && !$znewflag && !$zpubflag && !$zobsflag)
	{
		if($refflag || $unrefflag)
		{
			$setsflag = 1;
			$keysflag = 1;
		}

		$zobsflag = 1 if($unrefflag);
	}

	#
	# Select all records if the "-all" option was given.  This option
	# overrides almost everything.
	#
	if($allflag)
	{
		$zonesflag   = 1;
		$setsflag    = 1;
		$keysflag    = 1;

		$refflag     = 0;
		$unrefflag   = 0;
		$validflag   = 0;
		$expiredflag = 0;

	}

	#
	# Set the appropriate keys flags.  The obsolete keys must be
	# explicitly requested.  The all-keys flag won't pick it up.
	#
	if($keysflag)
	{
		$kskflag = 1;
		$zskflag = 1;
	}

	if($kskflag)
	{
		$kcurflag = 1;
		$kpubflag = 1;
	}

	if($zskflag)
	{
		$zcurflag = 1;
		$znewflag = 1;
		$zpubflag = 1;
	}

	#
	# Set up some zone output flags.
	#
	if($zonesflag)
	{
		#
		# Set our defaults.
		#
		$z_label    = 1;
		$z_archdir  = 0;
		$z_expdate  = 0;
		$z_signdate = 1;
		$z_zonefile = 1;

		#
		# Set the non-defaults for -long.
		#
		if($long)
		{
			$z_archdir = 1;
			$z_expdate = 1;
		}

		#
		# Set the non-defaults for -terse.
		#
		if($terse)
		{
			$z_archdir  = 0;
			$z_label    = 0;
			$z_signdate = 0;
			$z_zonefile = 0;
		}

		#
		# Set some values for flags.
		#
		$z_archdir  = 1 if(defined($options{'z-archdir'}));
		$z_expdate  = 1 if(defined($options{'z-expdate'}));
		$z_signdate = 1 if(defined($options{'z-signdate'}));
		$z_zonefile = 1 if(defined($options{'z-zonefile'}));

		$z_label    = 1 if(defined($options{'label'}));

	}

	#
	# Set up some set output flags.
	#
	if($setsflag)
	{
		#
		# Set our defaults.
		#
		$s_label   = 1;
		$s_keys	   = 1;
		$s_setdate = 0;
		$s_zone    = 1;

		#
		# Set the non-defaults for -long.
		#
		if($long)
		{
			$s_setdate = 1;
			$s_zone	   = 1;
		}

		#
		# Set the non-defaults for -terse.
		#
		if($terse)
		{
			$s_label = 0;
			$s_keys	 = 0;
			$s_zone  = 0;
		}

		$s_label    = 1 if(defined($options{'label'}));

	}

	#
	# Set up some key output flags.
	#
	if($kskflag || $kcurflag || $kpubflag ||
	   $zskflag || $zcurflag || $znewflag || $zpubflag)
	{
		#
		# Set our defaults.
		#
		$k_algorithm = 0;
		$k_date	     = 1;
		$k_enddate   = 0;
		$k_label     = 1;
		$k_length    = 0;
		$k_life	     = 0;
		$k_path	     = 0;
		$k_random    = 0;
		$k_zonename  = 1;

		#
		# Set the non-defaults for -long.
		#
		if($long)
		{
			$k_algorithm = 1;
			$k_enddate   = 1;
			$k_length    = 1;
			$k_path	     = 1;
			$k_random    = 1;
		}

		#
		# Set the non-defaults for -terse.
		#
		if($terse)
		{
			$k_date	    = 0;
			$k_label    = 0;
			$k_zonename = 0;
		}

		#
		# Set some values for flags.
		#
		$k_algorithm = 1 if(defined($options{'k-algorithm'}));
		$k_enddate   = 1 if(defined($options{'k-enddate'}));
		$k_date      = 1 if(defined($options{'k-signdate'}));
		$k_length    = 1 if(defined($options{'k-length'}));
		$k_life      = 1 if(defined($options{'k-lifespan'}));
		$k_path      = 1 if(defined($options{'k-path'}));
		$k_random    = 1 if(defined($options{'k-random'}));
		$k_zonename  = 1 if(defined($options{'k-zone'}));

		$k_label     = 1 if(defined($options{'label'}));

		#
		# $keysflag isn't used any more for output selection, so we'll
		# set it to indicate that some keys should be printed.
		$keysflag = 1;
	}

	#
	# If -headers was given, we'll turn off the label flags.
	#
	if($headerflag)
	{
		$z_label = 0 if(!defined($options{'label'}));
		$s_label = 0 if(!defined($options{'label'}));
		$k_label = 1;
	}

}

#-----------------------------------------------------------------------------
# Routine:	getkeyrecs()
#
# Purpose:	This routine reads the specified keyrec file and puts each
#		keyrec into the appropriate keyrec hash table.  There are
#		hashes for zones, KSK keys, ZSK keys, current KSKs, obsolete
#		KSKs, and all keys.  current ZSKs, new ZSKs, published ZSKs,
#		obsolete ZSKs, and all keys.
#
sub getkeyrecs
{
	my $krfile = shift;			# Keyrec file.

	keyrec_read($krfile);

	@krnames = keyrec_names();

	foreach my $krn (sort(@krnames))
	{
		my $kr;				# Reference to keyrec.
		my %keyrec;			# Keyrec.
		my $type;			# Keyrec's type.

		$kr = keyrec_fullrec($krn);
		%keyrec = %$kr;

		$type = $keyrec{'keyrec_type'};

		if($type eq 'zone')
		{
			my $archdir;

			#
			# Set the archive directory to the default if one
			# isn't defined for the zone.
			#
			if(!defined($kr->{'archivedir'}))
			{
				$kr->{'archivedir'} = $archive;
			}

			$zones{$krn} = $kr;
		}
		elsif($type eq 'set')
		{
			my $name;		# Key for hash entry.

			$name = "$krn($kr->{'zonename'})";
			$sets{$name} = $kr;
		}
		elsif($type eq 'kskcur')
		{
			$allkeys{$krn}	= $kr;
			$kcurkeys{$krn}	= $kr;
			$kskkeys{$krn}	= $kr;
		}
		elsif($type eq 'kskpub')
		{
			$allkeys{$krn}	= $kr;
			$kpubkeys{$krn}	= $kr;
			$kskkeys{$krn}	= $kr;
		}
		elsif($type eq 'kskobs')
		{
			$kobskeys{$krn}	= $kr;
			$kskkeys{$krn}	= $kr;
		}
		elsif($type eq 'zskcur')
		{
			$allkeys{$krn}	= $kr;
			$zcurkeys{$krn}	= $kr;
			$zskkeys{$krn}	= $kr;
		}
		elsif($type eq 'zsknew')
		{
			$allkeys{$krn}	= $kr;
			$znewkeys{$krn}	= $kr;
			$zskkeys{$krn}	= $kr;
		}
		elsif($type eq 'zskpub')
		{
			$allkeys{$krn}	= $kr;
			$zpubkeys{$krn}	= $kr;
			$zskkeys{$krn}	= $kr;
		}
		elsif($type eq 'zskobs')
		{
			$zobskeys{$krn}	= $kr;
			$zskkeys{$krn}	= $kr;
		}
	}
}

#----------------------------------------------------------------------
# Routine:	makeheaders()
#
# Purpose:	Build header lines as a fake keyrec.
#
sub makeheaders
{
	return if(!$headerflag);

	#
	# Build the headers for zones.
	#
	if($zonesflag)
	{
		my %kr = ();
		$kr{'keyrec_name'}	= $ZONE;
		$kr{'keyrec_type'}	= 'Zone';
		$kr{'zonefile'}		= 'Zone File';
		$kr{'keyrec_signdate'}	= 'Signing Date';
		$kr{'expdate'}		= 'Expiration Date';
		$kr{'archivedir'}	= 'Archive Directory';
		$zones{$HEADER_KRN} = \%kr;
	}

	#
	# Build the headers for signing sets.
	#
	if($setsflag)
	{
		my %kr = ();
		$kr{'keyrec_name'}	= $SET;
		$kr{'keyrec_type'}	= 'Set';
		$kr{'keys'}		= 'Keys';
		$kr{'zonename'}		= 'Zone Name';
		$kr{'keyrec_setdate'}	= 'Last Set Modification';
		$sets{$HEADER_KRN} = \%kr;
	}

	#
	# Build the headers for keys.
	#
	if($keysflag)
	{
		my %kr = ();
		$kr{'keyrec_name'}	= 'Key Name';
		$kr{'keyrec_type'}	= 'Key Type';
		$kr{'algorithm'}	= 'Algorithm';
		$kr{'enddate'}		= 'End Date';
		$kr{'keyrec_gendate'}	= 'Key Generation';
		$kr{'keylength'}	= 'Key Length';
		$kr{'keylife'}		= 'Key Life';
		$kr{'keypath'}		= 'Key Path';
		$kr{'random'}		= 'Random Generator';
		$kr{'zonename'}		= 'Zone Name';

		#
		# Are these five needed?
		#
		$kr{'keyrec_gensecs'}	= 'Key Generation';
		$kr{'ksklength'}	= 'Key Length';
		$kr{'ksklife'}		= 'Key Life';
		$kr{'zsklength'}	= 'Key Length';
		$kr{'zsklife'}		= 'Key Life';

		$allkeys{$HEADER_KRN} = \%kr;
		$selkeys{$HEADER_KRN} = \%kr;
	}

}

#----------------------------------------------------------------------
# Routine:	maxlens()
#
# Purpose:	Calculate the maximum length of each keyrec field for the
#		zone, signing set, and key keyrecs.  Length data for each
#		type of keyrec will be saved separately.
#		After finding the longest length for each field, we'll
#		add a little buffer space.
#
sub maxlens
{
	#
	# Initialize the lengths hashes.
	#
	%lengths = ();

	#
	# If we'll be printing zones, we'll calculate the maximum length
	# of each field in each zone keyrec.
	#
	if($zonesflag)
	{
		#
		# Loop through the zone list and get data on the desired zones.
		#
		foreach my $name (sort(keys(%zones)))
		{
			my $rref  = $zones{$name};
			my %kr = %$rref;

			foreach my $fld (sort(keys(%kr)))
			{
				if(length($kr{$fld}) > $lengths{$ZONE}{$fld})
				{
					$lengths{$ZONE}{$fld} = length($kr{$fld});
				}
			}
		}

		#
		# Hardcode the length of the expiration date string.
		# Unless we change our system of time-keeping, this will be 24.
		#
		$lengths{$ZONE}{'expdate'} = 24;

		#
		# Add a little buffer space between fields.
		#
		foreach my $fld (sort(keys(%{$lengths{$ZONE}})))
		{
			my $newlen;

			$newlen = $lengths{$ZONE}{$fld};
			$newlen += $COLSPACE;
			$lengths{$ZONE}{$fld} = $newlen;
		}
	}

	#
	# If we'll be printing signing sets, we'll calculate the maximum
	# length of each field in each set keyrec.
	#
	if($setsflag)
	{
		#
		# Loop through the set list and get data on the desired sets.
		#
		foreach my $name (sort(keys(%sets)))
		{
			my $rref  = $sets{$name};
			my %kr = %$rref;

			foreach my $fld (sort(keys(%kr)))
			{
				if(length($kr{$fld}) > $lengths{$SET}{$fld})
				{
					$lengths{$SET}{$fld} = length($kr{$fld});
				}
			}
		}

		#
		# Add a little buffer space between fields.
		#
		foreach my $fld (sort(keys(%{$lengths{$SET}})))
		{
			my $newlen;

			$newlen = $lengths{$SET}{$fld};
			$newlen += $COLSPACE;
			$lengths{$SET}{$fld} = $newlen;
		}
	}

	#
	# If we'll be printing keys, we'll calculate the maximum length
	# of each field in each set keyrec.
	#
	if($keysflag)
	{
		#
		# Loop through the selected key list and get data on the
		# desired keys.
		#
		foreach my $name (sort(keys(%selkeys)))
		{
			my $rref  = $selkeys{$name};
			my %kr;

			#
			# Skip undefined hash keys.
			#
			next if(!defined($rref));

			%kr = %$rref;

			#
			# Go through the keyrec's fields and check them
			# against the saved maximum lengths of key fields.
			#
			foreach my $fl (sort(keys(%kr)))
			{
				if(length($kr{$fl}) > $lengths{$KEY}{$fl})
				{
					$lengths{$KEY}{$fl} = length($kr{$fl});
				}
			}
		}

		#
		# Add a little buffer space between fields.
		#
		foreach my $fld (sort(keys(%{$lengths{$KEY}})))
		{
			my $newlen;

			$newlen = $lengths{$KEY}{$fld};
			$newlen += $COLSPACE;
			$lengths{$KEY}{$fld} = $newlen;
		}
	}

}

#-----------------------------------------------------------------------------
# Routine:	showzones()
#
# Purpose:	This routine displays zone data.  It has three output formats:
#
#			normal	A zone label, the zone name, the zone file,
#				and the zone's signing date are displayed.
#
#			terse	The zone name is displayed.
#
#			long	A zone label, the zone name, the zone file,
#				the zone's signing date, and the zone's date
#				of expiry are displayed.
#
#		If one of the zone expiration flags was given then there is
#		also a check made to see if the zone is expired.
#
sub showzones
{
	my $out = "";				# Output string to build.

	my $signdate;				# Zone's signing date.
	my $zonename;				# Zone's name.
	my $zonefile;				# Zone's zonefile.

	my $archdir;				# Zone's archive directory.
	my $endtime;				# Calculated expiration date.
	my $signsecs;				# Signing date in seconds.
	my $expdate;				# Expiration date in seconds.

	#
	# Reset our previous key value.
	#
	$prevkey = '';

	#
	# Loop through the zone list and give data on the desired zones.
	#
	foreach my $zk (sort(keys(%zones)))
	{
		my $krr = $zones{$zk};
		my %kr = %$krr;

		#
		# Check the zone-validity flags against the zone to see if
		# the record should be displayed.
		#
		if(($validflag	 &&  expiredzone($zk))	||
		   ($expiredflag && !expiredzone($zk)))
		{
			next;
		}

		#
		# Bump the matching-records count.
		#
		$count++ if($zk ne $HEADER_KRN);

		#
		# Stay cloaked if only the count of matching records
		# should be given.
		#
		next if($cntflag);

		#
		# Get a bunch of data from the zone keyrec.
		#
		$signdate = $kr{'keyrec_signdate'};
		$zonefile = $kr{'zonefile'};
		$endtime  = $kr{'endtime'};
		$expdate  = $kr{'expdate'};
		$archdir  = $kr{'archivedir'};
		$signsecs = $kr{'keyrec_signsecs'};

		#
		# Get a string holding the zone's expiration date.
		#
		if($zk ne $HEADER_KRN)
		{
			$endtime = $signsecs + $endtime;
			$expdate = gmtime($endtime);

			$zones{$zk}{'expdate'} = $expdate;
		}

		#
		# Get the zone's name.
		#
		$zonename = $HEADER_KRN if($zonename eq "");
		$zonename = $zk;

		#
		# Build the output string.
		#
		$prevkey = 'first-field';
		$out  = outstr($ZONE,$zk,'keyrec_type','zone',$z_label,0);
		$out .= outstr($ZONE,$zk,'keyrec_name',$zonename,1,0);
		$out .= outstr($ZONE,$zk,'zonefile',$zonefile,$z_zonefile,0);
		$out .= outstr($ZONE,$zk,'keyrec_signdate',$signdate,$z_signdate,1);
		$out .= outstr($ZONE,$zk,'expdate',$expdate,$z_expdate,1);
		$out .= outstr($ZONE,$zk,'archivedir',$archdir,$z_archdir,0);

		#
		# Write the output string.
		#
		print "$out\n";

	}

	print "\n" if($headerflag && ($setsflag || $keysflag));
}

#-----------------------------------------------------------------------------
# Routine:	showsets()
#
# Purpose:	This routine displays set data.  It has three output formats:
#
#			normal	A label, the set name, the set's zone, and the
#				set's keys are displayed.
#
#			terse	The set name and the set's zone are displayed.
#
#			long	A label, the set name, the set's keys, the set's
#				zone, the set's creation date are displayed.
#
sub showsets
{
	my $out = "";				# Output string to build.

	my $setname;				# Set's name.
	my $keylist;				# Set's key list.
	my $moddate;				# Set's creation date.
	my $zone;				# Set's zonename.

	my $endtime;				# Calculated expiration date.
	my $setsecs;				# Signing date in seconds.

	#
	# Reset our previous key value.
	#
	$prevkey = '';

	#
	# Loop through the set list and give data on the desired sets.
	#
	foreach my $sk (sort(keys(%sets)))
	{
		my $krr = $sets{$sk};		# Reference to set's keyrec.
		my %kr = %$krr;			# Set's keyrec.
		my $ref = 0;			# Referenced-set flag.
		my $zkr;			# Ref. to set's zone keyrec.

		#
		# Get a bunch of data from the zone keyrec.
		#
		$zone	 = $kr{'zonename'};
		$keylist = $kr{'keys'};
		$moddate = $kr{'keyrec_setdate'};

		#
		# Check the zone-validity flags against the zone to see if
		# the record should be displayed.
		#

		#
		# If the set's zone exists, we'll check to see if 
		# the zone uses this set as one of its own.
		#
		$zkr = $zones{$zone};
		if(defined($zkr))
		{
			if(($zkr->{'kskcur'} eq $sk)	||
			   ($zkr->{'kskpub'} eq $sk)	||
			   ($zkr->{'zskcur'} eq $sk)	||
			   ($zkr->{'zskpub'} eq $sk)	||
			   ($zkr->{'zsknew'} eq $sk))
			{
				$ref = 1;
			}
		}

		#
		# If either of the referenced or unreferenced flags were set, 
		# we'll only give the the appropriate sets.
		#
		# (I'm sure the logic could have been reduced, but this
		# version is nice and clear.)
		#
		if($refflag || $unrefflag)
		{
			if((!$ref && $refflag)		||
			   ( $ref && $unrefflag))
			{
				next;
			}
		}

		#
		# Bump the matching-records count.
		#
		$count++ if($sk ne $HEADER_KRN);

		#
		# Stay cloaked if only the count of matching records
		# should be given.
		#
		next if($cntflag);

		#
		# Get the set's name (stripping off the zone.)
		#
		$sk =~ /(.*)\(.*\)/;
		$setname = $1;
		$setname = $HEADER_KRN if($setname eq "");

		#
		# Build the output string.
		#
		$prevkey = 'first-field';
		$out  = outstr($SET,$sk,'keyrec_type','set',$z_label,0);
		$out .= outstr($SET,$sk,'keyrec_name',$setname,1,0);
		$out .= outstr($SET,$sk,'zonename',$zone,$s_zone,0);
		$out .= outstr($SET,$sk,'keyrec_setdate',$moddate,$s_setdate,1);
		$out .= outstr($SET,$sk,'keys',$keylist,$s_keys,0);

		#
		# Write the output string.
		#
		print "$out\n";

	}

	print "\n" if($headerflag && ($keysflag));
}

#-----------------------------------------------------------------------------
# Routine:	showkeys()
#
# Purpose:	This routine goes through the key-related hashes and prints
#		output for them.  It's only done if the appropriate option
#		has been given, blah blah blah.
#
sub showkeys
{
	my $krr;			# Reference to a key's keyrec.

	#
	# Select a header line.
	#
	if($headerflag)
	{
		$krr = $selkeys{$HEADER_KRN};
		selkey($HEADER_KRN,$krr,'');
	}

	#
	# Select the information about the Current KSK keys.
	#
	if($kcurflag)
	{
		foreach my $k (sort(keys(%kcurkeys)))
		{
			$krr = $kcurkeys{$k};
			selkey($k,$krr,"KSK-cur");
		}
	}

	#
	# Select the information about the Published KSK keys.
	#
	if($kpubflag)
	{
		foreach my $k (sort(keys(%kpubkeys)))
		{
			$krr = $kpubkeys{$k};
			selkey($k,$krr,"KSK-pub");
		}
	}

	#
	# Select the information about the obsolete KSK keys.
	#
	if($kobsflag)
	{
		foreach my $k (sort(keys(%kobskeys)))
		{
			$krr = $kobskeys{$k};
			selkey($k,$krr,"KSK-obs");
		}
	}

	#
	# Select the information about the Current ZSK keys.
	#
	if($zcurflag)
	{
		foreach my $k (sort(keys(%zcurkeys)))
		{
			$krr = $zcurkeys{$k};
			selkey($k,$krr,"ZSK-cur");
		}
	}

	#
	# Select the information about the Published ZSK keys.
	#
	if($zpubflag)
	{
		foreach my $k (sort(keys(%zpubkeys)))
		{
			$krr = $zpubkeys{$k};
			selkey($k,$krr,"ZSK-pub");
		}
	}

	#
	# Select the information about the New ZSK keys.
	#
	if($znewflag)
	{
		foreach my $k (sort(keys(%znewkeys)))
		{
			$krr = $znewkeys{$k};
			selkey($k,$krr,"ZSK-new");
		}
	}

	#
	# Select the information about the obsolete ZSK keys.
	#
	if($zobsflag)
	{
		foreach my $k (sort(keys(%zobskeys)))
		{
			$krr = $zobskeys{$k};
			selkey($k,$krr,"ZSK-obs");
		}
	}

	#
	# Write the selected key data.
	#
	writekeys();
}

#-----------------------------------------------------------------------------
# Routine:	expiredzone()
#
# Purpose:	This routine determines if a specified zone has expired or
#		if it's still valid.
#
# Return Values:
#		 1 - the zone has expired
#		 0 - the zone has not expired
#
sub expiredzone
{
	my $zn = shift;				# Zone name to be checked.
	my %zkr;				# Zone keyrec.
	my $zkrref;				# Reference to zone keyrec.

	my $endtime;				# Zone's end-time.
	my $signsecs;				# Zone's signing date.

	my $curtime = time();			# Current time.
	my $secs;				# Seconds in "+nnn" endtime.
	my $finaltime;				# Time zone expires.

	#
	# Get the zone's keyrec.
	#
	$zkrref = $zones{$zn};
	%zkr = %$zkrref;

	#
	# Pull some data from the keyrec.
	#
	$endtime  = $zkr{'endtime'};
	$signsecs = $zkr{'keyrec_signsecs'};

	#
	# Get the number of seconds until the zone's end time.
	#
	if($endtime =~ /^+/)
	{
		$endtime =~ /\+([0-9]+)/;
		$secs = $1;
	}

	#
	# Calculate the zone's expiration date.
	#
	$finaltime = $signsecs + $secs;

	#
	# If the zone has expired, we'll return success.  If not, we'll
	# return failure.
	#
	if($finaltime <= $curtime)
	{
		return(1);
	}

	return(0);
}

#-----------------------------------------------------------------------------
# Routine:	refdkey()
#
# Purpose:	This routine determines if a named key is referenced by any
#		zones.  KSKs and ZSKs are referenced in signing sets, so
#		those must be checked..
#
# Return Values:
#		 1 - the key is referenced
#		 0 - the key is not referenced
#
sub refdkey
{
	my $kn = shift;			# Key name to be checked.
	my %zkr;			# Zone keyrec.
	my $zkrref;			# Reference to zone keyrec.
	my $zn;				# Zone name.

	#
	# Check each zone to see if it's using this key.
	#
	foreach $zn (keys(%zones))
	{
		$zkrref = $zones{$zn};
		%zkr = %$zkrref;

		#
		# Go through each signing set to see if it holds this key.
		#
		foreach my $set (keys(%sets))
		{
			return(1) if(keyrec_signset_haskey($set,$kn));
		}
	}

	#
	# Didn't find a reference to the key, so we'll return failure.
	#
	return(0);
}

#-----------------------------------------------------------------------------
# Routine:	selkey()
#
# Purpose:	This routine selects the keys whose data will be displayed.
#		It is called for two types of KSKs and three flavors of ZSK.
#		It handles the referenced-key options, depending on whether
#		or not the specified key is actually referenced.
#
sub selkey
{
	my $key	 = shift;		# Key name.
	my $kkr	 = shift;		# Reference to key's keyrec.
	my $lbl	 = shift;		# Output label.

	my %kr = %$kkr;			# Key's keyrec.

	my $algorithm;			# Key's algorithm.
	my $ender;			# Key's lifespan date (in seconds.)
	my $gendate = "";		# Key's date.
	my $enddate = "";		# Key's end-date (in text.)
	my $length;			# Key's length.
	my $life;			# Key's lifespan.
	my $path;			# Key's path.
	my $random;			# Key's random number generator.
	my $zonename;			# Name of key's owning zone.
	my $out  = "";			# Output string.

	#
	# Check this key's reference state against the command options.
	#
	if($key ne $HEADER_KRN)
	{
		if(($refflag   && !refdkey($key)) ||
		   ($unrefflag &&  refdkey($key)))
		{
			return;
		}
	}

	#
	# Bump the matching-records count.
	#
	$count++ if($key ne $HEADER_KRN);

	#
	# Run silent if only the count of matching records should be given.
	#
	return if($cntflag);

	#
	# Set up some -long specific stuff.
	#
	if($long)
	{
		$lbl .= "-key";
	}

	#
	# Get the key's data.
	#
	$algorithm = $kr{'algorithm'};
	$path	   = $kr{'keypath'};
	$random	   = $kr{'random'};
	$zonename  = $kr{'zonename'};
	$gendate   = "$kr{'keyrec_gendate'}" if(!$nodateflag);

	#
	# Set some key-type-specific values.
	#
	if($kr{'keyrec_type'} =~ /^ksk/)
	{
		$lbl	.= "\t" if($long);
		$length	 = $kr{'ksklength'};
		$life	 = $kr{'ksklife'};
	}
	else
	{
		$length	= $kr{'zsklength'};
		$life	= $kr{'zsklife'}
	}

	#
	# Do some field-specific data majigulations.
	#
	if($key eq $HEADER_KRN)
	{
		$enddate = $kr{'enddate'};
	}
	else
	{
		#
		# Calculate the key's end-date.
		#
		$ender = $kr{'keyrec_gensecs'} + $life;
		$enddate = gmtime($ender);

		#
		# Set a dummy value if the lifetime wasn't set yet.
		#
		$life = "(not set)" if($life eq "");
	}

	#
	# Save the calculated end date.
	#
	$allkeys{$key}{'enddate'} = $enddate;

	#
	# Save the key data to the selected-keys hash.
	#
	$selkeys{$key}{'keyrec_name'}	= $key;
	$selkeys{$key}{'keyrec_type'}	= $allkeys{$key}{'keyrec_type'};
	$selkeys{$key}{'algorithm'}	= $algorithm;
	$selkeys{$key}{'enddate'}	= $enddate;
	$selkeys{$key}{'gendate'}	= $gendate;
	$selkeys{$key}{'keylength'}	= $length;
	$selkeys{$key}{'keylife'}	= $life;
	$selkeys{$key}{'keypath'}	= $path;
	$selkeys{$key}{'random'}	= $random;
	$selkeys{$key}{'zonename'}	= $zonename;
}

#----------------------------------------------------------------------
# Routine:	writekeys()
#
# Purpose:	This routine performs the actual output operations for key
#		data.  It creates an output string for each of the keys saved
#		in the %selkeys hash.
#
sub writekeys
{
	#
	# Adjust the key's type a bit.
	#
	foreach my $key (sort(keys(%selkeys)))
	{
		my $keytype;				# Key's type.

		$keytype = $selkeys{$key}{'keyrec_type'};
		$keytype =~ s/^ksk/KSK-/;
		$keytype =~ s/^zsk/ZSK-/;
		$selkeys{$key}{'keyrec_type'} = $keytype;
	}

	#
	# Now that we have the actual keys, recalculate the maximum lengths.
	#
	$zonesflag = $setsflag = 0;
	maxlens();

	#
	# Write the selected keys.
	#
	foreach my $key (sort(keys(%selkeys)))
	{
		my $out = '';				# Output string.
		my $algorithm;				# Key's algorithm.
		my $enddate;				# Key's expiration date.
		my $gendate;				# Key's generation date.
		my $length;				# Key's length.
		my $life;				# Key's lifespan.
		my $path;				# Key's path.
		my $random;				# Key's randomizer.
		my $type;				# Key's type.
		my $zonename;				# Key's zone.

		#
		# Set-up for output line.
		#
		$prevkey = 'first-field';

		#
		# Save the key data to the selected-keys hash.
		#
		$algorithm = $selkeys{$key}{'algorithm'};
		$enddate   = $selkeys{$key}{'enddate'};
		$gendate   = $selkeys{$key}{'gendate'};
		$length	   = $selkeys{$key}{'keylength'};
		$life	   = $selkeys{$key}{'keylife'};
		$path	   = $selkeys{$key}{'keypath'};
		$random	   = $selkeys{$key}{'random'};
		$type	   = $selkeys{$key}{'keyrec_type'};
		$zonename  = $selkeys{$key}{'zonename'};

		#
		# Build the output string.
		#
		$out  = outstr($KEY,$key,'keyrec_type',$type,$k_label,0);
		$out .= outstr($KEY,$key,'keyrec_name',$key,1,0);
		$out .= outstr($KEY,$key,'zonename',$zonename,$k_zonename,0);
		$out .= outstr($KEY,$key,'algorithm',$algorithm,$k_algorithm,0);
		$out .= outstr($KEY,$key,'keylength',$length,$k_length,0);
		$out .= outstr($KEY,$key,'gendate',$gendate,$k_date,1);
		$out .= outstr($KEY,$key,'keylife',$life,$k_life,0);
		$out .= outstr($KEY,$key,'enddate',$enddate,$k_enddate,1);
		$out .= outstr($KEY,$key,'keypath',$path,$k_path,0);
		$out .= outstr($KEY,$key,'random',$random,$k_random,0);

		#
		# Write the output string.
		#
		print "$out\n";
	}
}

#----------------------------------------------------------------------
# Routine:	outstr()
#
# Purpose:	Build an output line.  We'll do whatever spacing is required
#		so that each type's records line up nicely.  The built output
#		line is returned to the caller.
#
sub outstr
{
	my $dtype = shift;		# Type of these data.
	my $krname = shift;		# Zone/set/key name.
	my $key  = shift;		# Hashkey.
	my $val	 = shift;		# Value to print.
	my $flag = shift;		# Output flag.
	my $usequotes = shift;		# Quotes flag.

	my $ret;			# Return string.

	my $krgroup;			# Keyrec group to consult.
	my $maxcollen;			# Max field length of previous field.
	my $prevcollen;			# Length of previous field's value.
	my $numspaces = 0;		# Spaces to add to previous field.
	my $spaces = '';		# Spaces to add.

	#
	# Return if the given flag isn't set and -long wasn't given.
	#
	return('') if(!$flag);

	#
	# Figure out which group of keyrecs to use.  We're intentionally
	# not using a default for this and will thus allow things to die
	# horrible death if this routine is improperly used.
	#
	if($dtype eq $ZONE)
	{
		$krgroup = \%zones;
	}
	elsif($dtype eq $SET)
	{
		$krgroup = \%sets;
	}
	elsif($dtype eq $KEY)
	{
		$krgroup = \%selkeys;
	}

	#
	# Use the data's type as the name field for the header line.
	#
	if(($key eq 'keyrec_name') && ($val eq $HEADER_KRN))
	{
		$val = $dtype;
		$krgroup->{$krname}{$key} = $dtype;
	}

	#
	# Add in the appropriate header for zone and set data.
	# (Key keyrecs have their type header pre-set.)
	#
	if((($key eq 'keyrec_type')	&&
	    ($krname eq $HEADER_KRN))		&&
	   (($val eq 'zone') || ($val eq 'set')))
	{
		$val = "Type";
		$krgroup->{$krname}{$key} = $val;
	}

	#
	# Figure out spacing for this column.
	#
	$maxcollen  = $lengths{$dtype}{$prevkey};
	$prevcollen = length($krgroup->{$krname}{$prevkey});
	$numspaces  = $maxcollen - $prevcollen;

	#
	# Build the spacing.
	#
	$spaces = ' ' x $numspaces if($numspaces > 0);

	#
	# Build the output line.
	#
	$ret = $spaces . $val;

	#
	# For some fields we'll add quotes around the value.
	# We won't add quotes if we're printing headers.
	#
	$usequotes = 0 if($headerflag);
	if($usequotes && ($krname ne $HEADER_KRN))
	{
		$ret =~ s/$spaces$val/$spaces\"$val\"/;
	}

	#
	# Save the hash key and return the output string to the caller.
	#
	$prevkey = $key;
	return($ret);
}

#----------------------------------------------------------------------
# Routine:	version()
#
# Purpose:	Print the version number(s) and exit.
#
sub version
{
	print STDERR "$VERS\n";
	print STDERR "$DTVERS\n";

	exit(1);
}


#-----------------------------------------------------------------------------
# Routine:	usage()
#
sub usage
{
	print STDERR "usage:  lskrf [options] <keyrec-file>\n";
	print STDERR "\trecord-selection options:\n";
	print STDERR "\t\t-all		list all records\n";
	print STDERR "\t\t-zones\t	list all zones\n";
	print STDERR "\t\t-sets		list all signing sets\n";
	print STDERR "\t\t-keys		list all keys\n";
	print STDERR "\t\t-ksk		list KSK keys\n";
	print STDERR "\t\t  -kcur		list Current KSK keys\n";
	print STDERR "\t\t  -kpub		list Published KSK keys\n";
	print STDERR "\t\t  -kobs		list Obsolete KSK keys\n";
	print STDERR "\t\t-zsk		list ZSK keys\n";
	print STDERR "\t\t  -cur		list Current ZSK keys\n";
	print STDERR "\t\t  -pub		list Published ZSK keys\n";
	print STDERR "\t\t  -new		list New ZSK keys\n";
	print STDERR "\t\t  -obs		list obsolete ZSK keys\n";

	print STDERR "\trecord-attribute options:\n";
	print STDERR "\t\t-valid\t	show keyrecs of unexpired zones\n";
	print STDERR "\t\t-expired	show keyrecs of expired zones\n";
	print STDERR "\t\t-ref		show referenced key keyrecs\n";
	print STDERR "\t\t-unref\t	show unreferenced key keyrecs\n";

	print STDERR "\toutput-format options:\n";
	print STDERR "\t\t-count		only give count of matching keyrecs\n";
	print STDERR "\t\t-label		show record-type label\n";
	print STDERR "\t\t-headers	give explanatory column headers\n";
	print STDERR "\t\t-life		display date\n";
	print STDERR "\t\t-long		long output\n";
	print STDERR "\t\t-nodate		do not display date\n";
	print STDERR "\t\t-terse\t	terse output\n";
	print STDERR "\t\t-help		help message \n";
	print STDERR "\t\t-Version	Show version information\n";

	print STDERR "\tzone-attribute options:\n";
	print STDERR "\t\t-z-archdir	show zone's key-archive directory\n";
	print STDERR "\t\t-z-expdate	show zone's expiration date\n";
	print STDERR "\t\t-z-signdate	show zone's signing date\n";
	print STDERR "\t\t-z-zonefile	show zone's zonefile\n";

	print STDERR "\tkey-attribute options:\n";
	print STDERR "\t\t-k-algorithm	show key's algorithm\n";
	print STDERR "\t\t-k-enddate	show key's end-date\n";
	print STDERR "\t\t-k-length	show key's length\n";
	print STDERR "\t\t-k-lifespan	show key's lifespan\n";
	print STDERR "\t\t-k-path		show key's path\n";
	print STDERR "\t\t-k-random	show key's random number generator\n";
	print STDERR "\t\t-k-signdate	show key's signing date\n";
	print STDERR "\t\t-k-zone		show key's zonefile\n";

	exit(0);
}

1;

##############################################################################
#

=pod

=head1 NAME

lskrf - List the I<keyrec>s in a DNSSEC-Tools I<keyrec> file.

=head1 SYNOPSIS

  lskrf [options] <keyrec-files>

=head1 DESCRIPTION

B<lskrf> lists the contents of the specified I<keyrec> files.  All
I<keyrec> files are loaded before the output is displayed.  If any I<keyrec>s
have duplicated names, whether within one file or across multiple files, the
later I<keyrec> will be the one whose data are displayed.  The output given
depends on the options selected.

=head1 OPTIONS

B<lskrf> takes three types of options:  record-selection options,
record-attribute options, and output-style options.  These option
sets are detailed below.

=head2 Record-Selection Options

These options select the types of I<keyrec> that will be displayed.

=over 4

=item -all

This option displays all the records in a I<keyrec> file.

=item -zones

This option displays the zones in a I<keyrec> file.

=item -sets

This option displays the signing sets in a I<keyrec> file.

=item -keys

This option displays the keys in a I<keyrec> file.

=item -ksk

This option displays the KSK keys in a I<keyrec> file.

=item -kcur

This option displays the Current KSK keys in a I<keyrec> file.

=item -kpub

This option displays the Published KSK keys in a I<keyrec> file.

=item -kobs

This option displays the obsolete KSK keys in a I<keyrec> file.  This option
must be give if obsolete KSK keys are to be displayed.

=item -zsk

This option displays the ZSK keys in a I<keyrec> file.  It does not include
obsolete ZSK keys; the I<-obs> option must be specified to display obsolete
keys.

=item -cur

This option displays the Current ZSK keys in a I<keyrec> file.

=item -new

This option displays the New ZSK keys in a I<keyrec> file.

=item -pub

This option displays the Published ZSK keys in a I<keyrec> file.

=item -obs

This option displays the obsolete ZSK keys in a I<keyrec> file.  This option
must be give if obsolete ZSK keys are to be displayed.

=back

=head2 Record-Attribute Options

These options select subsets of the I<keyrec>s chosen by the
record-selection options. 

=over 4

=item -valid

This option displays the valid zones in a I<keyrec> file.
It implies the I<-zones> option.

=item -expired

This option displays the expired zones in a I<keyrec> file.
It implies the I<-zones> option.

=item -ref

This option displays the referenced signing set I<keyrec>s or the referenced
key I<keyrec>s in a I<keyrec> file, depending upon other selected options.

Referenced state depends on the following:

  * Signing sets are considered to be referenced if they
    are listed in a zone keyrec.

  * KSKs are considered to be referenced if they are listed
    in a zone keyrec.

  * ZSKs are considered to be referenced if they are listed
    in a set keyrec.

This option may be used with either the I<-sets> or I<-keys> options.  If it
isn't used with any record-selection options, then it is assumed that both
I<-sets> and I<-keys> have been specified.

=item -unref

This option displays the unreferenced signing set I<keyrec>s or the
unreferenced key I<keyrec>s in a I<keyrec> file, depending upon other
selected options.

Unreferenced state depends on the following:

  * Signing sets are considered to be unreferenced if they
    are not listed in a zone keyrec.

  * KSKs are considered to be unreferenced if they are not
    listed in a zone keyrec.

  * ZSKs are considered to be unreferenced if they are not
    listed in a set keyrec.

  * Obsolete ZSKs are checked, whether or not the -obs flag
    was specified.

This option may be used with either the I<-sets> or I<-keys> options.  If it
isn't used with any record-selection options, then it is assumed that both
I<-sets> and I<-keys> have been specified.

=back

=head2 Zone-Attribute Options

These options allow specific zone fields to be included in the output.  If
combined with the I<-terse> option, only those fields specifically desired
will be printed.

=over 4

=item z-archdir

Display the zone's archive directory.  If an archive directory is not
explicitly set for the zone, the default directory will be listed.

=item z-expdate

Display the zone's expiration date.

=item z-signdate

Display the zone's signing date.

=item z-zonefile

Display the zone's zonefile.

=back

=head2 Set-Attribute Options

There are no options specifically for signing set fields.  However, the general
I<-terse>, I<-long>, and I<-label> options control the signing-set output.
Due to potential signing-set name conflicts among zones, the sets' zone names
will always be printed.

=head2 Key-Attribute Options

These options allow specific key fields to be included in the output.  If
combined with the I<-terse> option, only those fields specifically desired
will be printed.

=over 4

=item -k-algorithm

Display the key's encryption algorithm.

=item -k-enddate

Display the key's end-date, calculated by adding the key's lifespan to its
signing date.

=item -k-length

Display the key's length.

=item -k-lifespan

Display the key's lifespan (in seconds.) This lifespan is B<only> related to
the time between key roll-over.  There is no other lifespan associated with a
key.

=item -k-path

Display the key's path.

=item -k-random

Display the key's random number generator.

=item -k-signdate

Display the key's signing date.

=item -k-zone

Display the key's zonefile.

=back

=head2 Output-Format Options

These options define how the I<keyrec> information will be displayed.

Without any of these options, the zone name, zone file, zone-signing date,
and a label will be displayed for zones.  For types, the key name, the key's
zone, the key's generation date, and a label will be displayed if these
options aren't given.

=over 4

=item -count

The count of matching records will be displayed, but the matching records
will not be.

=item -nodate

The key's generation date will not be printed if this flag is given.

=item -headers

Display explanatory column headers.  If this flag is given, then entry labels
will not be printed unless explicitly requested by use of the I<-label>
option.

=item -label

A label for the I<keyrec>'s type will be given.

=item -long

The long form of output will be given.  For zones, the zone name, the zone
file, the zone's signing date, the zone's expiration date, and a label will
be displayed.  For keys, the key name, the key's zone, the key's encryption
algorithm, the key's length, the key's generation date, and a label are
given.

=item -terse

This options displays only the name of the zones or keys selected by other
options.

=item -help

Display a usage message.

=back

=head1 COPYRIGHT

Copyright 2005-2007 SPARTA, Inc.  All rights reserved.
See the COPYING file included with the DNSSEC-Tools package for details.

=head1 AUTHOR

Wayne Morrison, tewok@users.sourceforge.net

=head1 SEE ALSO

B<zonesigner(8)>

B<Net::DNS::SEC::Tools::keyrec.pm(3)>

B<file-keyrec(5)>

=cut

