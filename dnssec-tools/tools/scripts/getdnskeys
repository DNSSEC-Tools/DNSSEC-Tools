#!/usr/bin/perl

use strict;
use Net::DNS;
use Net::DNS::SEC;
use IO::File;

my %opts;
my @origargs = @ARGV;

LocalGetOptions(\%opts,
		['GUI:separator',"DNS Configuration:"],
		['k','Only look for key signing keys (KSK) and ignore others'],

		['GUI:separator',
		 "Named.conf configuration file input support:"],
		['i|named-conf-in-file=s',
		'Read path as a named.conf to compare key lists with'],
		['T|use-current-trusted-keys',
		 'Check the current trusted key list from named.conf'],

		['GUI:separator',
		 "Named.conf configuration file output support:"],
		['o|output-file=s','Output the results to a file'],
		['t|print-named-conf-tokens',
		 'Enclose output in needed named.conf syntax markers'],

		['GUI:separator','Miscellanious Configuration:'],
		['v|verbose','Verbose mode'],
);

my $res = Net::DNS::Resolver->new;
my %keystorage;
my $output;

read_named_conf_keys(\%keystorage, $opts{'i'}) if ($opts{'i'});

if ($opts{'o'}) {
    $output = new IO::File;
    if (!$output->open(">" . $opts{'o'})) {
	print STDERR "Could not open output file: $opts{'o'}\n";
	exit 1;
    }
}

use Data::Dumper;;

my @currentkeys;
@currentkeys = keys(%keystorage) if ($opts{'T'});

# print leading named.conf information
if ($opts{'t'}) {
    Output("// \n");
    Output("// trusted-keys list generated by $0\n");
    Output("//  arguments: ", join(" ",@origargs),"\n");
    Output("// \n\n");
    Output("trusted-keys {\n");
}

#
# foreach domain to check, query for it's dns keys and then compare
# against the stashed copies.
#
foreach my $domain (@currentkeys, @ARGV) {
    my $q = $res->query($domain, "DNSKEY");

    Verbose("Checking keys in $domain\n");
    if ($q) {
	#
	my $newkeys = 0;
	foreach my $rec (grep { $_->type eq 'DNSKEY'} $q->answer) {
	    next if ($opts{'k'} && !($rec->flags & 1));   # KSK's only

	    my $key = $rec->key;
	    $key =~ s/\s+//g;

	    # if we're storing output (! -q) then print the keys
	    Output(sprintf "  %s  %d %d %d \"%s\";\n",
		   $domain, $rec->flags, $rec->protocol, $rec->algorithm, $key);

	    # compare against cached named.conf records
	    $newkeys += compare_keys(\%keystorage, $domain, $rec, $key)
	}
	Verbose(sprintf("  Old: %3d    New: %3d\n",
			1+$#{$keystorage{$domain}},
			$newkeys));
    } else {
	# no answer or other resolution problem
	print STDERR
	  "  Error pulling keys for $domain (maybe there were none)\n";
	print STDERR
	  "  Error: " . $res->errorstring . "\n";
    }
}

# print the trailer for the named.conf information
Output("};\n") if ($opts{'t'});

#######################################################################
# comapare_keys()
#
# compares the contents of two keys to see if the new one ($domain,
# $rec, and $keyin) matches the cached one previously remembered (in
# $storage->{$domain} )
#
sub compare_keys {
    my ($storage, $domain, $rec, $keyin) = @_;
    if (!exists($storage->{$domain})) {
	print STDERR "  Found a key for $domain; previously we had none cached\n";
    }
    my $keys = $storage->{$domain};
    foreach my $key (@$keys) {
	if ($key->{'flags'} eq $rec->flags &&
	    $key->{'protocol'} eq $rec->protocol &&
	    $key->{'algorithm'} eq $rec->algorithm &&
	    $key->{'key'} eq $keyin) {
	    # the key exactly matches a stored key
	    $key->{'found'} = 1;
	    return 0;
	}
    }
    print STDERR "  Found a new key found for $domain\n";
    return 1;
}

#######################################################################
# read_named_conf_keys()
#
# reads in a named.conf file pointed to by $file and stores key
# information in $storage
#
sub read_named_conf_keys {
    my ($storage, $file) = @_;
    Verbose("reading and parsing trust keys from $file\n");
    # regexp pulled from Fast.pm
    my $pat_maybefullname = qr{[-\w\$\d*]+(?:\.[-\w\$\d]+)*\.?};

    my $fh = new IO::File;
    if (!$fh->open("<$file")) {
	print STDERR "Could not open named configuration file: $file\n";
	exit 1;
    }
    while (<$fh>) {
	if (/trusted-keys {/) {
	    while (<$fh>) {
		last if (/^\s*};/);
		if (/\s*($pat_maybefullname)\s+(256|257)\s+(\d+)\s+(\d+)\s+\"(.+)\"\s*;/) {
		    push @{$storage->{$1}},
		      { flags => $2,
			protocol => $3,
			algorithm => $4,
			key => $5 };
		    $storage->{$1}[$#{$storage->{$1}}]{key} =~ s/\s+//g;
		}
	    }
	}
    }
}

#######################################################################
# Verbose()
#
# prints something(s) to STDERR only if -v was specified.
#
sub Verbose {
    print STDERR @_ if ($opts{'v'});
}

#######################################################################
# Output()
#
# prints something(s) to the output filehandle if -o was specified.
#
sub Output {
    print $output @_ if ($opts{'o'});
}

#######################################################################
# Getopt::GUI::Long portability
#
sub LocalGetOptions {
    if (eval {require Getopt::GUI::Long;}) {
	require Getopt::Long;
	import Getopt::GUI::Long;
	Getopt::GUI::Long::Configure(qw(display_help no_ignore_case));
	return GetOptions(@_);
    }
    require Getopt::Long;
    import Getopt::Long;
    Getopt::Long::Configure(qw(auto_help no_ignore_case));
    GetOptions(LocalOptionsMap(@_));
}

sub LocalOptionsMap {
    my ($st, $cb, @opts) = ((ref($_[0]) eq 'HASH') 
			    ? (1, 1, $_[0]) : (0, 2));
    for (my $i = $st; $i <= $#_; $i += $cb) {
	if ($_[$i]) {
	    next if (ref($_[$i]) eq 'ARRAY' && $_[$i][0] =~ /^GUI:/);
	    push @opts, ((ref($_[$i]) eq 'ARRAY') ? $_[$i][0] : $_[$i]);
	    push @opts, $_[$i+1] if ($cb == 2);
	}
    }
    return @opts;
}

=pod

=head1 NAME

getdnskeys - Fetch, compare and remember a list of DNSKEYs from DNS zones.

=head1 SYNOPSIS

# then fetch the dnssec-tools.org key using:

  getdnskeys -o /etc/named.trustkeys.conf -k -v -t dnssec-tools.org

# then in your main named.conf file put the following line:

  include "/etc/named.trustkeys.conf";

# ... and restart named

# Finally, check the file against live keys occasionally.

  getdnskeys -i /etc/named.trustkeys.conf -T -k -v -t

# And automatically update it if you wish:

  getdnskeys -i /etc/named.trustkeys.conf -T -o /etc/named.trustkeys.conf -k -v -t

=head1 SECURITY ISSUES

Currently this does not validate new keys placed in the file in any
way, nor does it validate change over keys which have been added.

It also does not handle revokation of keys.

It should prompt you before adding a new key so that you can always
run the auto-update feature.

=cut

