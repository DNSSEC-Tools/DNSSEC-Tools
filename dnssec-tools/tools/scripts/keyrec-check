#!/usr/bin/perl
#
# Copyright 2004-2005 SPARTA, Inc.  All rights reserved.  See the COPYING
# file distributed with this software for details
#
#
# keyrec-check
#
#	This script checks a keyrec file for problems, potential problems,
#	and inconsistencies.
#
#	Problems include:
#
#		- no zones defined
#		- no keys defined
#		- unknown zone keyrecs  (key keyrec points to a non-existent
#					 zone keyrec)
#		- mislabeled keys (key thinks it's KSK/ZSK, zone
#				   thinks it's a ZSK/KSK)
#		- missing key from zone keyrec
#		- invalid zone data values
#			- existence of zone file
#			- existence of KSK file
#			- existence of ZSK file
#			- endtime > 1 day
#			- seconds count and date string match
#		- invalid key data values
#			- bad encryption algorithm
#			- out-of-range bit values
#			- non-existent random device
#			- seconds count and date string match
#		- expired zone keyrecs
#
#	Potential problems include:
#
#		- soon-to-expire zone keyrecs
#		- odd zone-signing date
#		- orphaned key keyrecs  (not referenced by any zone keyrecs)
#		- non-existent key directories
#
#	Inconsistencies include:
#
#		- zone fields in a key keyrec
#		- key fields in a zone keyrec
#

use strict;

use Getopt::Long;

use Net::DNS::SEC::Tools::keyrec;
use Net::DNS::SEC::Tools::tooloptions;

#######################################################################

#
# Time "constants".
#
my $DAY	  = (24 * 60 * 60);		# Seconds in a day.
my $WEEK  = (7 * $DAY);			# Seconds in a week.

my $DAYSWARN = 7;			# Days before an expiration warning.


#
# List of valid encryption algorithms and length ranges.
#
my @algorithms = ("rsasha1", "rsamd5", "dsa", "dh", "hmac-md5");

my %length_low =
(
	"rsasha1"  => 512,
	"rsamd5"   => 512,
	"dsa"	   => 512,
	"dh"	   => 128,
	"hmac-md5" => 1
);

my %length_high =
(
	"rsasha1"  => 2048,
	"rsamd5"   => 2048,
	"dsa"	   => 1024,
	"dh"	   => 4096,
	"hmac-md5" => 512
);

#######################################################################

#
# Data required for command line options.
#
my $count   = 0;			# Error-count flag.
my $quiet   = 0;			# Quiet flag.
my $verbose = 0;			# Verbose flag.
my $keychk  = 0;			# Keys-only flag.
my $zonechk = 0;			# Zones-only flag.
my %options = ();			# Filled option array.
my @opts =
(
	"count+",			# Give final error count.
	"quiet+",			# Don't give any output.
	"verbose+",			# Give lotsa output.
	"help",				# Give a usage message and exit.
	"zone",				# Only check zone keyrecs.
	"key",				# Only check key keyrecs.
);


my $zoneerrs = 0;			# Count of errors in zones.
my $keyerrs = 0;			# Count of errors in keys.

my @krnames;				# List of keyrecs in the file.

my %zones = ();				# Names of zone keyrecs.
my %kskkeys = ();			# Names of KSK keyrecs.
my %zskkeys = ();			# Names of ZSK keyrecs.

my $curtime;				# Current time.

my $ret;				# Return code from main().

$ret = main();
exit($ret);

#-----------------------------------------------------------------------------
#
# Routine:	main()
#
sub main()
{
	my $argc = @ARGV;		# Number of command line arguments.
	my $errors = 0;			# Total error count.

	#
	# Check our options.
	#
	GetOptions(\%options,@opts);
	$count	 = $options{'count'};
	$quiet	 = $options{'quiet'};
	$verbose = $options{'verbose'};
	$keychk	 = $options{'key'};
	$zonechk = $options{'zone'};

	if(defined($options{'help'}))
	{
		usage();
	}

	if($keychk && $zonechk)
	{
		usage();
	}

	#
	# Ensure we were given a keyrec file to check.
	#
	if($argc == 0)
	{
		print STDERR "usage:  keyrec-check [-q] [-v] <keyrec_file>\n";
		exit(1);
	}

	#
	# Read the keyrec file.
	#
	getkeyrecs($ARGV[0]);

	#
	# Check our watch.
	#
	$curtime = time();

	#
	# Run the zone checks.
	#
	if(!$keychk)
	{
		zonechecks();
	}

	#
	# Run the key checks.
	#
	if(!$zonechk)
	{
		keychecks();
	}

	$errors = $zoneerrs + $keyerrs;
	if($count)
	{
		print("$errors errors\n");
	}
	return($errors);
}

#-----------------------------------------------------------------------------
#
# Routine:	zonechecks()
#
sub zonechecks
{
	my $zkr;				# Zone keyrec reference.
	my %zonerec;				# Zone keyrec.

	my $zonename;				# Zone name for looping.
	my $keyname;				# Key name.

	my @fields = keyrec_keyfields();	# Valid key fields.

	if(length(%zones) == 0)
	{
		vprint("no zones defined\n");
		$zoneerrs++;
		return;
	}

	foreach my $zonename (sort(keys(%zones)))
	{
		vprint("checking zone $zonename\n");

		$zkr = $zones{$zonename};

		zonedata($zonename,$zkr);

		zonekeys($zonename,$zkr);

		expiredzones($zonename,$zkr);

		crosshkeys("zone","key",$zonename,$zkr,@fields);
	}

	vprint("\n");
}

#-----------------------------------------------------------------------------
#
# Routine:	keychecks()
#
sub keychecks
{
	my $kr;					# Keyrec reference.
	my %keyrec;				# Keyrec.

	my @fields = keyrec_zonefields();	# Valid zone fields.

	if(length(%kskkeys) == 0)
	{
		vprint("no KSK keys defined\n");
		$keyerrs++;
	}
	else
	{
		foreach my $keyname (sort(keys(%kskkeys)))
		{
			vprint("checking KSK key $keyname\n");

			$kr = $kskkeys{$keyname};
			%keyrec = %$kr;

			keydata("KSK",$keyname,$kr);

			keyzones("KSK",$keyname,\%keyrec);

			orphankeys("KSK",$keyname);

			keytypes("KSK",$keyname);

			crosshkeys("KSK","zone",$keyname,$kr,@fields);
		}
	}
	vprint("\n");

	if(length(%zskkeys) == 0)
	{
		vprint("no ZSK keys defined\n");
		$keyerrs++;
	}
	else
	{
		foreach my $keyname (sort(keys(%zskkeys)))
		{
			vprint("checking ZSK key $keyname\n");

			$kr = $zskkeys{$keyname};
			%keyrec = %$kr;

			keydata("ZSK",$keyname,$kr);

			keyzones("ZSK",$keyname,\%keyrec);

			orphankeys("ZSK",$keyname);

			keytypes("ZSK",$keyname);

			crosshkeys("ZSK","zone",$keyname,$kr,@fields);
		}
	}

}

#-----------------------------------------------------------------------------
#
# Routine:	getkeyrecs()
#
sub getkeyrecs
{
	my $krfile = shift;			# Keyrec file.

	keyrec_read($krfile);

	@krnames = keyrec_names();

	foreach my $krn (sort(@krnames))
	{
		my $kr;				# Reference to keyrec.
		my %keyrec;			# Keyrec.
		my $type;			# Keyrec's type.

		$kr = keyrec_fullrec($krn);
		%keyrec = %$kr;

		$type = $keyrec{'keyrec_type'};

		if($type eq 'zone')
		{
			$zones{$krn} = $kr;
		}
		elsif($type eq 'ksk')
		{
			$kskkeys{$krn} = $kr;
		}
		elsif(($type eq 'zskcur') || ($type eq 'zsknew') ||
		      ($type eq 'zskpub'))
		{
			$zskkeys{$krn} = $kr;
		}
	}
}

##############################################################################
#									     #
# 				Zone checks				     #
#									     #
##############################################################################

#-----------------------------------------------------------------------------
#
# Routine:	zonekeys()
#
sub zonekeys
{
	my $zonename = shift;			# Zone name for looping.
	my $zkr	     = shift;			# Zone keyrec reference.
	my %zonerec  = %$zkr;			# Zone keyrec.

	my $keyname;				# Key name.

	#
	# Ensure that the zone's KSK key is present and exists.
	#
	$keyname = $zonerec{'kskkey'};
	if(!defined($keyname))
	{
		qprint("missing key:  KSK (zone $zonename)\n");
		$zoneerrs++;
	}
	elsif(!defined($kskkeys{$keyname}))
	{
		qprint("no such key:  KSK key $keyname (zone $zonename)\n");
		$zoneerrs++;
	}

	#
	# Ensure that the zone's current ZSK is present and exists.
	#
	$keyname = $zonerec{'zskcur'};
	if(!defined($keyname))
	{
		qprint("missing key:  current ZSK (zone $zonename)\n");
		$zoneerrs++;
	}
	elsif(!defined($zskkeys{$keyname}))
	{
		qprint("no such key:  current ZSK key $keyname (zone $zonename)\n");
		$zoneerrs++;
	}

	#
	# We aren't checking the zone for a new ZSK, as that's only present
	# in a roll-over situation.
	#

	#
	# Ensure that the zone's published ZSK is present and exists.
	#
	$keyname = $zonerec{'zskpub'};
	if(!defined($keyname))
	{
		qprint("missing key:  published ZSK (zone $zonename)\n");
		$zoneerrs++;
	}
	elsif(!defined($zskkeys{$keyname}))
	{
		qprint("no such key:  published ZSK key $keyname (zone $zonename)\n");
		$zoneerrs++;
	}

	vprint("\n");

}

#-----------------------------------------------------------------------------
#
# Routine:	expiredzones()
#
sub expiredzones
{
	my $zonename = shift;				# Zone name to check.
	my $zkr	     = shift;				# Keyrec reference.
	my %zonerec  = %$zkr;				# Zone keyrec.

	my $endtime  = $zonerec{'endtime'};		# Zone's endtime.
	my $signsecs = $zonerec{'keyrec_signsecs'};	# Zone's sign date.

	$ret = checkexpire('zone',$zonename,$endtime,$signsecs);
	$zoneerrs += $ret;
}

#-----------------------------------------------------------------------------
#
# Routine:	zonedata()
#
sub zonedata
{

	my $zonename = shift;			# Zone's name.
	my $kr	     = shift;			# Keyrec reference.
	my %keyrec   = %$kr;			# Zone table.

	my $zonefile = $keyrec{'zonefile'};
	my $kskdir   = $keyrec{'kskdirectory'};
	my $kskfile  = $keyrec{'kskpath'};
	my $zskdir   = $keyrec{'zskdirectory'};
	my $zskcfile = $keyrec{'zskcur'};
	my $zsknfile = $keyrec{'zsknew'};
	my $zskpfile = $keyrec{'zskpub'};
	my $endtime  = $keyrec{'endtime'};
	my $signsecs = $keyrec{'keyrec_signsecs'};
	my $signdate = $keyrec{'keyrec_signdate'};

	my $datestr;				# Converted keyrec_signsecs.

	#
	# Check the existence of the zone file.
	#
	if(defined($zonefile) && (! -e $zonefile))
	{
		qprint("missing file:  zone file $zonefile (zone $zonename)\n");
		$zoneerrs++;
	}

	#
	# Check the existence of the KSK key file.
	#
	if(defined($kskfile) && (! -e $kskfile))
	{
		qprint("missing file:  KSK $kskfile (zone $zonename)\n");
		$zoneerrs++;
	}

	#
	# Check the existence of the KSK key directory.
	#
	if(defined($kskdir) && (! -e $kskdir))
	{
		qprint("missing directory:  KSK $kskdir (zone $zonename)\n");
		$zoneerrs++;
	}

	#
	# Check the existence of the current ZSK key file.
	#
	if(defined($zskcfile) && (! -e ($zskcfile . ".key")))
	{
		qprint("missing file:  current ZSK $zskcfile (zone $zonename)\n");
		$zoneerrs++;
	}

	#
	# Check the existence of the new ZSK key file.
	#
	if(defined($zsknfile) && (! -e ($zsknfile . ".key")))
	{
		qprint("missing file:  new ZSK $zsknfile (zone $zonename)\n");
		$zoneerrs++;
	}

	#
	# Check the existence of the published ZSK key file.
	#
	if(defined($zskpfile) && (! -e ($zskpfile . ".key")))
	{
		qprint("missing file:  published ZSK $zskpfile (zone $zonename)\n");
		$zoneerrs++;
	}

	#
	# Check the existence of the ZSK key directory.
	#
	if(defined($zskdir) && (! -e $zskdir))
	{
		qprint("missing directory:  ZSK $zskdir (zone $zonename)\n");
		$zoneerrs++;
	}

	#
	# Make sure the zone's endtime is more than a day.
	#
	if(defined($endtime) && ($endtime =~ /^\+[0-9]+/))
	{
		my $secs;			# Second-count in endtime.

		$endtime =~ /^\+([0-9]+)/;
		$secs = $1;
		if($secs < $DAY)
		{
			qprint("strange endtime:  $secs < one day (zone $zonename)\n");
			$zoneerrs++;
		}
	}

	#
	# Ensure that the zone's seconds count converts into the date
	# stored in its date string.
	#
	$datestr = gmtime($signsecs);
	if(defined($signdate) && ($datestr ne $signdate))
	{
		qprint("mismatched timestamps:  $signsecs invalid for \"$signdate\" (zone $zonename)\n");
		$zoneerrs++;
	}

}

##############################################################################
#									     #
# 				Key checks				     #
#									     #
##############################################################################

#-----------------------------------------------------------------------------
#
# Routine:	keydata()
#
sub keydata
{
	my $keytype = shift;			# Keyrec's type.
	my $keyname = shift;			# Keyrec's name.
	my $kr	    = shift;			# Keyrec reference.
	my %keyrec  = %$kr;			# Key table.

	my $found = 0;				# Algorithm-found flag.
	my $length;				# Key length.

	my $algorithm	= lc($keyrec{'algorithm'});
	my $random	= $keyrec{'random'};
	my $gensecs	= $keyrec{'keyrec_gensecs'};
	my $gendate	= $keyrec{'keyrec_gendate'};

	my $datestr;				# Converted keyrec_gensecs.

	#
	# Get the key's length.
	#
	if($keytype eq "KSK")
	{
		$length = $keyrec{'ksklength'};
	}
	else
	{
		$length = $keyrec{'zsklength'};
	}

	#
	# Search the algorithm list for this key's algorithm.  If we find
	# it, we'll mark that it's good.
	#
	if(defined($algorithm))
	{
		foreach my $alg (@algorithms)
		{
			if($alg eq $algorithm)
			{
				$found = 1;
				last;
			}
		}
	}

	#
	# If the key's encryption algorithm is bad, we'll give an error
	# message.  If it's okay, we'll make sure the length is in the
	# range of valid lengths for the key type.
	#
	if(!$found)
	{
		qprint("invalid algorithm:  \"$algorithm\" ($keytype key $keyname)\n");
		$keyerrs++;
	}
	else
	{
		my $lowval  = $length_low{$algorithm};
		my $highval = $length_high{$algorithm};

		if($lowval > $length)
		{
			qprint("invalid key length:  length ($length) < minimum ($lowval) for $algorithm ($keytype key $keyname)\n");
			$keyerrs++;
		}
		if($highval < $length)
		{
			qprint("invalid key length:  length ($length) > maximum ($lowval) for $algorithm ($keytype key $keyname)\n");
			$keyerrs++;
		}
	}

	#
	# Check the existence of the random number file.
	#
	if(defined($random))
	{
		if(! -e $random)
		{
			qprint("missing file:  random generator $random ($keytype key $keyname)\n");
			$keyerrs++;
		}
	}

	#
	# Ensure that the key's seconds count converts into the date
	# stored in its date string.
	#
	$datestr = gmtime($gensecs);
	if(defined($gendate) && ($datestr ne $gendate))
	{
		qprint("mismatched timestamps:  $gensecs invalid for \"$gendate\" ($keytype key $keyname)\n");
		$keyerrs++;
	}

}

#-----------------------------------------------------------------------------
#
# Routine:	keyzones()
#
sub keyzones
{
	my $keytype = shift;			# Keyrec's type.
	my $keyname = shift;			# Keyrec's name.
	my $kr	    = shift;			# Keyrec reference.
	my %keyrec  = %$kr;			# Key table.

	my $zonename;				# Zone name to check.

	$zonename = $keyrec{'zonename'};

	if($zonename eq "")
	{
		qprint("no zone given:  $keytype key $keyname\n");
		$keyerrs++;
		return;
	}

	if(!defined($zones{$zonename}))
	{
		qprint("no such zone:  $zonename ($keytype key $keyname)\n");
		$keyerrs++;
	}
}

#-----------------------------------------------------------------------------
#
# Routine:	orphankeys()
#
sub orphankeys
{
	my $keytype = shift;			# Keyrec's type.
	my $keyname = shift;			# Keyrec's name.

	my $zkr;				# Zone reference.
	my %keyrec;				# Key table.

	my $found = 0;				# Key-found flag.

	#
	# Look through the zone list to ensure the key is referenced somewhere.
	#
	foreach my $zonename (sort(keys(%zones)))
	{
		$zkr = $zones{$zonename};
		%keyrec = %$zkr;

		#
		# If the key is in this zone, we'll mark that we've found
		# it.  Once we've found it, we'll drop out.
		#
		if(($keyrec{'kskkey'} eq $keyname)	||
		   ($keyrec{'zskcur'} eq $keyname)	||
		   ($keyrec{'zsknew'} eq $keyname)	||
		   ($keyrec{'zskpub'} eq $keyname))
		{
			$found = 1;
			last;
		}
	}

	#
	# Give an error message if we didn't find it.
	#
	if(!$found)
	{
		qprint("orphaned key:  $keytype key $keyname\n");
	}
}

#-----------------------------------------------------------------------------
#
# Routine:	keytypes()
#
sub keytypes
{
	my $keytype = shift;			# Keyrec's type.
	my $keyname = shift;			# Keyrec's name.

	my $zkr;				# Zone reference.
	my %keyrec;				# Key table.

	my $badtype = 0;			# Bad-type flag.
	my $foundtype;				# Bad type we found.

	#
	# Look through the zone list to ensure the key and the zone agree
	# about the key's type.
	#
	foreach my $zonename (sort(keys(%zones)))
	{
		$zkr = $zones{$zonename};
		%keyrec = %$zkr;

		#
		# If the key is in this zone, we'll check if this key's
		# type matches the way the zone thinks about it.
		#
		if($keyrec{'kskkey'} eq $keyname)
		{
			if($keytype eq "ZSK")
			{
				$badtype = 1;
				$foundtype = "ZSK";
			}
		}
		elsif(($keyrec{'zskcur'} eq $keyname) ||
		      ($keyrec{'zsknew'} eq $keyname) ||
		      ($keyrec{'zskpub'} eq $keyname))
		{
			if($keytype eq "KSK")
			{
				$badtype = 1;
				$foundtype = "KSK";
			}
		}

	}

	#
	# Give an error message if the key and zone have mismatched ideas
	# about the key's type.
	#
	if($badtype)
	{
		qprint("mislabeled key type:  $keytype key $keyname\n");
	}

}

##############################################################################
#									     #
# 				Utilities				     #
#									     #
##############################################################################

#-----------------------------------------------------------------------------
#
# Routine:	checkexpire()
#
sub checkexpire
{
	my $type     = shift;			# Zone name for looping.
	my $name     = shift;			# Zone name for looping.
	my $endtime  = shift;			# Zone's endtime.
	my $signsecs = shift;			# Zone's sign date.

	my $errs = 0;				# Error count.

	my $secs;				# Seconds in "+nnn" endtime.
	my $days;				# Days until zone expiration.
	my $daystr = "days";			# Days string.
	my $finaltime;				# Time zone expires.

	#
	# Ensure that the keyrec's sign date is older than the current time.
	#
	if($signsecs > $curtime)
	{
		qprint("bizarre time:  sign date more recent than current date ($type $name)\n");
		$errs++;
	}

	#
	# Get the number of seconds until the keyrec's end time.
	#
	if($endtime =~ /^+/)
	{
		$endtime =~ /\+([0-9]+)/;
		$secs = $1;
	}

	#
	# Calculate the keyrec's expiration date.
	#
	$finaltime = $signsecs + $secs;

	#
	# Make sure the keyrec hasn't expired yet.  If it hasn't, we'll
	# check to see if it's close to expiration.
	#
	if($finaltime <= $curtime)
	{
		$secs = $curtime - $finaltime;
		$days = int($secs / $DAY);
		$daystr = "day" if ($days == 1);
		qprint("signtime:  $type expired $days $daystr ago ($type $name)\n");
		$errs++;
	}
	else
	{
		#
		# Figure out how many days are left until expiration.
		#
		$secs = $finaltime - $curtime;
		$days = int($secs / $DAY);
		$daystr = "day" if ($days == 1);

		#
		# Check if the keyrec will soon expire.
		#
		if($days <= $DAYSWARN)
		{
			qprint("signtime:  $type expires in $days $daystr ($type $name)\n");
			$errs++;
		}
	}

	return($errs);
}

#-----------------------------------------------------------------------------
#
# Routine:	crosshkeys()
#
sub crosshkeys
{
	my $krtype   = shift;			# Type of keyrec.
	my $fldtype   = shift;			# Type of @fields' keys.
	my $krname   = shift;			# Keyrec's name.
	my $kr	   = shift;			# Reference to keyrec.
	my @fields = shift;			# Hash keys to check for.

	my %keyrec = %$kr;			# Caller's keyrec.
	my $errs   = 0;				# Error count.

	#
	# None of the entries in @fields should be hash keys in the
	# keyrec.  We'll check to ensure all's well.
	#
	foreach my $key (@fields)
	{
		#
		# Skip internal-use fields.
		#
		if($key eq "keyrec_type")
		{
			next;
		}

		if(exists($keyrec{$key}))
		{
			qprint("bad entry:  $fldtype hash-key $key in a $krtype record  ($krtype $krname)\n");
			$errs++;
		}
	}

	if($errs == 0)
	{
		qprint("hash entry:  all hash-keys valid  ($krtype $krname)\n");
	}
	return($errs);
}

#-----------------------------------------------------------------------------
#
# Routine:	dumpdata()
#
sub dumpdata
{
	my $keyname;				# Key name for looping.
	my $zonename;				# Zone name for looping.

	if(!$verbose)
	{
		return;
	}

	print "zones:\n";
	foreach $zonename (sort(keys(%zones)))
	{
		print "\t$zonename\n";
	}
	print "\n";

	print "ksks:\n";
	foreach $keyname (sort(keys(%kskkeys)))
	{
		print "\t$keyname\n";
	}
	print "\n";

	print "zsks:\n";
	foreach $keyname (sort(keys(%zskkeys)))
	{
		print "\t$keyname\n";
	}
	print "\n";
}

#-----------------------------------------------------------------------------
#
# Routine:	qprint()
#
sub qprint
{
	my $line = shift;

	if(!$quiet)
	{
		print $line;
	}
}

#-----------------------------------------------------------------------------
#
# Routine:	vprint()
#
sub vprint
{
	my $line = shift;

	if($verbose)
	{
		qprint($line);
	}
}

#-----------------------------------------------------------------------------
#
# Routine:	usage()
#
sub usage
{
	print STDERR "usage:  keyrec-check [-c] [-q] [-v] [-h]\n";
	exit(0);
}

1;

##############################################################################
#

=pod

=head1 NAME

keyrec-check - Check a DNSSEC-Tools I<keyrec> file for problems and
inconsistencies.

=head1 SYNOPSIS

  keyrec-check [-z | -k] [-c] [-q] [-v] [-h] keyrec-file

=head1 DESCRIPTION

This script checks a I<keyrec> file for problems, potential problems,
and inconsistencies.

Recognized problems include:

=over 4

=item * no zones defined

The I<keyrec> file does not contain any zone I<keyrec>s.

=item * no keys defined

The I<keyrec> file does not contain any key I<keyrec>s.

=item * unknown zone I<keyrec>s

A key I<keyrec> references a non-existent zone I<keyrec>.

=item * missing key from zone I<keyrec>

A zone I<keyrec> does not have both a KSK key and a ZSK key.

=item * expired zone I<keyrec>s

A zone has expired.

=item * mislabeled key

A key is labeled as a KSK (or ZSK) and its owner zone has it labeled as the
opposite.

=item * invalid zone data values

A zone's I<keyrec> data are checked to ensure that they are valid.  The
following conditions are checked:  existence of the zone file, existence of
the KSK file, existence of the ZSK file, the end-time is greater than one
day, and the seconds-count and date string match.

=item * invalid key data values

A key's I<keyrec> data are checked to ensure that they are valid.  The
following conditions are checked:  valid encryption algorithm, key length
falls within algorithm's size range, random generator file exists, and the
seconds-count and date string match.

=back

Recognized potential problems include:

=over 4

=item * imminent zone expiration

A zone will expire within one week. 

=item * odd zone-signing date

A zone's recorded signing date is later than the current system clock.

=item * orphaned keys

A key I<keyrec> is unreferenced by any zone I<keyrec>.

=item * missing key directories

A zone I<keyrec>'s key directories (I<kskdirectory> or I<zskdirectory>) does
not exist.

=back

Recognized inconsistencies include:

=over 4

=item * key-specific fields in a zone I<keyrec>

A zone I<keyrec> contains key-specific entries.  To allow for site-specific
extensibility, I<keyrec-check> does not check for undefined I<keyrec> fields.

=item * zone-specific fields in a key I<keyrec>

A key I<keyrec> contains zone-specific entries.  To allow for site-specific
extensibility, I<keyrec-check> does not check for undefined I<keyrec> fields.

=back

=head1 OPTIONS

=over 4

=item -k

Only perform checks of key I<keyrec>s.  This option may not be combined with
the B<-z> option.

=item -z

Only perform checks of zone I<keyrec>s.  This option may not be combined with
the B<-k> option.

=item -c

Display a final count of errors.

=item -q

Do not display messages.  This option supersedes the setting of the I<-v>
option.

=item -v

Display many messages.  This option is subordinate to the I<-q> option.

=item -h

Display a usage message.

=back

=head1 COPYRIGHT

Copyright 2004-2005 SPARTA, Inc.  All rights reserved.
See the COPYING file included with the dnssec-tools package for details.

=head1 AUTHOR

Wayne Morrison, tewok@users.sourceforge.net

=head1 SEE ALSO

B<Net::DNS::SEC::Tools::keyrec.pm(3)>

=cut
