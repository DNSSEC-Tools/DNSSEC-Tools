# Copyright 2004-2008 SPARTA, Inc.  All rights reserved.
# See the COPYING file included with the dnssec-tools package for details.


			     DNSSEC-Tools
			Is your domain secure?


DNSSEC validator
----------------

The libval(3) library provides basic functionality for resource-record
validation.  It relies on the resolver component (see
libsres-implementation-notes for more details) to fetch answers from a
DNSSEC-aware name server.

Overview 
-------

The security extensions to DNS allows applications to test the authenticity of
data returned by the DNS. The validator library performs this test by checking
the cryptographic signatures that cover DNS records and by building a sequence 
of such verified records up to a trusted key. The library exports a number of 
basic interfaces that applications may use in lieu of older resolver interfaces 
provided by the libres(3) library. Other interfaces are also provided that 
allow applications more detail into the validation process. This range allows 
for the creation of applications that are either only interested in a basic
"validated" or "not-validated" result, or more sophisticated applications that
can look for specific errors as a sign of some network abnormality or attack.

See libval(3), val_gethostbyname(3), val_getaddrinfo(3), val_res_query(3) and
val_get_rrset(3) for the interfaces are exported by the validator. 

The validator supports the RSA/MD5 [RFC_2537], DSA/SHA-1 [RFC_2536] and 
RSA/SHA-1 [RFC_3110] DNSSEC algorithms.  It uses the OpenSSL software package 
for cryptographic processing.  


Validator Design Choices
------------------------

1. Trusted versus validated conditions 

The DNSSEC specification lists four validation states: success, bogus, 
indeterminate and provably insecure. While the validator library is 
able to gather details of each of these conditions by inspecting the
authentication chain, most applications are only interested in a high-level
answer that tells it if the response was trustworthy or not. Since 
the bogus and indeterminate states are effectively equivalent, the DNSSEC
specification really only allows for three conditions - Validated, Untrusted,
Provably Insecure.

The provably insecure condition is interesting, since some applications 
may view this as untrusted, while others may view this as a directive 
by the parent to say that there is no security expectation for the child,
in which the answer is trustworthy.  Validation policy may also specify 
all answers from a zone to be either trustworthy or untrustworthy. 

In view of the above considerations, the validator library defines three
high-level states for answers - trusted, validated, and untrusted.

The validated condition covers all the states where an answer was 
cryptographically validated from a locally configured trust anchor.
The trusted condition covers those states that are validated, and
also those states that are locally trusted. All other conditions 
are untrusted. 

A negative proof may similarly be trusted, validated or untrusted.

The provably insecure condition may be configured by local policy
to either be trusted or not.


2. Top-down versus bottom-up validation

There are two possible ways in which a validator may construct its
authentication chain: top-down and bottom-up. Top-down validation uses the
normative query process to also fetch and validate DNSSEC meta-data,
chaining down from a known trust anchor. Bottom-up validation builds the
authentication chain from the data to a known trust anchor.

For a security-aware recursive name server, the top-down approach is generally
more efficient. For a validating end-system, the type of data that must be
validated decides which approach is more efficient. The reason for this is that
validating end-systems are very often located behind some caching name server
In order to utilize the benefits provided by the DNS caching infrastructure, 
the validating stub resolver must not attempt to recursively answer all 
queries itself. Furthermore, firewall configurations in may environments 
also run recursive name server processes that preempt any attempt made
by the end system to run in recursive mode.

With this architecture in mind, the problems with top-down validation become
evident. In order for top-down validation to work, the validator must be able 
reconstruct the list of zonecuts all the way down from the trust anchor to the
query. It must do so by issuing SOA queries for the list of names obtained by 
adding labels present in the query to the zone name configured as the trust 
anchor, in succession, until the zonecut information can be determined, and 
repeat this process till the zonecut covering the original query is reached.
Bottom-up validation does not suffer from this problem to the extent that
zonecut information for is already available via the RRSIG meta-data.

The above reasoning holds only if zones are signed most of the time. If 
signatures are missing, the validator would have to perform a similar but 
less query-intensive process of determining if the zone that lacked DNSSEC 
meta-data was actually provably insecure. The provably insecure check is 
straightforward to perform if validation happens top-down.

Using the above rationale, the libval library has been designed to do 
bottom-up validation by default and then switch over to top-down validation 
in case a provably insecure condition needs to be checked.

3. Multi-threading support (sharing validator contexts)

Multi-threaded applications should be able to share validator contexts.
The constraints to doing this is that data can time out. However the 
specifications say that data must be kept for the duration of the 
validation check (even if the TTL expires). Another constraint is that
multiple threads can issue the same query at the same time.

The design choices for context sharing are impacted by the following 
concerns:
    - Extent of sharing: applications that are able to access a 
      validator context that is being used by some other application 
      has security implications
    - lock granularity: overhead of acquiring locks for each assertion 
      chain element v/s typical operation of single threaded app
    - posix does not allow lock upgrade and downgrade

The following design choices were made for the validator:
    - New queries_for_query structure
    - only check for relevant queries
    - "hold" the queries in this chain till such time that validate 
      does not complete  
    - Locking strategy
        - big lock for each "run" of the validator
        - sleep(0) between multiple runs to allow other threads to execute
        - add a read lock for each query touched
        - data times out only through the query pointer
        - queries can be deleted only if no lock is held on them

This impacts the resolver logic in that libsres should never block 
(but we were already moving in that direction). The above design choices 
also imply that we are not able to log query-related information since 
this is unreliable after a call to the validator functions (queries may 
time out).


4. NULL contexts 

All functions exported by libval have their first parameter as a 
"validator context". The context provides a handle to the validation 
policy as selected by the application. Since the results of validation 
depend on validator policy, the context also provides the handle to cached 
authentication chains. The expected usage is that applications will create 
a context using the val_create_context() function and supply this value to
different functions so that the results of validation are reused.

Successive calls to val_create_context() create fresh context objects, 
even if they were created using the same label. This allows applications to 
be able to validate using the same policy but without  reusing
older validation results.

libval also allows applications that are DNSSEC-agnostic to supply a NULL 
context for different functions.  In such cases libval will create a 
temporary context using some default policy. However, if this context is
deleted after use, it would mean that DNSSEC-agnostic applications will 
never be able to make use of the benefit of validator caches

In order to account for this we special case the handling of NULL labels 
during context creation.  Instead of creating a fresh context each time 
a NULL argument is given, libval will return a saved value if
the context was already created in the past. This behavior is for NULL 
labels only (and not even for contexts created using the ":" label). in 
other words, successive calls to val_create_contex(":",...) will still 
create fresh contexts. The rationale here is that applications that
know what value to pass as a non-NULL label should also be intelligent 
enough to reuse context objects that they create.

5. Environment overrides for validator policy

While it is always possible to write an application that uses a specific 
validator policy (or allow the user to supply one through a command line
option), we wanted to provide a less intrusive way for users to specify
a validation policy to libval. There were two approaches that we came up 
with - reading the policy label from an variable, and dynamically 
generating the policy label from the application name. 

        locked-down system with single policy
          An administrator that wants to (and is able to) lock down a
          system to a particular validator policy, must be able to
          disable other ways for a user to change the validator
          policy
 
        locked-down system with app-specific policies
          An administrator that wants to (and is able to) lock down a
          system to a particular dnsval.conf file, but wishes to use dif-
          ferent policies for different applications must still be allowed
          to disable reading policy labels from the environment. 

        User controlled
          It must be possible for an administrator to give complete 
          flexibility to the user over the choice of policy label,
          either on a per-application basis or on a system-wide basis.

The set of precedence rules are documented in dnsval.conf(3)


6. Minimizing false positives 

While constructing the chain of trust we are willing to look at more trust
anchors when trying to verify a proof. When trying to prove that DNSSEC is
not required (through the provably insecure condition), we only look at the 
closest matching trust anchor.


Validator Algorithm
-------------------

The val_resolve_and_check() interface forms the core interface for the
validator library. Its algorithm is as follows:

i)	A new validator context is created if one does not exist already.

ii)	The next step in val_resolve_and_check() is to build a data request
	entry for the missing data. The data request entry is stored in the
	"queries" linked list which is of type "struct queries_for_query". 
    Each element in this linked list internally maps to an element in 
    another linked list of type 'struct val_query_chain'. 
    The queries linked list is created separately for each call to 
    val_resolve_and_check. The val_query_chain linked list is maintained 
    on a per-context basis and is the "query cache" for the context.

iii)Not all data requests get translated into actual DNS queries; some
	answers may be obtained from the local cache. Answers are always 
    accessed through the struct val_query_chain element. This is because, data may
    time out. The struct val_query_chain element maintains the state 
    of the response; if it times out the query state will revert to the
    initial state. 

iv)	For every answer that is received, the validator assimilates this data
	and identifies any additional queries need to be made in order to
	either verify the data contained in the response or to build the chain-
	of-trust to a trust anchor. Assimilated data is stored in the "struct
	val_digested_auth_chain" structure, which is also a linked list. A
	separate data request entry is created for each such data component
	that is required and all of them are added to the "queries"
	linked-list. The val_digested_auth_chain linked list is also maintained
    on a per-context basis. 

v)	Data contained in an element of the authentcation chain can be verified
	as long as all cryptographic components necessary to complete this
	operation is available. The verification operation may be
	performed even if other components in the chain of trust are still
	being built.

vi) Since multiple RRsets may be returned in response to a query there
    can be multiple authentication chains that are returned.
    Multiple authentication chains are also possible for negative 
    proofs where the proof is actually comprised of an SOA RR, and one 
    or more NSEC (or NSEC3) RRsets. Multiple answers are represented 
    through multiple elements in the struct val_internal_result linked 
    list. Each val_internal_result element wraps around an authentication 
    chain. It points to the chain and also contains a consolidated 
    validation status value for the authentication chain.

vii)For RRsets in the response that are not validated, the validator may
    selectively perform the DLV logic to identify if the data can be validated
    that way. The DLV logic is only applied if the entry point from the DLV
    tree to the main tree is at a closer point to the query name than any
    configured trust anchor for the main tree.

viii) For status values that map to unsuccessful conditions, an attempt is
    made to see if the answer is actually provably insecure. This test
    test is made in a top-down fashion starting from the closest configured
    trust anchor and ending at the zone cut for the query in question.

viii)Steps iii) through viii) are repeated as long as there are additional
	queries	that have still not received a response or failure from the
	DNS. Upon completion, the authentication chain linked list contains the
	list of all answers that were returned from the DNS with a field
	describing each of their validation status values and a consolidated
    validation status value for the entire authentication chain. If no 
    answers were returned or some DNS error was encountered for a particular 
    query, an empty authentication chain node is created to contain this 
    error value.

ix) Once all authentication chains have been completed, a number of 
    sanity checks are performed on the elements of the . 
     - Any non-existence proofs are checked at this time, but only 
       if all components of the proof are trustworthy.
     - Wildcard responses are checked to see if they actually expand 
       the correct type and the original name itself does not exist.
     - Any CNAME and DNAME chains are checked to ensure that they 
       are loop-free and that they are complete. If the final element
       in a CNAME or DNAME chain is also an alias then any proof of
       non-existence is checked to ensure that the name being pointed
       to is provably non-existent.
   Each element in the val_internal_result linked list that has passed 
   the sanity check above is converted to a similar entry in the 
   val_result_chain linked list. The elements in the val_result_chain
   linked list (including the authentication chain elements) are copied 
   indivually from their val_internal_result counterparts; they are 
   not merely a reference. 

x) Any left over elements in the val_internal_result linked list that
   have not been consumed by the above sanity check process is transformed
   into a similar entry into the val_result_chain linked list. If the element
   is a component of a proof of non-existence it is considered extraneous
   and marked as bogus. 
   
xi)	The val_resolve_and_check() method returns the val_result_chain
   to the calling application only if the application has requested this
   information.


Lower-level routines: digesting answers received from libsres
-------------------------------------------------------------

The validator uses the asynchronous query_send() and response_rcv()
resolver interfaces (see man page for libsres(3)) to fetch answers from the DNS.
The D0 and CD bit on the query is only set if a trust anchor is configured
above the name being queried for. Note that since checks for the provably 
insecure condition are not made as the referral is being traversed, the 
D0 and CD bits are also set while issuing queries for names that are under
a provably insecure domain.

After the answer is received, the first step is "digesting" the response --
RRsets in the answer and authority sections are extracted as is any
referral information present in the additional section of the response. Any
DS or DNSKEY information is also cached for future use. One aspect
of the caching functionality that will change in future is the notion of
credibility of data stored within the cache.

The validator follows any referrals or aliases that are returned as part of 
the response and issues queries to fetch any missing glue. Information gathered 
as part of following referrals are maintained separately within the val_query_chain 
structure. Once the referral operation completes, all information within 
this entry are merged into the validator cache.

The validator keeps track of nameservers that it actually used while following
referrals.  These are re-used in future requests for data in the same zone.

Digestion of answers is followed by assimilation of answers. Here, the data
returned by the digestion process is transformed into an authentication chain
element.  Checks are made to determine the answer kind and if the data or NSEC
was actually relevant.  A sanity check is also made to ensure that all answers
received as part of a query with type as ANY have the same answer kind.  

Query, Assertion and Result states
----------------------------------

Query states transition as follows:

      (cached)
   +------------>Q_ANSWERED
   |                  ^
   |                  | (answer recieved)
   |                  |
   |                  |
   |  (query sent)    |    (error)
Q_INIT ----------> Q_SENT --------> (Q_ERROR_BASE + <error_condition>) 
   ^                | |                   ^
   |                | |                   |
   +<---------------+ |                   |
   |   (referral)     |                   |
   |                  |                   |
   |                  |                   |
   |  (success)       v           (fail)  |
   +<----------- Q_WAIT_FOR_GLUE ---------+


===============================================================================================

   
Assertion states transition as follows:

     VAL_AC_UNSET
         |
         v
     VAL_AC_INIT  
          |                                           
          +----------------->  VAL_AC_TRUST_NOCHK --------------------------------------->+
          |                                                                               |
          |                  +-----------------------+                                    |
          +----------------->| VAL_AC_NEGATIVE_PROOF |----------------------------------->+
          |                  +-----------------------+                                    |
          |                                                                               |
          +----------------->  VAL_AC_WAIT_FOR_RRSIG --------+                            |
          |                              |                   |                            |
          |                              |                   v                            |
          |                              |              +==============+                  |
          |                              |              |    ERROR     |----------------->|
          |                              |              +==============+                  |
          |                              |                   ^                            |
          |                              v                   |                            |
          +----------------->  VAL_AC_WAIT_FOR_TRUST --------+                            |
          |                              |                                                |
          |                              |                                                |
          |                              v              +==============+                  |
          |                     VAL_AC_CAN_VERIFY ----> |  SUCCESS     |                  |
          |                              |              +==============+                  |
          |                              |                                                |
          |                              |                                                |
          |                              v                                                |
          | VAL_AC_FAIL_BASE    +====================+                                    |
          +-------||----------->|       FAIL         | ---------------------------------->+
          | VAL_AC_LAST_FAILURE +====================+                                    |
          |                                                                               |
          |                                                                               |
          |                                                                               |
          | VAL_AC_BAD_BASE     +====================+                                    |
          +-------||----------->|       BAD          |                                    |
          | VAL_AC_LAST_BAD     +====================+                                    |
          |                                                                               |
          |                                                                               |
          |                                                                               |
          |                                                                               |
          |<----------------------------------------------------------------------------->+
          |
          v
  +====================+
  |  DONT GO FURTHER   | 
  +====================+

where:

              +====================+
              |  DONT GO FURTHER   | 
              +====================+
                      |---> VAL_AC_IGNORE_VALIDATION 
                      |---> VAL_AC_TRUSTED_ZONE
                      |---> VAL_AC_UNTRUSTED_ZONE
                      |---> VAL_AC_PROVABLY_INSECURE
                      |---> VAL_AC_BARE_RRSIG
                      |---> VAL_AC_NO_TRUST_ANCHOR
                      +---> VAL_AC_TRUST

              +====================+
              |       ERROR         | 
              +====================+
                      |---> VAL_AC_RRSIG_MISSING 
                      |---> VAL_AC_DNSKEY_MISSING 
                      +---> VAL_AC_DS_MISSING
                      
              +====================+
              |        BAD         | 
              +====================+
                      |---> VAL_AC_DATA_MISSING 
                      +---> VAL_AC_DNS_ERROR
                      
              +====================+
              |       FAIL         | 
              +====================+
                      |
                      |---> VAL_AC_NOT_VERIFIED 
                      |
                      |---> Key status
                      |         |-------------> VAL_AC_UNKNOWN_DNSKEY_PROTOCOL
                      |         |-------------> VAL_AC_DS_NOMATCH
                      |         |-------------> VAL_AC_INVALID_KEY
                      |         +-------------> VAL_AC_ALGORITHM_NOT_SUPPORTED
                      |
                      +---> sig status 
                                |-------------> VAL_AC_WRONG_LABEL_COUNT
                                |-------------> VAL_AC_INVALID_RRSIG
                                |-------------> VAL_AC_RRSIG_NOTYETACTIVE
                                |-------------> VAL_AC_RRSIG_EXPIRED
                                |-------------> VAL_AC_RRSIG_VERIFY_FAILED 
                                |-------------> VAL_AC_RRSIG_ALGORITHM_MISMATCH 
                                |-------------> VAL_AC_DNSKEY_NOMATCH
                                +-------------> VAL_AC_ALGORITHM_NOT_SUPPORTED
            
              +====================+
              |    SUCCESS         | 
              +====================+
                      |
                      |---> VAL_AC_VERIFIED 
                      |
                      |---> Key status  
                      |         |-------------> VAL_AC_TRUST_POINT 
                      |         |-------------> VAL_AC_SIGNING_KEY 
                      |         |-------------> VAL_AC_VERIFIED_LINK
                      |         +-------------> VAL_AC_UNKNOWN_ALGORITHM_LINK
                      |
                      +---> sig status 
                                |
                                |-------------> VAL_AC_RRSIG_VERIFIED 
                                |-------------> VAL_AC_WCARD_VERIFIED
                                |-------------> VAL_AC_RRSIG_VERIFIED_SKEW
                                +-------------> VAL_AC_WCARD_VERIFIED_SKEW
                      

The consolidated dnssec validation results obtained in the results array
are derived from the authentication chain states in the following manner:
(Note: see val_errors.h for values of *_BASE and *_LAST)

any auth.chain.elem    result  
status                 status             
====================================================

> FAIL_BASE,            VAL_BOGUS
<=LAST_FAILURE   

VAL_AC_DNS_ERROR        VAL_DNS_ERROR 
VAL_AC_DATA_MISSING     VAL_DNS_ERROR 

> VAL_AC_DONT_GO_FURTHER  equivalent "termination" 
<= VAL_AC_LAST_STATE      status


trust    every auth.chain.elem   final result status
anchor   status  (if present)   
============================================================================

 YES    VERIFIED                  VAL_SUCCESS
 NO     VERIFIED                  VAL_NOTRUST


The following status values are defined for results of negative proof checks for
the main DNS query:

Condition                         final result
==========================================================================
All components of the proof of    VAL_NONEXISTENT_NAME
non-existence, also validated     or VAL_NONEXISTENT_TYPE

All components of the proof of    VAL_NONEXISTENT_NAME_NOCHAIN
non-existence, trusted but        or VAL_NONEXISTENT_TYPE_NOCHAIN
not validated

Any component of the proof of     VAL_BOGUS
non-existence is not trusted
or proof components are trusted   
but are incomplete

For negative proofs in the middle of the authentication chain, if 
the check for provably insecure condition could not be performed, the
status is set to VAL_BOGUS_PROOF.


For the provably non-existence condition, the following values exist:

Provably insecure trust status      final result
==========================================================================
Trusted                             VAL_PROVABLY_INSECURE
Untrusted                           VAL_BAD_PROVABLY_INSECURE


Current status of libval
------------------------

A number of feature improvements are possible for the validator library:

1. Support for passive-mode operation 
The validator can be modified to allow both active and passive modes of operation.
In the first mode, the validator library actively looks for answers by sending
out queries needed to build the chain of trust. In the second mode of operation
the validator would only use the local cache while trying to build the chain-
of-trust 

2. Support for negative caches

3. Support for credibility level of data in the cache

4. Better handling of EDNS0 in provably insecure delegations 
   and EDNS0 failure handling. 

5. More robustness in the querying process -- falling back to other name servers 
when some error is encountered.

6. Improved support for a validator daemon: ability to specify ACLs for clients, 
   correctly setting the AD bit in the response.


Acknowledgements
----------------

Some of the code for this library was borrowed from an older implementation
of the secure resolver library written by Ed Lewis at Tislabs. 

