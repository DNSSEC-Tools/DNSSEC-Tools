<?xml version="1.0"  encoding='ISO-8859-1' standalone='no' ?>
<?rfc compact="yes" ?>
<?rfc editing="no" ?>
<?rfc toc="yes"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<rfc ipr="trust200811" docName="draft-hayatnagarkar-dnsext-validator-api-07">
  <front>
    <title> DNSSEC Validator API </title>

    <author initials="S." surname="Krishnaswamy"
            fullname="Suresh Krishnaswamy"> 
      <organization> SPARTA, Inc. </organization>
      <address>
        <postal>
          <street>7110 Samuel Morse Dr.</street>
          <city>Columbia</city>
          <region>MD</region>
          <code>21046</code>
          <country>US</country>
        </postal>
        <email>suresh AT sparta.com</email>
      </address>
    </author>
    <author initials="A." surname="Hayatnagarkar"
            fullname="Abhijit Hayatnagarkar"> 
      <organization> SPARTA, Inc. </organization>
      <address>
        <postal>
          <street>7110 Samuel Morse Dr.</street>
          <city>Columbia</city>
          <region>MD</region>
          <code>21046</code>
          <country>US</country>
        </postal>
      </address>
    </author>

    <date month="January" year="2009" />
    <workgroup> DNS Extensions </workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract> 
<t>The DNS Security Extensions (DNSSEC) provide origin authentication and
integrity of DNS data.  However, the current resolver Application Programming 
Interface (API) does not specify how a validating stub resolver 
should communicate detailed results of DNSSEC processing back to the application.  
This document describes an API between applications and a 
validating stub resolver that allows applications to control the 
DNSSEC validation process and obtain results of DNSSEC processing.</t>
    </abstract>
  </front>

  <middle>
  <section title="Introduction">
  <!--           ############## -->

<t>The DNS Security Extensions (<xref target="refs.RFC4033">RFC 4033</xref>,
<xref target="refs.RFC4034">RFC 4034</xref>, <xref target="refs.RFC4035">RFC 4035</xref>)
enable DNS resolvers to test the origin authenticity and integrity of data returned by the 
DNS.  A DNSSEC validator, or more formally, a validating stub resolver, 
is a piece of software that performs these tests by 
constructing an <xref target="refs.RFC4033">authentication chain</xref> 
from a locally configured DNSSEC <xref target="refs.RFC4033">trust anchor</xref>
to a cryptographic signature that covers the DNS information in question.
This document presents an API between an application and a DNSSEC validator, which 
enables applications to control the DNSSEC validation process and enables applications 
to obtain detailed DNSSEC validation results upon which to base program behavior. </t>

<t>The API can be broadly divided into three groups: the high-Level DNSSEC validator API, 
the low-Level DNSSEC validator API and the DNSSEC validator-context API. 
<xref target="high_level_api"/>, <xref target="low_level_api"/>,
and <xref target="val-context"/> describe these interfaces in greater detail. </t>

<t> The high-level DNSSEC validator API is designed for ease of use and mirrors 
existing DNS-related functions. This API is best suited for existing 
applications that use legacy DNS functions such as 
gethostbyname() and getaddrinfo() <xref target="refs.IEEE.1003.1-2004"/> and have no requirement 
for detailed DNSSEC validation status information. </t>

<t> The low-level DNSSEC validator API enables applications to examine the 
DNSSEC validation details for each element of the DNSSEC authentication chain. </t>

<t> The DNSSEC validator-context API enables applications 
to control the DNSSEC policies that are used for validating DNS responses.</t>

<t> The range of functions provided in this API supports different classes of 
applications, ranging from those that are only interested in basic DNSSEC results 
such as "validated" or "not-validated", to more sophisticated 
applications that can look for specific errors in an authentication 
chain as a sign of some abnormality or attack. </t>
  </section> <!-- Introduction -->


  <section title="Terminology">
  <!--            ############# -->

<t> Some of the terms used in this specification are defined below: 

  <list style="hanging">
    <t> </t>
    <t hangText="Legacy DNS Functions:"> 
functions, such as gethostbyname() and getaddrinfo(), that are 
not capable of returning DNSSEC validation status codes for DNS responses. </t>
    <t> </t>
    <t hangText="DNSSEC Validator Policy:"> 
a set of configuration parameters for the DNSSEC validator, which can influence 
the eventual outcome of the DNSSEC validation process. </t>
    <t> </t>
    <t hangText="DNSSEC Validator Context:">
the application's run-time handle to the DNSSEC validator policy.  </t>
  </list> </t>

  </section> <!-- Terminology -->

  <section title="High-level DNSSEC Validator API" anchor="high_level_api">
  <!--            ######################### -->

<t> The high-level DNSSEC validator API defines DNSSEC-aware substitutes for commonly
used legacy DNS functions. 
It provides an easy path for applications already using legacy DNS functions
to transition towards becoming DNSSEC-aware.  The high-level API also defines the 
val_get_rrset() function, which enables applications to obtain data for an 
arbitrary DNS name, class and type, and inspect the corresponding 
DNSSEC validation status values. </t>

<t> A number of resolver API functions exist; however, some of these functions 
(such as gethostbyname_r and gethostbyname2) are only available on a subset of Operating Systems and are not part of any official 
standard.  Also, some functions are defined only as minor extensions of other well-known resolver API functions.  
For example, gethostbyname2 differs from gethostbyname_r only by virtue of having the extra argument to explictly 
specify the address family. Further, some functions differ from others 
only by virtue of being able to support a re-entrant and thread-safe implementation. 
Instead of providing an exhaustive list of DNSSEC-capable replacement functions 
for all known resolver function calls, the high-level DNSSEC validator API in this document only 
describes DNSSEC extensions for the canonical set of function calls specified in <xref
target="refs.IEEE.1003.1-2004"/>. DNSSEC replacement functions for other legacy DNS functions are 
expected to mirror, to a large extent, other functions described in this document. </t> 

<t> The ctx parameter in the functions described in this API 
points to a DNSSEC validator context object (<xref target="val-context"/>). 
Applications MUST either supply a reference to a valid DNSSEC validator context object created 
using the functions specified in <xref target="val-context"/> or supply a NULL 
value for this parameter. Libraries that implement the DNSSEC Validator API 
MUST internally use a
DNSSEC validator context created with a default DNSSEC validator policy
when the application supplies a NULL value for ctx. </t> 

    <section title="val_gethostbyname, val_gethostbyaddr">
    <figure>
      <artwork>
#include &lt;validator/validator.h&gt;

struct hostent *val_gethostbyname( val_context_t *ctx,
                                   const char    *name,
                                   val_status_t  *val_status );

struct hostent *val_gethostbyaddr( val_context_t *ctx,
                                   const char    *addr,
                                   int            len,
                                   int            type,
                                   val_status_t  *val_status );
      </artwork>
      <postamble>
<t>The val_gethostbyname() and val_gethostbyaddr() functions are DNSSEC-aware versions of the 
gethostbyname() and gethostbyaddr() legacy DNS functions. 
The new functions have an additional parameter, val_status, 
which enables applications to check the DNSSEC validation status codes for
the address-to-name and name-to-address translations. The other arguments to these
functions have identical semantics to the corresponding legacy DNS functions as 
described in <xref target="refs.IEEE.1003.1-2004"/>. 
The val_gethostbyname() and val_gethostbyaddr() functions SHOULD 
only be used when retrofitting DNSSEC in existing applications that use the
gethostbyname() and gethostbyaddr() functions.
For new applications that need to perform these translations, 
the functions described in <xref target="hl_getaddrinfo"/> and <xref target="hl_getrrset"/>
SHOULD be used instead. </t>

<t> The DNSSEC validation status is returned in the val_status parameter.
When evaluating the validity of a DNS response, 
applications SHOULD use the functions described in <xref target="val-istrusted"/> 
instead of directly inspecting the DNSSEC validation status code returned in val_status.  </t>

<t> The status code returned in val_status is determined by the following rules. </t> 
<t/>
    <list style="symbols">
    <t> A DNSSEC validation status of VAL_OOB_ANSWER SHOULD be returned if the complete answer is returned 
using some out-of-band mechanism (for example, from a local configuration store such as /etc/hosts or its equivalent)
without any DNSSEC validation being performed. However, if local DNSSEC validator policy
defines out-of-band answers to be trustworthy, a DNSSEC validation status of VAL_TRUSTED_ANSWER
SHOULD be returned instead. </t>
    <t> A DNSSEC validation status of VAL_VALIDATED_ANSWER MUST be
returned if all resource record sets for the various addresses and canonical names within the
hostent structure are validated successfully. </t>
    <t> A DNSSEC validation status of VAL_TRUSTED_ANSWER MUST be
returned if at least one resource record set for the various addresses and 
canonical names within the hostent structure is not validated by the DNSSEC validation process, 
but all returned resource record sets are still considered trustworthy 
(<xref target="val-context"/>) by way of the configured local DNSSEC validator policy. </t>
    <t> A DNSSEC validation status of VAL_UNTRUSTED_ANSWER MUST be returned if at least one resource record set
for the various addresses and canonical names within the hostent structure is neither validated through the DNSSEC validation process nor considered to be trusted according to the configured local DNSSEC validator policy. </t>
    <t> A DNSSEC validation status of VAL_NONEXISTENT_NAME or VAL_NONEXISTENT_TYPE MUST 
be returned if the DNSSEC validation
process is able to prove non-existence for the name or type being queried for. A 
DNSSEC validation status of VAL_NONEXISTENT_NAME_NOCHAIN or VAL_NONEXISTENT_TYPE_NOCHAIN
MUST be returned if a DNS response with an RCODE reflecting 
type or name non-existence is returned, and local DNSSEC validator policy is configured 
to treat such answers as trustworthy. If the previous two conditions for non-existence are not satisfied, val_status
MUST be set to VAL_UNTRUSTED_ANSWER.</t>

    </list> 

      </postamble>
    </figure>
    </section>

    <section title="val_getaddrinfo, val_getnameinfo" anchor="hl_getaddrinfo">
    <figure>
      <artwork>
#include &lt;validator/validator.h&gt;

int val_getaddrinfo( val_context_t          *ctx, 
                     const char             *nodename,
                     const char             *servname,
                     const struct addrinfo  *hints,
                     struct addrinfo       **res ,
                     val_status_t           *val_status); 

int val_getnameinfo( val_context_t         *ctx, 
                     const struct sockaddr *sa,
                     socklen_t              salen,
                     char                  *host,
                     size_t                 hostlen,
                     char                  *serv,
                     size_t                 servlen,
                     int                    flags,
                     val_status_t          *val_status );

      </artwork>
      <postamble>
<t> These functions are DNSSEC-aware versions of the 
getaddrinfo() and getnameinfo() legacy DNS functions
(<xref target="refs.RFC3493"/>) respectively. 
The val_getaddrinfo() function returns the address and service
information for the specified domain name and service. The   
val_getnameinfo() function performs an address-to-name
translation in a protocol independent manner.  </t>

<t> The results from the val_getaddrinfo() function is returned in the res parameter. 
The value of res MUST point to a valid addrinfo structure (<xref target="refs.RFC3493"/>) 
on success or NULL in case of error.  Any library that implements the 
val_getaddrinfo() function MUST internally allocate sufficient memory to hold the linked list pointed to by res.
The caller MUST release this memory after use by invoking the freeaddrinfo() function 
(<xref target="refs.RFC3493"/>). </t>

<t> The DNSSEC validation status is returned in the val_status parameter.
For val_getaddrinfo(), this MUST represent the effective DNSSEC validation status code for
all answers returned in the addrinfo linked list. 
When evaluating the validity of a DNS response, applications SHOULD use the functions described in <xref target="val-istrusted"/> 
instead of directly inspecting the DNSSEC validation status code returned in val_status.  
The syntax and semantics of other parameters in 
val_getaddrinfo() and val_getnameinfo() are identical to those specified for 
getaddrinfo() and getnameinfo() in <xref target="refs.RFC3493"/>.  </t>

<t> The status code returned in val_status is determined by the following rules. </t> 
<t/>
    <list style="symbols">
    <t> A DNSSEC validation status of VAL_OOB_ANSWER SHOULD be returned in val_status 
if the complete answer is returned using some out-of-band mechanism (for example, 
from a local configuration store such as /etc/hosts or its equivalent) 
without any DNSSEC validation being performed. However, if local DNSSEC validator policy
defines out-of-band answers to be trustworthy, a DNSSEC validation status of VAL_TRUSTED_ANSWER 
SHOULD be returned instead. </t> 
    <t> For val_getnameinfo(), a DNSSEC validation status of VAL_VALIDATED_ANSWER or VAL_TRUSTED_ANSWER MUST
be returned in val_status if the returned response for the hostname is validated by the DNSSEC process
or is considered to be trustworthy through the local DNSSEC validator policy respectively. </t>
    <t> For val_getaddrinfo(), a DNSSEC validation status of VAL_VALIDATED_ANSWER MUST be
returned in val_status if all resource record sets for the various addresses and canonical names within the
returned addrinfo structure are validated through the DNSSEC process. </t>
    <t> For val_getaddrinfo(), a DNSSEC validation status of VAL_TRUSTED_ANSWER MUST be
returned in val_status if at least resource record set for the various addresses and canonical names 
within the returned addrinfo structure is not validated by the DNSSEC validation process, but all 
returned resource record sets are still considered to be trustworthy through the local DNSSEC validator policy (<xref target="val-context"/>). </t>
    <t> A DNSSEC validation status of VAL_UNTRUSTED_ANSWER MUST be returned if at least one resource record set
(for the various addresses and canonical names returned by val_getaddrinfo() within the addrinfo structure, or 
for the returned hostname in val_getnameinfo()) is neither validated through the DNSSEC process nor considered 
to be trustworthy according to the local DNSSEC validator policy. </t>
    <t> A DNSSEC validation status of VAL_NONEXISTENT_NAME or VAL_NONEXISTENT_TYPE MUST 
be returned in val_status if the DNSSEC validation
process is able to prove non-existence for the name or type being queried for. A 
DNSSEC validation status of VAL_NONEXISTENT_NAME_NOCHAIN or VAL_NONEXISTENT_TYPE_NOCHAIN 
MUST be returned if a DNS response with an RCODE reflecting 
type or name non-existence is returned, and local DNSSEC validator policy is configured 
to treat such answers as trustworthy (<xref target="val-context"/>). 
If the previous two conditions for non-existence are not satisfied, val_status
MUST be set to VAL_UNTRUSTED_ANSWER.</t>
    </list> 

      </postamble>
      </figure>
    </section>

    <section title="val_res_query">
      <figure>
      <artwork>
#include &lt;validator/validator.h&gt;

int val_res_query(val_context_t *ctx, 
                  const char    *domain_name, 
                  int            class, 
                  int            type,
                  u_char        *answer, 
                  int            anslen, 
                  val_status_t  *val_status);

      </artwork>
      <postamble>
<t> The val_res_query() function is a DNSSEC-aware replacement 
for the res_query() function (currently not documented in any standard reference).
The val_res_query() function queries the DNS 
for the data associated with the given domain name, class and type, 
and returns the result as a DNS-style response. </t>

<t> The val_res_query() function returns the actual size of the response packet on
success and -1 on failure.  On success, the response
from the DNS MUST be copied to the user-allocated buffer in answer and MUST NOT 
exceed the buffer size specified in anslen. 
The caller MUST check that the returned packet size is not greater than the 
length of the buffer provided in anslen.  If the returned size is greater, 
the caller SHOULD allocate a larger buffer in answer and call val_res_query() again. </t> 

<t> The DNSSEC validation status is returned in the val_status parameter.
When evaluating the validity of a DNS response, applications SHOULD use the functions described 
in <xref target="val-istrusted"/>
instead of directly inspecting the DNSSEC validation status code returned in val_status.
The validation status MUST correspond to the combined DNSSEC validation status 
code for all resource record sets returned in the response, and is determined by the following rules. </t>
<t/>
    <list style="symbols">
    <t> A DNSSEC validation status of VAL_VALIDATED_ANSWER MUST be
returned if all resource record sets returned in the answer
are validated by the DNSSEC validation process. </t> 
    <t> A DNSSEC validation status of VAL_TRUSTED_ANSWER MUST be
returned if at least one resource record set returned in the answer
is not validated by the DNSSEC validation process, but all resource record sets are still considered
to be trustworthy according to the configured local DNSSEC validator policy (<xref target="val-context"/>). </t> 
    <t> A DNSSEC validation status of VAL_UNTRUSTED_ANSWER MUST be returned if at least one resource record set in the
answer is neither validated through the DNSSEC validation process nor considered to be trustworthy according to the 
local DNSSEC validator policy. </t>
    <t> A DNSSEC validation status of VAL_NONEXISTENT_NAME or VAL_NONEXISTENT_TYPE
MUST be returned if the DNSSEC validation
process is able to prove non-existence for the name or type being queried for. 
A DNSSEC validation status of VAL_NONEXISTENT_NAME_NOCHAIN or VAL_NONEXISTENT_TYPE_NOCHAIN
MUST be returned if a DNS response with an RCODE reflecting
type or name non-existence is returned, and local DNSSEC validator policy is configured
to treat such answers as trustworthy.  If the previous two conditions for non-existence are not satisfied, val_status
MUST be set to VAL_UNTRUSTED_ANSWER.</t>
    </list> 

      </postamble>
      </figure>
    </section>

    <section title="val_get_rrset" anchor="hl_getrrset">
      <figure>
      <artwork>
#include &lt;validator/validator.h&gt;

int val_get_rrset(val_context_t            *ctx,
                  const char               *name,
                  int                       class,
                  int                       type,
                  u_int32_t                 flags,
                  struct val_answer_chain **answers);

void val_free_answer_chain(struct val_answer_chain *answers);
      
      </artwork>
      </figure>
    
<t> The val_get_rrset() function queries the DNS for the data associated with
the given domain name, class and type. The flags argument is currently unused
and SHOULD be set to 0. </t> 

<t> val_get_rrset() returns 0 on success and an error code from
<xref target="val-return-values"/> on failure. 
val_get_rrset() returns its results in the val_answer_chain structure. Memory for
the val_answer_chain structure MUST be
allocated internally by the function. The user MUST release
this memory after use using the val_free_answer_chain() function. </t>
 
<t> The val_answer_chain structure is defined below. </t>
      <figure>
      <artwork>
struct val_answer_chain {
      val_status_t             val_ans_status;
      char                    *val_ans_name;
      int                      val_ans_class;
      int                      val_ans_type;
      struct rr_rec           *val_ans;
      struct val_answer_chain *val_ans_next;
};

struct rr_rec {
      size_t         rr_length;
      u_char        *rr_data;
      struct rr_rec *rr_next;
};
      </artwork>
      </figure>

<t> val_ans_name MUST be set to the DNS name of the actual resource record set returned. 
This value may differ from the value passed as the argument to val_get_rrset() if the resource
record is returned after following a CNAME (<xref target="refs.RFC1034"/>) or DNAME 
(<xref target="refs.RFC2672"/>) alias.  val_ans_class and val_ans_type
MUST be set to the actual class and type for the returned resource record. These values
may differ from the values passed as arguments to val_get_rrset() if the query type or
class has the value 255 (ANY). The resource record sets are returned in val_ans as a linked list of 
rr_rec structures, with each element containing the rr_length and rr_data tuple
for a resource record in the resource record set. val_ans MUST be set to NULL if no
answer was returned for the given query or if a proof of non-existence was returned.  </t>

<t> The  DNSSEC validation status code is returned in the val_ans_status field.
This value MUST correspond to the consolidated validation status value 
for a resource record set, based on the
individual status codes for all components in an authentication chain.
Possible codes for val_ans_status are listed in <xref target="val-status"/>.
When evaluating the validity of a DNS response,
applications SHOULD use the functions described in <xref target="val-istrusted"/>
instead of directly inspecting the DNSSEC validation status code returned in
val_ans_status. </t>

    </section>

  </section> <!-- High-level DNSSEC Validator API -->

  <section title="Low-level DNSSEC Validator API" anchor="low_level_api">
  <!-- #################################### -->

<t> The low-level DNSSEC validator API provides applications with greater control and visibility 
into the DNSSEC validation process. The functions and data structures defined in the low-level 
DNSSEC validator API are summarized below. </t>

    <section title="val_resolve_and_check, val_free_result_chain">
      <figure>
      <artwork>
#include &lt;validator/validator.h&gt;

int val_resolve_and_check( val_context_t               *ctx, 
                           char                        *domain_name,
                           int                          class,
                           int                          type, 
                           u_int32_t                    flags,
                           struct val_result_chain    **results);

void val_free_result_chain( struct val_result_chain *results);

      </artwork>
      <postamble>
<t> The val_resolve_and_check() function queries the DNS 
for the &lt;domain_name, class, type&gt; tuple and then performs the
DNSSEC validation operation for the responses received. </t> 

<t> The flags argument specifies a list of options to the validation process, 
logically OR'd to each other. Only one flag is currently defined: 
<figure>
      <artwork>
#define VAL_QUERY_NO_AC_DETAIL 0x00000001
      </artwork>
      <postamble>
<t> If this flag is specified, details of the authentication chain MUST NOT be returned in 
the returned results. </t> 
      </postamble>
</figure> 
</t> 

<t> val_resolve_and_check() returns 0 on success and an error code from 
<xref target="val-return-values"/> on failure.  
Answers to the query is returned in results, which is a linked list 
of val_result_chain structures as defined below. The memory for results
MUST be allocated by val_resolve_and_check().  Applications MUST release the memory
allocated in results after use using the val_free_result_chain() function.</t>

<figure>
<artwork>

#define MAX_PROOFS 4
struct val_result_chain {
      val_status_t                     val_rc_status;
      char                            *val_rc_alias;
      struct val_rrset_rec            *val_rc_rrset;
      struct val_authentication_chain *val_rc_answer;
      int                              val_rc_proof_count;
      struct val_authentication_chain *val_rc_proofs[MAX_PROOFS];
      struct val_result_chain         *val_rc_next;
};

</artwork>
</figure>

<t> Each element in the val_rc_answer linked list MUST point 
to a distinct resource record set returned in the answer section. Any 
associated proofs of non-existence SHOULD be returned in in val_rc_proofs. 
val_rc_proof_count MUST be set to the
number of proof elements that are available.
 val_rc_answer and val_rc_proofs MUST both point to NULL if the 
 VAL_QUERY_NO_AC_DETAIL flag is specified in the flags argument for
 val_resolve_and_check(). </t> 

<t> Multiple resource record sets can be returned in a response when the 
query is for the type code of 255 (ANY) or 46 (RRSIG). 
val_rc_rrset MUST be set to NULL if val_rc_answer is NULL.
If val_rc_answer is not NULL, val_rc_rrset MUST point to the 
val_rrset_rec structure within the first element of the authentication 
chain pointed to by val_rc_answer. For all val_result_chain elements that 
represent a name alias, val_rc_alias MUST point to the target name referenced by that alias.
The val_rc_next field enables an application to iterate 
through the list of all results returned by the DNSSEC validator.  </t>

<t> The  DNSSEC validation status code is returned in the val_rc_status field.
This value MUST correspond to the consolidated validation status value 
for a resource record set, based on the
individual status codes for all components in an authentication chain.
Possible codes for val_rc_status  are listed in <xref target="val-status"/>. 
When evaluating the validity of a DNS response,
applications SHOULD use the functions described in <xref target="val-istrusted"/>
instead of directly inspecting the DNSSEC validation status code returned in
val_rc_status. </t>

<t> The val_authentication_chain structure represents a linked list 
whose elements comprise the DNSSEC authentication chain 
for an answer or proof of non-existence resource record set, and is further described below. </t> 

<figure>
<artwork>
struct val_authentication_chain {
    val_astatus_t                    val_ac_status;
    struct val_rrset_rec            *val_ac_rrset;
    struct val_authentication_chain *val_ac_trust;
};
</artwork>
</figure>

<t> The DNSSEC validation status for the specified resource record set MUST be set
in the val_ac_status field. Possible codes for 
this field are defined in <xref target="val-astatus"/>. The p_ac_status() function
defined in <xref target="val-astatus"/> enables an application to translate this code 
into a more user-friendly string representation.
The val_ac_trust field points to the next element in the authentication chain
proceeding from the signed record towards a DNSSEC trust anchor.
For an element with type DNSKEY, the next element MUST correspond to a DS record 
in the parent zone and for a DS record the next element MUST correspond to the 
DNSKEY in the same zone as the DS record. The value of val_ac_trust MUST be set to NULL for 
any of the following conditions: </t>

<t> <list style="symbols">
<t> the current element in the linked list points to a valid DNSSEC trust anchor </t> 
<t> an error condition is encountered </t>
<t> no authentication chain details are being returned. </t>
</list></t>

<t> The validation status code stored in the val_ac_status field can be 
used to differentiate between error conditions and the valid trust anchor condition.  </t>

<t> The val_ac_rrset field in the val_authentication_chain structure points to 
a val_rrset_rec structure, which holds the actual resource record set fields 
(<xref target="refs.RFC1034"/>) as described below. </t> 

<figure>
<artwork>
struct val_rrset_rec {
    int                 val_rrset_rcode;
    char                *val_rrset_name; 
    int                 val_rrset_class;
    int                 val_rrset_type;
    long                val_rrset_ttl; 
    int                 val_rrset_section;
    struct sockaddr     *val_rrset_server;
    struct val_rr_rec   *val_rrset_data;
    struct val_rr_rec   *val_rrset_sig;
};
</artwork>
</figure>

<t> The information stored in the val_rrset_rec structure includes 
data obtained from the DNS response header, including the DNS response error code 
in the val_rrset_rcode field, and the DNS response "envelope"
comprising of the name, class, type and time-to-live tuple in the 
val_rrset_name, val_rrset_class, val_rrset_type and val_rrset_ttl 
fields respectively. 
The name server from where this resource record set has been 
received is stored in the sockaddr data structure (<xref target="refs.IEEE.1003.1-2004"/>) 
pointed to by the val_rrset_server field.
The section where the resource record set appeared in the DNS response is saved in the 
val_rrset_section field within the val_rrset_rec structure, and MUST be set to one
of the following values: </t> 

        <t> <list style="hanging">
<t hangText="#define VAL_FROM_ANSWER     1">
/* if the resource record set was present in the answer section of the DNS response. */ </t> 
<t> </t>
<t hangText="#define VAL_FROM_AUTHORITY  2">
/* if the resource record set was present in the authority section of the DNS response. */ </t>
<t> </t>
<t hangText="#define VAL_FROM_ADDITIONAL 3">
/* if the resource record set was present in the additional section of the DNS response. */</t>
        </list></t>

<t> 
The data returned for the resource record set MUST be queued to val_rrset_data.  Any associated
RRSIGs MUST be queued to val_rrset_sig.  Both of these variables point to
lists of struct val_rr_rec elements, which specify the resource record data and the
DNSSEC validation status for each resource-record within the resource record set as defined below. </t>

<figure>
<artwork>
struct val_rr_rec {
    size_t               rr_rdata_length; 
    u_char              *rr_rdata;  
    struct val_rr_rec   *rr_next;
    val_astatus_t        rr_status;      
};
</artwork>
</figure>

<t> The rr_status member in val_rr_rec is only relevant for the signatures present in
val_rrset_sig or when val_rrset_data points to DNSKEY or DS resource records. In other
cases the value of this field MUST be set to VAL_AC_UNSET. 
The rr_status field takes on a subset of all status codes possible for the 
val_astatus_t type and is further described in <xref target="val-astatus"/>.  </t>

      </postamble>
      </figure>
    </section>

    <section title="Authentication Chain Status Codes and p_ac_status()" anchor="val-astatus">

        <t> For each authentication chain element in the val_authentication_chain structure, the 
        val_ac_status field can contain one of the following codes:
        <list style="hanging">
<t> </t>
<t hangText="VAL_AC_UNSET:">
DNSSEC validation for the given resource record set could not be attempted 
for any reason.  </t>
<t> </t>
<t hangText="VAL_AC_IGNORE_VALIDATION:">
DNSSEC validation for the given resource record set was ignored on
the basis of some configured DNSSEC validator policy. </t>
<t> </t>
<t hangText="VAL_AC_UNTRUSTED_ZONE:">
The resource record set belonged to a zone that the 
DNSSEC validator considered to be 
un-trusted, with no further DNSSEC validation              
being deemed necessary.  </t>
<t> </t>
<t hangText="VAL_AC_PINSECURE:">
The resource record set belonged to a zone for which the DS record
was provably absent. </t>
<t> </t>
<t hangText="VAL_AC_BARE_RRSIG:">
The resource record set contained only RRSIGs (in response to a query of type
RRSIG). RRSIGs contain the cryptographic
signatures for other DNS data and cannot themselves be validated.  </t>
<t> </t>
<t hangText="VAL_AC_NO_TRUST_ANCHOR:">
No DNSSEC trust anchor was configured at or above the level of the 
zone for the given resource record set, therefore no
validation could be performed. </t> 
<t> </t>
<t hangText="VAL_AC_TRUST:">
At least one of the signatures covering the given
resource record set was directly verified using a key that was 
configured as a DNSSEC trust anchor.  </t>
<t> </t>
<t hangText="VAL_AC_RRSIG_MISSING:">
RRSIG data for the given resource record set could not be located.  </t>
<t> </t>
<t hangText="VAL_AC_DNSKEY_MISSING:">
The DNSKEY data that generated
signatures for the given resource record set could not be located. </t>
<t> </t>
<t hangText="VAL_AC_DS_MISSING:">
The DS data for the DNSKEY resource record set 
in question could not be located. </t>
<t> </t>
<t hangText="VAL_AC_DATA_MISSING:">
The returned resource record set was empty. </t>
<t> </t>
<t hangText="VAL_AC_DNS_ERROR:">
A DNS error was encountered during the query resolution process.  </t>
<t> </t>
<t hangText="VAL_AC_NOT_VERIFIED:">
None of the RRSIGs covering the given resource record set could be verified.  </t>
<t> </t>
<t hangText="VAL_AC_VERIFIED:">
At least one RRSIG covering the resource record set verified successfully.  </t>
      </list> </t>

      <t>  For each signature val_rr_rec member within an authentication chain 
pointed to by val_ac_rrset, the DNSSEC validation status stored in the variable rr_status can 
be set to one of the following codes: 
        <list style="hanging">
<t> </t>
<t hangText="VAL_AC_UNSET:">
No DNSSEC validation status information could be obtained for the given signature.  </t>
<t> </t>
<t hangText="VAL_AC_RRSIG_VERIFIED:">
The RRSIG verified successfully.  </t>
<t> </t>
<t hangText="VAL_AC_WCARD_VERIFIED:">
The RRSIG covering a resource record 
proved that the record was wildcard expanded.  </t>
<t> </t>
<t hangText="VAL_AC_RRSIG_VERIFIED_SKEW:">
The RRSIG verified successfully only after clock skew 
was taken into consideration.  </t>
<t> </t>
<t hangText="VAL_AC_WCARD_VERIFIED_SKEW:">
The RRSIG covering a resource record 
proved that the record was wildcard expanded, 
but only after clock skew was taken
into consideration.  </t>
<t> </t>
<t hangText="VAL_AC_WRONG_LABEL_COUNT:">
The number of labels on the signature was greater 
than the count given in the RRSIG resource record data.  </t>
<t> </t>
<t hangText="VAL_AC_INVALID_RRSIG:">
The RRSIG could not be parsed.  </t>
<t> </t>
<t hangText="VAL_AC_RRSIG_NOTYETACTIVE:">
The RRSIG's inception time was in the future.  </t>
<t> </t>
<t hangText="VAL_AC_RRSIG_EXPIRED:">
The RRSIG's expiration time was in the past.  </t>
<t> </t>
<t hangText="VAL_AC_ALGORITHM_NOT_SUPPORTED:">
The RRSIG algorithm was not supported.  </t>
<t> </t>
<t hangText="VAL_AC_RRSIG_VERIFY_FAILED:">
The RRSIG could not be verified.  </t>
<t> </t>
<t hangText="VAL_AC_RRSIG_ALGORITHM_MISMATCH:">
The keytag referenced in the RRSIG matched a DNSKEY 
but the algorithms were different. </t>
<t> </t>
<t hangText="VAL_AC_DNSKEY_NOMATCH:">
The DNSKEY that created the given signature 
could not be found in the zone DNSKEY resource record set. </t>
      </list> </t>

      <t>  For each val_rr_rec member of type DNSKEY (or DS where indicated) 
within an authentication chain structure pointed to by val_ac_rrset, the DNSSEC validation status 
stored in the variable rr_status can be set to one of the following codes: 
        <list style="hanging">
<t> </t>
<t hangText="VAL_AC_UNSET:">
No DNSSEC validation status information could be obtained for the given DNSKEY or DS record.  </t>
<t> </t>
<t hangText="VAL_AC_TRUST_POINT:">
The given DNSKEY or DS record was configured as a DNSSEC trust anchor.  </t>
<t> </t>
<t hangText="VAL_AC_SIGNING_KEY:">
The given DNSKEY was used for generating an RRSIG for a resource record in the authentication chain.  </t>
<t> </t>
<t hangText="VAL_AC_VERIFIED_LINK:">
The given DNSKEY or DS resource record provided the link in the authentication chain from 
a DNSSEC trust anchor to the signed record.  </t>
<t> </t>
<t hangText="VAL_AC_UNKNOWN_ALGORITHM_LINK:">
The DNSKEY chained up to a DS record but the DNSKEY algorithm was unknown.  </t>
<t> </t>
<t hangText="VAL_AC_UNKNOWN_DNSKEY_PROTOCOL:">
The DNSKEY protocol number was unknown.  </t>
<t> </t>
<t hangText="VAL_AC_ALGORITHM_NOT_SUPPORTED:">
The DNSKEY or DS algorithm was not supported.  </t>
<t> </t>
<t hangText="VAL_AC_DS_NOMATCH:">
The given DNSKEY did not chain up to any DS record in the parent zone.  </t>
<t> </t>
<t hangText="VAL_AC_INVALID_KEY:">
The given DNSKEY was invalid.  </t>
      </list> </t>

    <t> The numerical values for the codes listed above are implementation-specific. 
    The DNSSEC validation status code stored in struct val_authentication_chain  
can be converted to a string representation using the p_ac_status() function. </t>
<figure>
<artwork>
    #include &lt;validator/validator.h&gt;

    const char *p_ac_status(val_astatus_t status);
</artwork>
</figure>
<postamble>
The value returned SHOULD be the string conversion for the corresponding val_astatus_t identifier. For example, 
p_ac_status(VAL_AC_VERIFIED) SHOULD return "VAL_AC_VERIFIED". 
</postamble> 
    </section>

  </section> <!-- Low-level API -->

  <section title="DNSSEC Validator Context API" anchor="val-context">
  <!--            ####################### -->

<t> DNSSEC validator policy can be used to influence the DNSSEC validation outcome. 
Examples of DNSSEC validator policy include DNSSEC trust anchors for 
different zones and acceptable clock-skew values for checking 
inception and expiration times on signatures from different zones.
DNSSEC validator policy MAY be configured differently for different 
applications and operating scenarios. </t> 

<t> DNSSEC validator policy is stored in the local 
system configuration (for example, the configuration file /etc/dnsval.conf).  
Policies are identified by simple text strings called labels, which MUST be 
unique within the system configuration. As an example, "browser" could be used 
as the label that defines the DNSSEC validator policy for all web-browsers in a
system. The label for the validation policy that is to be used for an
application MAY be supplied during application-startup through the environment variable, VAL_CONTEXT_LABEL.</t> 


<t> DNSSEC validator policy definitions in the system configuration are implementation-specific.
A possible definition is described in <xref target="pol-config"/>.  </t>

    <section title="val_create_context, val_free_context">
      <figure>
      <artwork>
#include &lt;validator/validator.h&gt;

int val_create_context( char *scope,
                        val_context_t **newctx );

void val_free_context( val_context_t *ctx );
      </artwork>
      <postamble>
<t> An application maintains a run-time handle to its validator policy 
through the validator context. </t>

<t> val_create_context() creates a new DNSSEC validator context.
The scope parameter identifies the DNSSEC validator policy to be used 
by the application for DNSSEC validation.  

The manner in which the scope argument is used within the system configuration to
identify specific validator policy settings is implementation-specific.

Any library that implements this API MUST internally create a 
DNSSEC validator context with a default DNSSEC validator policy if scope is NULL. </t>

<t>The val_create_context() function returns 0 on success, 
and an error code from <xref target="val-return-values"/> on failure. 
The newly created DNSSEC validator context is returned in the newctx field.
A NULL DNSSEC validator context MUST be returned if an error is encountered.  
The memory allocated for the DNSSEC validator context 
after a successful call to val_create_context() 
MUST be released after use by the application using the val_free_context() function. </t> 

    </postamble>
    </figure>
    </section>

    <section title="val_add_valpolicy, val_remove_valpolicy">
    <figure>
    <artwork>
#include &lt;validator.h&gt;

int val_add_valpolicy(  val_context_t       *context, 
                        void *policy_definition,
                        val_policy_entry_t **pol);

int val_remove_valpolicy(val_context_t      *context, 
                         val_policy_entry_t *pol);
    </artwork>
    <postamble>
<t>The val_add_valpolicy() function allows an application to add a new DNSSEC
validator policy definition to an existing DNSSEC validator context. 
The newly added policy MUST only be associated with the current DNSSEC 
validator context and MUST NOT be stored persistently in the system 
configuration. The policy_definition field points to a policy definition 
structure and is implementation-specific. A timeout MAY be attached to 
the DNSSEC validator policy as part of the policy_definition structure
such that after the timeout interval, the effects of the newly added DNSSEC 
validator policy is ignored. A handle to the newly 
added DNSSEC validator policy MUST be returned in *pol, which is a pointer to
the val_policy_entry_t structure.  This structure is opaque to applications and
applications MUST NOT modify its contents. </t>

<t> Applications can revoke the effects of a newly added DNSSEC validator
policy before the expiry of its timeout interval using the 
val_remove_valpolicy() function. The DNSSEC validator policy 
that is to be removed from the DNSSEC validator context is identified by its
handle, pol. </t>

<t> The above functions return 0 on success and an error code from 
<xref target="val-return-values"/> on failure.  </t>
    </postamble>
    </figure>
    </section>

  </section> <!-- DNSSEC Validator Context API -->
    
  <section title="Function Return Codes and p_val_err()" anchor="val-return-values">
    <!--            ####################### -->

<t> The following codes can be returned by functions defined in the low-level API, 
DNSSEC validator-context API, and by the  val_get_rrset() function defined
in the high-level API. Other high-level API functions mirror existing 
legacy DNS functions, so the return codes from these functions are
identical to their predecessors. The numerical values for the return codes listed below 
are implementation-specific.</t>

        <t> <list style="hanging">
<t hangText="VAL_NO_ERROR:">
The function call was successful.  </t>
<t> </t>
<t hangText="VAL_NOT_IMPLEMENTED:">
The implementation did not support a particular feature.  </t>
<t> </t>
<t hangText="VAL_RESOURCE_UNAVAILABLE:">
Some resource necessary for an operation (such as memory) was unavailable.  </t>
<t> </t>
<t hangText="VAL_BAD_ARGUMENT:">
An unexpected value was passed as an argument to a function.  </t>
<t> </t>
<t hangText="VAL_INTERNAL_ERROR:">
An internal error was encountered by the DNSSEC validator.  </t>
<t> </t>
<t hangText="VAL_CONF_PARSE_ERROR:">
The DNSSEC validator configuration was improperly specified in the 
system configuration.  </t>
<t> </t>
<t hangText="VAL_CONF_NOT_FOUND:">
The DNSSEC validator configuration could not be located in the 
system configuration.  </t>
<t> </t>
<t hangText="VAL_NO_POLICY:">
The DNSSEC validator policy identifier being referenced was invalid. </t>
        </list></t>

<t> The error codes listed above can be converted to a string representation
using the p_val_err() function. </t> 
<figure>
    <artwork>
#include &lt;validator/validator.h&gt;

const char *p_val_err(int err);
    </artwork>
    <postamble>
<t> The returned value from p_val_err() SHOULD be the string 
conversion for the corresponding error code identifier. For example, 
p_val_err(VAL_NO_ERROR) SHOULD return "VAL_NO_ERROR". </t>
    </postamble>
</figure>

  </section> <!-- Return Values -->

  <section title="Evaluating Response Validity">
  <!--         ############################### -->

    <t> The result of DNSSEC validation for a resource record set, based on the individual 
status code of each element in an authentication chain, is returned in a variable of 
type val_status_t. val_status_t can contain one of possible codes
listed in <xref target="val-status"/>. 
The functions provided in <xref target="val-istrusted"/> simplify the
task of evaluating validity of an answer by wrapping around the different 
status codes possible for each type of answer.</t>

    <section title="DNSSEC Validation Status Codes and p_val_status()" anchor="val-status">
        <t> A variable of type val_status_t can contain one of the following codes (the numerical values
            for these codes are implementation-specific): </t>

        <t> <list style="hanging">
<t hangText="VAL_VALIDATED_ANSWER:">
Returned if the combined DNSSEC validation status for a set of resource record set responses represents a validated
state.</t>
<t> </t>
<t hangText="VAL_TRUSTED_ANSWER:">
Returned if the combined DNSSEC validation status for a set of resource record set responses represents a trusted (but
non-validated) state.</t>
<t> </t>
<t hangText="VAL_UNTRUSTED_ANSWER:">
Returned if the combined DNSSEC validation status for a set of resource record set responses represents an untrusted 
state.</t>
<t> </t>
<t hangText="VAL_SUCCESS:">
The response for the given resource record set was successfully validated through the DNSSEC validation process.  </t>
<t> </t>
<t hangText="VAL_NONEXISTENT_NAME:">
The proof for denial of existence for a domain name
validated successfully.  </t>
<t> </t>
<t hangText="VAL_NONEXISTENT_TYPE:">
The proof for denial of existence for the resource record type for the
given name was validated successfully.  </t>
<t> </t>
<t hangText="VAL_NONEXISTENT_NAME_NOCHAIN:">
The proof for non-existence of a domain name
was considered valid through local DNSSEC validator configuration; 
the authentication chain(s) for the different 
components of the proof were not validated. </t> 
<t> </t>
<t hangText="VAL_NONEXISTENT_TYPE_NOCHAIN:">
The proof for non-existence of the resource record type for the
name queried was considered valid through local DNSSEC validator configuration; 
the authentication chain(s) for the different 
components of the proof were not validated.  </t>
<t> </t>
<t hangText="VAL_PINSECURE:">
The record or some ancestor of the record in the authentication chain 
towards a DNSSEC trust anchor was known to be provably insecure and 
DNSSEC validator policy is configured to trust provably insecure answers. </t>
<t> </t>
<t hangText="VAL_PINSECURE_UNTRUSTED:">
The record or some ancestor of the record in the authentication chain 
towards a DNSSEC trust anchor was known to be provably insecure, 
but DNSSEC validator policy is configured to not trust provably insecure answers. </t> 
<t> </t>
<t hangText="VAL_BARE_RRSIG:">
The response was for a query of type RRSIG. RRSIGs contain the cryptographic
signatures for other DNS data and cannot themselves be validated.  </t>
<t> </t>
<t hangText="VAL_IGNORE_VALIDATION:">
DNSSEC validator policy was configured 
to ignore DNSSEC validation for the zone from where this
data was received. </t>
<t> </t>
<t hangText="VAL_UNTRUSTED_ZONE:">
DNSSEC validator policy was configured to not trust
any response from the zone that this data was received from.  </t>
<t> </t>
<t hangText="VAL_OOB_ANSWER:">
The response was obtained using some out-of-band mechanism (for example, 
from a local configuration store such as /etc/hosts). </t> 
<t> </t>
<t hangText="VAL_BOGUS:">
The response could not be validated due to signature verification 
failures or the inability to verify proofs of non-existence for one or more 
components in the authentication chain.  </t>
<t> </t>
<t hangText="VAL_DNS_ERROR:">
Returned if a DNS error was encountered during the query resolution process.  </t>
<t> </t>
<t hangText="VAL_NOTRUST:">
The authentication chain does not lead up to a configured DNSSEC trust anchor. </t> 
        </list> </t>

    <t> The DNSSEC validation status code stored in a variable of type 
 val_status_t can be converted to a string representation using the p_val_status() function.  </t>
<figure>
<artwork>
#include &lt;validator/validator.h&gt;

const char *p_val_status(val_status_t status);
</artwork>
<postamble>
<t> The value returned SHOULD be the string conversion
for the corresponding val_status_t identifier. For example, p_val_status(VAL_SUCCESS) SHOULD return
"VAL_SUCCESS". </t> 
</postamble>
</figure>

    </section> <!-- List of DNSSEC Validation Status Codes -->

    <section title="High-Level Routines for Evaluating Validity" anchor="val-istrusted">
      <figure>
      <artwork>
#include &lt;validator/validator.h&gt;

int val_istrusted(val_status_t status);

int val_isvalidated(val_status_t status);

int val_does_not_exist(val_status_t status);
      </artwork>
      <postamble>

    <t> Most applications will be interested in a single value
 that represents the validity of DNS data. In some instances an
application may also need to distinguish between cases where the 
answer was cryptographically validated and cases where the answer
was locally trusted.  The val_istrusted() and val_isvalidated()
functions allow an application to evaluate, at a high level, the validity of a 
response without having to inspect the exact status code returned. 
</t> 

      <t> The val_istrusted() function returns a single integer value 
representing the validity of information returned by
the DNSSEC validator. The return value MUST be greater than 0 if 
status is one of VAL_SUCCESS, VAL_NONEXISTENT_NAME, VAL_NONEXISTENT_TYPE,
VAL_NONEXISTENT_NAME_NOCHAIN, VAL_NONEXISTENT_TYPE_NOCHAIN,
VAL_PINSECURE, VAL_IGNORE_VALIDATION, VAL_TRUSTED_ANSWER, or VAL_VALIDATED_ANSWER 
and MUST be equal to 0 for other status codes.  </t>

      <t> The val_isvalidated() function returns a single integer value
that indicates if the answer cryptographically chains down from a configured 
DNSSEC trust anchor.  The return value MUST be greater than 0 if 
status is one of VAL_SUCCESS, VAL_NONEXISTENT_NAME, VAL_NONEXISTENT_TYPE, or VAL_VALIDATED_ANSWER
and MUST be equal to 0 for other status codes.  </t>

      <t> The val_does_not_exist() function
allows an application to determine from the DNSSEC validation status value if the answer was
provably non-existent. In combination with the val_istrusted() and val_isvalidated() functions,
it can give an indication about the manner in which validity was determined (cryptographically 
verified or locally trusted by the DNSSEC validator).
The return value from val_does_not_exist() MUST be greater than 0 if status is one of VAL_NONEXISTENT_TYPE,
VAL_NONEXISTENT_NAME, VAL_NONEXISTENT_NAME_NOCHAIN, or VAL_NONEXISTENT_TYPE_NOCHAIN and
MUST be equal to 0 for other status codes. </t>

      </postamble>
      </figure>
    </section>

  </section>
  
  <section title="Notes On DNS Data Caching By Appplications">

  <t> Certain applications are known to cache DNS data for an application-specific 
 length of time, independent of the TTL limits placed on the relevant DNS resource records. 
 Since DNS data is ephemeral by design, any caching performed independently by an 
 application could violate the data publisher's intent of wanting to modify
 the DNS data within the duration that the application has this data cached. An extension to this
 problem is the scenario where an application caches DNS data for an application-specific length of time
 during which period a zone operator may revoke a DNSSEC key, thus rendering that  
 particular cached data as untrustworthy. </t>

 <t> It is recommended that applications MUST NOT cache DNS data in a manner 
 that would violate the TTL limits placed on DNS records. The proper behavior for applications 
 is to delegate the function of caching DNS data to a stub resolver or 
 a local recursive resolver library, and to only use DNS API functions to request answers 
 whenever necessary. The stub or recursive resolver libraries should, in turn, determine 
 if a cached answer is available or if a fresh DNS query is to be issued. </t> 

  </section>

  <section title="IANA Considerations">
  <t> This document has no actions for IANA.</t>
  </section> <!-- IANA Considerations -->

  <section title="Security Considerations" anchor="security-considerations">
<t> In certain cases DNS responses may be returned from the local 
system configuration (for example, from the /etc/hosts file on some systems).  The
application cannot assume that these answers are valid, unless the
application is certain that the local configuration store contains valid data.
If this information is modified during a DHCP lookup, for example, the client
system should ensure that the DHCP server is a trusted source, and that the
communication path between the DHCP server and the client system is secured. 
 If these conditions are not satisfied and if the application chooses to trust
a locally available answer, an attaker may be able to poison the system
configuration and cause an application to use invalid answers. If applications are
to treat out-of-band answers as trusted, this choice SHOULD be made explicit 
through a validator policy configuration knob.</t>

<t> Applications can similarly choose to trust data from provably insecure zones.
Not performing DNSSEC validation for a zone that has DNSSEC intentionally turned 
off is no worse than the current situation of DNSSEC-unaware applications not being 
able to detect the integrity of DNS data for such zones. </t>

<t> The DNS search path may affect the result of DNSSEC validation, especially in
the current Internet environment where not all DNS name servers are
expected to be DNSSEC-aware.  If the name server pointed to by the system configuration 
is not DNSSEC-aware (i.e. it does not return DNSSEC records), DNSSEC validation will not 
be performed. </t>

<t> The DNSSEC validator configuration information needs to be protected 
so that it cannot be overwritten by unauthorized users or processes. 
The system administrator must ensure that the list of DNSSEC trust anchors is kept
accurate and up-to-date.  If the DNSSEC trust anchors are outdated (in the event of key-rollovers),
the DNSSEC validator may either not be able to perform DNSSEC validation or may 
operate with the false belief of having validated a response when 
the response should really have been flagged as bogus.  Any subversion of the DNSSEC policy configuration
(including definition of new trust anchors) can similarly completely undermine the value of DNSSEC.
</t>
  </section> <!-- Security Considerations -->

  <section title="Acknowledgements">
  <t>A number of individuals have provided
valuable feedback and suggestions for improving this document including the 
following: Lindy Foster, Wayne Morrison, Russ Mundy, Bill Sommerfeld, 
Robert Story, Wes Hardaker, Giovanni Marzot and Alfred Hoenes.  
The list of authentication status codes in <xref target="val-astatus"/> was 
generated through multiple brainstorming sessions at various IETF meetings; 
this draft draws on the results from that effort.</t>
  </section> <!-- Acknowledgements -->

  </middle>
  <back>
        <references title="Normative References">
            <reference anchor="refs.IEEE.1003.1-2004">
              <front>
                <title>IEEE Std 1003.1-2004 Standard for Information Technology 
                -- Portable Operating System Interface (POSIX). Open Group
                Technical Standard: Base Specifications, Issue 6</title>
                <author>
                    <organization> IEEE and The Open Group, http://www.opengroup.org </organization>
                </author> 
                <date month="February" year="2004" />
              </front>
              <seriesInfo name="ISO/IEC" value="9945:2003" />
            </reference>
            <reference anchor="refs.RFC3493">
              <front>
                <title>Basic Socket Interface Extensions for IPv6</title>
                <author initials="R." surname="Gilligan" fullname="Bob Gilligan" />
                <author initials="S." surname="Thomson" fullname="Susan Thomson" />
                <author initials="J." surname="Bound" fullname="Jim Bound" />
                <author initials="J." surname="McCann" fullname="Jack McCann" />
                <author initials="W." surname="Stevens" fullname="W. Richard Stevens" />
                <date month="February" year="2003" />
              </front>
              <seriesInfo name="RFC" value="3493" />
            </reference>
            <reference anchor="refs.RFC4034">
              <front>
                <title>Resource Records for the DNS Security Extensions</title>
                <author initials="R." surname="Arends" fullname="Roy Arends" />
                <author initials="R." surname="Austein" fullname="Rob Austein" />
                <author initials="M." surname="Larson" fullname="Matt Larson" />
                <author initials="D." surname="Massey" fullname="Dan Massey" />
                <author initials="S." surname="Rose" fullname="Scott Rose" />
                <date month="March" year="2005" />
              </front>
              <seriesInfo name="RFC" value="4034" />
            </reference>
            <reference anchor="refs.RFC4035">
              <front>
                <title>Protocol Modifications for the DNS Security Extensions</title>
                <author initials="R." surname="Arends" fullname="Roy Arends" />
                <author initials="R." surname="Austein" fullname="Rob Austein" />
                <author initials="M." surname="Larson" fullname="Matt Larson" />
                <author initials="D." surname="Massey" fullname="Dan Massey" />
                <author initials="S." surname="Rose" fullname="Scott Rose" />
                <date month="March" year="2005" />
              </front>
              <seriesInfo name="RFC" value="4035" />
            </reference>
        </references>
        <references title="Informative References">
            <reference anchor="refs.RFC1034">
              <front>
                <title>Domain Names - Concepts and Facilities</title>
                <author initials="P." surname="Mockapetris" fullname="Paul Mockapetris" />
                <date month="November" year="1987" />
              </front>
              <seriesInfo name="RFC" value="1034" />
            </reference>
            <reference anchor="refs.RFC2672">
              <front>
                <title>Non-Terminal DNS Name Redirection</title>
                <author initials="M." surname="Crawford" />
                <date month="August" year="1999" />
              </front>
              <seriesInfo name="RFC" value="2672" />
            </reference>
            <reference anchor="refs.RFC4033">
              <front>
                <title>DNS Security Introduction and Requirements</title>
                <author initials="R." surname="Arends" fullname="Roy Arends" />
                <author initials="R." surname="Austein" fullname="Rob Austein" />
                <author initials="M." surname="Larson" fullname="Matt Larson" />
                <author initials="D." surname="Massey" fullname="Dan Massey" />
                <author initials="S." surname="Rose" fullname="Scott Rose" />
                <date month="March" year="2005" />
              </front>
              <seriesInfo name="RFC" value="4033" />
            </reference>
        </references>
        <!-- Appendices
        <section ...>
        <section ...>
        -->
        <section title="DNSSEC Validator Policy" anchor="pol-config">
<t> DNSSEC validator policy definitions in the system
configuration are implementation-specific. The
system MAY be implemented using
hierarchical representation for the scope
parameter in val_create_context(), with each element in the hierarchy identifying 
a different DNSSEC validator policy label in the system configuration. 
Each policy label within the scope parameter is separated by the ':' character. 
The DNSSEC validator creates an effective DNSSEC validator policy for the current
DNSSEC validator context by cumulatively applying the policies for each label
specified in the scope parameter. </t> 

<t> A label value of ":" for a DNSSEC validator policy in the system
configuration identifies the default DNSSEC validator policy.
The ":" DNSSEC policy label, as with other DNSSEC policy labels in the system configuration, 
MUST be unique within the system configuration.
Furthermore, the ':' character MUST only be present in the default DNSSEC validator policy label.
The system configuration MUST flag an error if some other DNSSEC policy label contains the 
':' character. </t> 

<t> When adopting this approach for constructing a validator
context from a given policy scope,
the DNSSEC validator policy identified by the ":" label 
MUST always be applied first. For example, for the DNSSEC validator policy scope 
"mozilla:browser", the effective DNSSEC validator policy for a DNSSEC validator context is 
computed by applying policies for the ":", "browser" and "mozilla" policies, in that order. </t>

<t> A DNSSEC policy attribute may be defined as one of the DNSSEC validator's configurable p
arameters that, when combined with other policy attributes, forms the validator policy.
The following validator policy attributes MAY be defined: </t> 

        <section title="Zone-Specific Validator Policy Settings">
<t> Zone-specific validator policy settings MAY have the following structure.  </t> 
<t> &lt;label&gt; &lt;attribute&gt; &lt;additional-data&gt;; </t>
<t> Sample values for &lt;attribute&gt; are "trust-anchor",
"zone-security-expectation", "provably-insecure-status",
"clock-skew".  The value for &lt;additional-data&gt; 
will depend on the type of attribute specified.  </t>

<t><list style="symbols">
<t>For the "trust-anchor" attribute additional-data SHOULD be a sequence of 
ordered pairs, each consisting of the zone name and a quoted
string containing the resource record data for the 
trust anchor's DNSKEY. An example is given below. 
    <figure>
    <artwork>
    browser trust-anchor 
        example.com   "257 3 5 AQO8XS4y9r77X 9SHBmrx MoJf1Pf9\
            AT9Mr/L5BBGtO9/e9f/zl4FFgM2l B6M2 XEm6mp6 mit4tzp\
            B/sAEQw1McYz6bJdKkTiqtuWTCfDmgQhI6 /Ha0 Ef GPNSqn\
            Y 99FmbSeWNIRaa4fgSCVFhvbrYq1nXkNVy QPeEVHk oDNCA\
            lr qOA3lw==" 
        example.org   "257 3 5 AQO8XS4y9r77X 9SHBmrx MoJf1Pf9\
            AT9Mr/L5BBGtO9/e9f/zl4FFgM2l B6M2 XEm6mp6 mit4tzp\
            B/sAEQw1McYz6bJdKkTiqtuWTCfDmgQhI6 /Ha0 Ef GPNSqn\
            Y 99FmbSeWNIRaa4fgSCVFhvbrYq1nXkNVy QPeEVHk oDNCA\
            lr qOA3lw==" 
        ;
    </artwork>
    <postamble>
    </postamble>
    </figure>
</t>
</list> </t>

<t><list style="symbols">
<t>For the "zone-security-expectation" attribute additional-data 
SHOULD be a sequence of  &lt;domain name,value&gt; tuples representing the 
security expectation for names in that domain, where value can be one of the following:
        <list style="hanging">
            <t></t>
            <t hangText="ignore:">
            Ignore DNSSEC validation for names under this domain.  </t>
            <t hangText="validate:">
            Perform DNSSEC validation of answers received for names under this domain.  </t>
            <t hangText="untrusted:">
            Reject all answers received for names under this domain.  </t>
            <t></t>
        </list> 
This zone-security-expectation DNSSEC validator policy construct makes it possible to define 
various islands of trust for DNSSEC-enabled zones and to 
ignore or trust data from selected zones. The default zone
security expectation for a domain SHOULD be "validate".
In the following example, for DNSSEC validator contexts created with a DNSSEC validator policy label of "browser",
the DNSSEC validation is only performed for names 
under the example.com domain; names under the somebogusdomain.org domain are always
considered to be untrusted and DNSSEC validation for all other domain names is ignored. 
    <figure>
    <artwork>
    browser zone-security-expectation           
        example.com  validate       
        somebogusdomain.org untrusted 
        . ignore
        ; 
    </artwork>
    <postamble>
    </postamble>
    </figure>
</t> 
</list> </t> 

<t><list style="symbols">
<t>
For the "provably-insecure-status" attribute additional-data SHOULD be a sequence 
of  &lt;domain name,value&gt; tuples representing the validity of the 
provably insecure condition, where value SHOULD be one of the following: 
        <list style="hanging">
            <t></t>
            <t hangText="trusted:">
            Treat the provably insecure condition as valid.  </t>
            <t hangText="untrusted:">
            Treat the provably insecure condition as invalid.  </t>
            <t></t>
        </list> 
The default value for the provably insecure status for a domain SHOULD be "trusted".
In the following example, for DNSSEC validator contexts created with the default label, 
the provably insecure condition is treated as trustworthy for all domains except the net domain, 
where this condition is treated as invalid.
    <figure>
    <artwork>
    : provably-insecure-status
        . trusted
        net untrusted
        ;
    </artwork>
    <postamble>
    </postamble>
    </figure>
</t>
</list> </t> 

<t><list style="symbols">
<t>
For the "clock-skew" attribute additional-data SHOULD be a sequence of the
domain name and the number of seconds of clock-skew acceptable for signatures
on names in that domain. A clock skew value of -1 SHOULD have the effect of turning off
inception and expiration time checks on signatures from that domain. The default clock 
skew SHOULD be 0.
In the following example, for DNSSEC validator contexts created with the "mta" label, signature 
inception and expiration checks are disabled for all names under the example.com domain.
    <figure>
    <artwork>
    mta clock-skew
        example.com -1 
        ;
    </artwork>
    <postamble>
    </postamble>
    </figure>
</t>
</list> </t> 
        </section>



        <section title="Global Validator Policy">

        <t> Global policy options guide validator behavior across multiple zones.
Global policy options for the DNSSEC validator may be defined under a separate 
section within the validator system configuration. Some of the possible configuration
knobs for global validator policy include the following. </t>
       
        <t><list style="symbols">
<t> trust-oob-answers &lt;yes/no&gt;: 
policy on whether or not the validator should trust answers received out-of-band.  </t>   

<t> edns0-size &lt;default-edns0-size&gt;: 
the default EDNS0 size to be advertized in queries sent out by the validator.  </t>   
        </list> </t>

        </section>


        </section>
  </back>
</rfc>

