<?xml version="1.0"  encoding='ISO-8859-1' standalone='no' ?>
<?rfc compact="yes" ?>
<?rfc editing="no" ?>
<?rfc toc="yes"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<rfc ipr="full3978" docName="draft-hayatnagarkar-dnsext-validator-api-01">
  <front>
  <title> DNSSEC Validator API </title>

  <author initials="A." surname="Hayatnagarkar"
                fullname="Abhijit Hayatnagarkar"> 
    <organization> SPARTA, Inc. </organization>
    <address>
       <postal>
        <street>7075 Samuel Morse Dr.</street>
        <city>Columbia</city>
        <region>MD</region>
        <code>21046</code>
        <country>US</country>
      </postal>
      <email>abhijit AT sparta.com</email>
    </address>
  </author>

  <author initials="S." surname="Krishnaswamy"
                fullname="Suresh Krishnaswamy"> 
    <organization> SPARTA, Inc. </organization>
    <address>
       <postal>
        <street>7075 Samuel Morse Dr.</street>
        <city>Columbia</city>
        <region>MD</region>
        <code>21046</code>
        <country>US</country>
      </postal>
      <email>suresh AT sparta.com</email>
    </address>
  </author>

  <date month="June" year="2006" />
  <workgroup> DNS Extensions </workgroup>
  <keyword>Internet-Draft</keyword>

  <abstract> 
    <t>The DNS Security Extensions (DNSSEC) provide origin authentication and
integrity of DNS data.  However, the current resolver Application Programming 
Interface (API) does not allow a security-aware resolver to communicate 
detailed results of DNSSEC processing back to the application.  
This document describes an API  between applications and a validating 
security-aware stub resolver that allows applications to control the 
validation process and obtain results of DNSSEC processing.</t>
  </abstract>
  </front>

  <middle>
  <section title="Introduction">
  <!--           ############## -->

  <t>
  DNS Security Extensions (<xref target="refs.RFC4033">RFC 4033</xref>,
<xref target="refs.RFC4034">RFC 4034</xref>, <xref target="refs.RFC4035">RFC 4035</xref>)
allow applications to test the origin authenticity and integrity of data returned by the 
DNS.  The validator, or more formally, the validating security-aware stub resolver 
is a piece of software that performs this test
by checking the cryptographic signatures that cover DNS records and by
verifying a sequence of such records from a <xref target="refs.RFC4033">trust anchor</xref> to
this data. </t>

  <t>
  This document presents an Application Programming Interface (API) 
between the application and the validator.
The API functions provide a convenient way for applications to control the DNSSEC validation
process and to obtain detailed results of the validation process. </t>
  <t>
  The API can be broadly divided into three groups: 
the high-Level validator API, the low-Level validator API and 
the context management API. </t>

  <t>
  The high-level validator API is designed for ease of 
use and mirrors existing DNS-related functions.
This API is best suited for existing applications that already use 
legacy DNS-related functions such as gethostbyname(), 
getaddrinfo() and res_query(), or for applications that have no requirement 
for detailed validation status information. </t>

  <t> The low-level validator API gives more control over the 
validation process and allows detailed inspection of validation 
status for each element of the <xref target="refs.RFC4033">authentication chain</xref>. </t>

  <t> Results returned by the validator can be guided by local policy decisions.  
The context management API provides functions to manage validator policies.</t>

  <t> The range of functions provided in this API allows for the creation of applications
that are either only interested in basic results such as "validated"
or "not-validated",  or more sophisticated applications that can look
for specific errors as a sign of a network abnormality or attack. </t>

  <t> <xref target="high_level_api"/>, <xref target="low_level_api"/>,
and <xref target="val-context"/> describe these interfaces in greater detail. </t>

  </section> <!-- Introduction -->


  <section title="Terminology">
  <!--            ############# -->

  <t> Some of the terminology used in this specification are defined below: 

  <list style="hanging">

		<t> </t>
		<t hangText="validator policy:"> 
		a set of configuration parameters for the validator that can influence 
		the eventual outcome of the validation process. </t>

		<t> </t>
        <t hangText="policy attribute: ">
        a particular configurable component of the validator policy;
        for instance a trust anchor setting or an untrusted algorithm definition. </t>

        <t> </t>
        <t hangText="validator context:">
		an opaque structure encapsulating the validator policy. 
        The validator context is the application's handle to the validator policy.  </t>

        <t> </t>
        <t hangText="base policy:">
		the default policy definition that is associated with a validator context. 
		The base policy can be different for different validator contexts. </t>

		<t> </t>
        <t hangText="policy scope: ">
        a customization within the base policy to address the requirements of a particular 
		operating scenario.  Policy scopes are useful
        when it becomes necessary to override certain policy attributes in specific
        environments. As an example, an application may require different validator policies 
		for a web browser and a mail client. In such cases the application may define a common
        base policy for the system and have overrides for specific scopes: one for the web browser
        and one for the mail client.  Policy scopes for a base policy are defined hierarchically, 
		one below the other. </t> 

		<t> </t>
        <t hangText="effective policy:">
        the policy that finally governs the validator behavior after all
        relevant policy scopes have been applied. 
		The effective policy is computed by applying the base policy
		for the context and overrides defined in all valid policy scopes in 
		increasing order of specificity.</t>

      </list> </t>

  </section> <!-- Terminology -->


    <section title="High-level Validator API" anchor="high_level_api">
    <!--            ######################### -->
    <t>
    The high-level validator API provides DNSSEC-aware substitutes for commonly
used DNS functions such as gethostbyname(), getaddrinfo(), and res_query().
This API provides an easy path for applications already using these legacy functions
to transition towards becoming DNSSEC-aware.
  </t>
  <t>
The ctx parameter of type val_context_t* used in the following functions points
to the validator context.  
An application may explicitly create a context using the val_create_context() function
described in <xref target="val-context"/>, or allow the API to create one internally on its behalf by 
specifying the value of NULL for the ctx parameter.  

  </t>
     <section title="val_gethostbyname, val_gethostbyname_r, val_gethostbyaddr, val_gethostbyaddr_r">
      <figure>
      <artwork>
struct hostent *val_gethostbyname( const val_context_t *ctx,
                                   const char          *name,
                                   val_status_t        *val_status );

int val_gethostbyname_r( const val_context_t *ctx,
                         const char          *name,
                         struct hostent      *ret,
                         char                *buf,
                         size_t              buflen,
                         struct hostent      **result,
                         int                 *h_errnop,
                         val_status_t        *val_status ); 

struct hostent *val_gethostbyaddr( const val_context_t *ctx,
                                   const char          *addr,
                                   int                 len,
                                   int                 type,
                                   val_status_t        *val_status );

int val_gethostbyaddr_r( const val_context_t *ctx,
                         const char          *addr,
                         int                 len,
                         int                 type,
                         struct hostent      *ret,
                         char                *buf,
                         int                 buflen,
                         struct hostent      **result,
                         int                 *h_errnop,
                         val_status_t        *val_status );
      </artwork>
      <postamble>
      <t>
      The val_gethostbyname() and val_gethostbyname_r() functions perform
name-to-address translation.  The val_gethostbyaddr() and val_gethostbyaddr_r()
functions perform the address-to-name translation.
      These functions are DNSSEC-aware versions of the gethostbyname(),
gethostbyname_r(), gethostbyaddr() and gethostbyaddr_r() functions and
can be used by applications to get the validation status of DNS queries
performed during the name-to-address or address-to-name translations.
The parameters to the above functions closely mirror the legacy functions
and must be only used when replacing such functions with their DNSSEC-aware 
counterparts. For applications that do not already use these older functions
it is instead recommended to use functions from <xref target="hl_getaddrinfo"/> 
to provide address-to-name and name-to-address translations.
      </t>
      <t>
      The val_gethostbyname() function returns a pointer to a structure of
type hostent for the given host name.  The val_gethostbyaddr() function
returns a pointer to a structure of type hostent for the given host address
addr whose length is given by the len parameter and address type is given by
the type parameter.  Valid address types are AF_INET and AF_INET6.  As with
gethostbyname() and gethostbyaddr(), the val_gethostbyname() and
val_gethostbyaddr() functions set the value of the global h_errno variable.
Their return value may point to static data, and it may be overwritten by
subsequent calls.  These functions return a pointer to a struct hostent value
on success, and NULL on error.
      </t>
      <t>
      The val_gethostbyname_r() and val_gethostbyaddr_r() functions are
reentrant and thread-safe versions of the val_gethostbyname() and val_gethostbyaddr() functions.
They should be used by multi-threaded applications or applications that
make multiple calls to these functions and store the return values.
These functions return 0 on success, and a non-zero value on error.  The result of the
call is stored in the hostent structure whose address is passed in the ret
parameter.  These functions do not modify the global h_errno variable, but
return the error numbers in the variable whose address is passed in the
h_errnop parameter. After the call, *result will be NULL on error
or point to the result on success.  Auxiliary data is stored in the buffer
buf of length buflen. If the buffer is too small, these functions will
return the error ERANGE.
      </t>
      <t>
      The val_status parameter returns the status of DNSSEC
validation, and must contain the address of a variable of type val_status_t. 
Possible values for val_status_t are defined in <xref target="val-status"/>.
A validation status of VAL_SUCCESS will be returned only if both the address and
canonical name(s) within the hostent structure, if present, have been 
validated successfully.
      </t>
      </postamble>
      </figure>
      </section>

      <section title="val_getaddrinfo, val_getnameinfo, val_freeaddrinfo" anchor="hl_getaddrinfo">
      <figure>
      <artwork>
int val_getaddrinfo( const val_context_t   *ctx, 
                     const char            *nodename,
                     const char            *servname,
                     const struct addrinfo *hints,
                     struct val_addrinfo   **res ); 

int val_getnameinfo( const val_context_t   *ctx, 
                     const struct sockaddr *sa,
                     socklen_t             salen,
                     char                  *host,
                     size_t                hostlen,
                     char                  *serv,
                     size_t                servlen,
                     int                   flags,
                     val_status_t          *val_status );

void val_freeaddrinfo( struct val_addrinfo *ainfo );


struct val_addrinfo {
           int                 ai_flags;
           int                 ai_family;
           int                 ai_socktype;
           int                 ai_protocol;
           size_t              ai_addrlen;
           struct sockaddr     *ai_addr;
           char                *ai_canonname;
           struct val_addrinfo *ai_next;
           val_status_t        val_status;
}
      </artwork>
      <postamble>
      <t>
      The val_getaddrinfo() function returns the address and service
information for the specified domain name and service.  It is a
DNSSEC-aware version of the getaddrinfo() function
(<xref target="refs.RFC3493">RFC 3493</xref>).
This function supports both IPv4 and IPv6
addresses.  It returns a pointer to a value of type val_addrinfo in *res on
success, and NULL on error.  The val_addrinfo structure is an augmented form
of the addrinfo structure.  It contains an additional val_status field that
represents the status of DNSSEC validation for that particular answer.  

The memory for the value returned in *res is dynamically allocated by this 
function.  The caller should free it after use with the val_freeaddrinfo() function.
      </t>
      <t>
      The val_getnameinfo() function performs an address-to-name translation
in a protocol independent manner.  It is a DNSSEC-aware version of the
getnameinfo() function (<xref target="refs.RFC3493">RFC 3493</xref>).  In
addition to the values returned by the getnameinfo() function, it returns
the DNSSEC validation status via the val_status parameter.
      </t>
	  <t>
val_status_t values can be displayed in a human-understandable format using
the p_val_error() function as described in <xref target="p-val-error"/>.
val_status will contain a validation status of VAL_SUCCESS 
only if both the address and canonical name within the val_addrinfo 
structure, if present, have been validated successfully.  
	  </t>
      <t>
The val_getaddrinfo() and val_getnameinfo() functions return 0 on success and
a non-zero value on error.
      </t>
      </postamble>
      </figure>
      </section>

      <section title="val_query">
      <figure>
      <artwork>
int val_query( const val_context_t *ctx, 
               const char          *domain_name,
               const u_int16_t     class, 
               const u_int16_t     type,
               const u_int8_t      flags, 
               struct val_response **resp); 

int val_free_response(struct val_response *resp);

struct val_response {
        unsigned char *response;
        int           response_length;
        val_status_t  val_status;
        struct val_response *next_response;
};
      </artwork>
      <postamble>
      <t>
      The val_query() function queries the name server for a fully qualified
domain name of the given class and type.  In addition to the answers to the
query, it gives the status of DNSSEC validation for each answer returned.
It is intended as a DNSSEC-aware replacement for the res_query() function.
      </t>
      <t>
      Multiple RRsets may be returned in response to a query, each with a 
potentially different validation status. 
The val_query() function returns 0 on success and a non-zero error code
on failure.  When a success value is returned, the 
*resp contains a linked-list of responses returned by the validator.  
The memory for *resp is internally allocated and must be released 
after a successful invocation of val_query() using the 
val_free_response() function. </t> 
      <t>
      By default, each val_response structure in the *resp linked list 
holds a single RRset response. The format of the response field 
within the val_response structure is similar to the format 
of the answer returned by res_query(). The val_status field contains 
the status of DNSSEC validation for that particular RRset and may
be displayed in a human-understandable format using
the p_val_error() function as described in <xref target="p-val-error"/>.
</t>
     <t>
     The flags parameter controls the scope of validation and name
resolution, and the output format.  At present only one flag is defined:
VAL_QUERY_MERGE_RRSETS. This flag has been provided for legacy applications
that already use res_query() and want to transition to val_query() with
minimal change.  When this flag is specified, all RRsets in the answer
are merged into a single response and returned in the first (and only)
element of the resp array.  
The response field of this element will have a format similar
to the answer returned by res_query().  The validation status will be
VAL_SUCCESS only if all the individual RRsets have been successfully
validated.  Otherwise, the validation status will be an error code.
If this flag is used and a value other than VAL_SUCCESS is returned with
multiple RRsets in the answer, it will not be possible to know which
RRset resulted in the error status.</t>

      </postamble>
      </figure>
      </section>
     <section title="p_val_error" anchor="p-val-error">
      <figure>
      <artwork>
char *p_val_error(val_status_t err);
      </artwork>
      <postamble>
      <t>
The p_val_error() function can be used to display the value contained in the val_status_t parameter in
a human-understandable format. The returned values are essentially string representations of the
definitions given in <xref target="val-status"/>. 
      </t>
      </postamble>
      </figure>
      </section>

      </section> <!-- High-level Validator API -->


      <section title="Low-level Validator API" anchor="low_level_api">
      <!-- #################################### -->

      <t> 
      The low-level validator API provides the application with greater control and visibility 
into the validation process. The functions and data structures defined in this API are 
summarized below. </t>

      <section title="val_resolve_and_check, val_free_result">
        <figure>
        <artwork>
int val_resolve_and_check( const val_context_t        *context, 
                           const char                 *domain_name,
                           const u_int16_t            class,
                           const u_int16_t            type, 
                           const u_int8_t             flags,
                           struct val_result_chain    **results);

void val_free_result( struct val_result_chain *results );

struct val_result_chain {
    val_status_t               val_rc_status;
    struct val_assertion_chain *val_rc_trust;
    struct val_result_chain    *val_rc_next;
};

struct val_assertion_chain {
    val_astatus_t              val_ac_status;
    struct val_rrset           *val_ac_rrset;
    struct val_assertion_chain *val_ac_trust;
    struct val_assertion_chain *val_ac_rrset_next;
    struct val_assertion_chain *val_ac_next;
};

struct val_rrset {
    u_int8_t  *val_msg_header;
    u_int16_t val_msg_headerlen;
    u_int8_t  *val_queryset_data; /* for {N,C,T} when no answer is returned, NSID etc  */
    u_int16_t val_queryset_datalen;
    u_int8_t  *val_rrset_name_n;    /* Owner */
    u_int16_t val_rrset_class_h;    /* ns_c_... */
    u_int16_t val_rrset_type_h; /* ns_t_... */
    u_int32_t val_rrset_ttl_h;  /* Received ttl */
    u_int8_t  val_rrset_section;    /* VAL_FROM_... */
    struct rr_rec *val_rrset_data;  /* All data RR's */
    struct rr_rec *val_rrset_sig;   /* All signatures */
};

struct rr_rec
{
    u_int16_t       rr_rdata_length_h; 
    u_int8_t        *rr_rdata;  
    val_astatus     rr_status;      
    struct rr_rec   *rr_next;
};

char *p_as_error(val_astatus_t err);

        </artwork>
        <postamble>
        <t>
        The val_resolve_and_check() function queries a set of name servers
for the &lt;domain_name, class, type&gt; tuple and verifies and validates
the responses received. The verification step checks RRSIGs and the
validation step performs verification down the authentication chain from a trust
anchor.  All the information necessary for inspecting the authentication chain 
is available through the result parameter. flags is currently unused. 
The context parameter points to the validator context.  
An application may explicitly create a context using the val_create_context() 
function described in <xref target="val-context"/>, or allow the API to create 
one internally on its behalf by specifying the value of NULL for this parameter.  
val_resolve_and_check() returns 0 on success and an error code from 
<xref target="val-return-values"/> on failure. 
The val_resolve_and_check() function may internally allocate memory for the value of the result
parameter, which must be released by the caller after a successful call to this 
function using the val_free_result() function. </t>

        <t>
        Answers to the query are returned in the val_result_chain linked list.  
Each answer corresponds to a distinct RRset and is stored as a different element in the linked list; 
multiple RRs within the RRset are all part of the same answer. Multiple answers are possible
when the query type is ANY or when a proof of non-existence is returned, in
which case RRsets of type NSEC and SOA may also be returned. Members of the authentication chain
sequence are encapsulated in the val_assertion_chain structure and 
the val_rc_trust field points to the first element in the authentication chain sequence. 
val_rc_next can be used to iterate through the list of all results returned by the validator. 
The consolidated validation status value for an RRset in the  DNS response based on the 
individual status values for all components in the authentication chain is stored in 
val_rc_status, which is of type val_status_t. 
Possible values for this type are listed in <xref target="val-status"/> and can be
displayed in a human-understandable format using the p_val_error() function as described 
in <xref target="p-val-error"/>.
</t> 

        <t>
        Most applications would only be interested in the results parameter 
since this provides a single error code for representing the authenticity of 
returned data.  Sophisticated applications, such as a DNSSEC troubleshooting 
utility, may look more closely at an individual RRset within assertions or an element 
within queries to identify the particular component in the 
authentication chain that led to a validation failure as described below. </t>

<t>
The val_authentication_chain structure provides greater detail about the validation status for each component
of the chain of trust.
The val_ac_status field returns the validation status for the specified RRset. Possible values for this field are
defined in <xref target="val-astatus"/>. These values can be displayed in a human-understandable format using
the p_as_error() function. 
The val_ac_rrset_next field points to the next RRset within the set of responses returned for a query also
encapsulated within the val_assertion_chain structure. 
The val_ac_trust field points to the parent element for the current assertion in the authentication chain.
For a element with type DNSKEY, this would correspond to a DS record in the parent zone and for a DS record
this would correspond to the DNSKEY in the current zone. Its value is NULL when the current element in the
linked list points to a valid trust anchor or in case of an error when the parent node in the authentication chain cannot be constructed. 
The val_ac_next field can be used to iterate through the list of DNS responses within the struct val_assertion_chain linked list.</t> 

<t>
The val_ac_rrset field in the val_assertion_chain structure contains the actual RRset data. 
The following information is stored in this structure: the header of the DNS response in which the RRset was
received in val_msg_header, with a length of val_msg_headerlen; the query section of the DNS response in which
the RRset was received in val_queryset_data, with a length val_queryset_datalen; the DNS response "envelope"
comprising of the name, class, type and time-to-live tuple in  val_rrset_name_n, val_rrset_class_h,
val_rrset_type_h and val_rrset_ttl_h respectively; and the response RDATA.

The section where the RRset appears in the DNS response is saved in the val_rrset_section field. The following values may be returned in this field. </t> 
        <t> <list style="hanging">
        <t> </t>
        <t hangText="VAL_FROM_ANS:">
        returned if the RRset was present in the answer section of the DNS response.
        </t>
        <t> </t>
        <t hangText="VAL_FROM_AUT:">
        returned if the RRset was present in the authority section of the DNS response.
        </t>
        <t> </t>
        <t hangText="VAL_FROM_ADD:">
        returned if the RRset was present in the additional section of the DNS response.
        </t>
	</list></t>

<t> The response RDATA is stored within val_rrset_data. Any RRSIGs that are applicable
to the response RDATA are stored within val_rrset_sig. Both of these variables are of type rr_rec which is
essentially a list of name-value pairs corresponding to each resource-record within the RRset. Members of the
val_rrset_sig linked list also have an rr_status field which indicates whether the signature verified
succesfully over the corresponding RRset or no. Although rr_status is of type val_astatus_t (defined in
section <xref target="val-astatus"/>), this field only takes on a subset of status values, specifically those
pertaining to signature verification. </t>

        </postamble>
        </figure>

        </section>

        <section title="Assertion Status Codes" anchor="val-astatus">

		<t> The verification status value stored in the variable of type val_astatus_t can have the following
values:</t> 	
        <t> <list style="hanging">
        <t> </t>
        <t hangText="VAL_A_DATA_MISSING:">
        returned if there was no data returned for a query and the DNS did not indicate an error. 
        </t>
        <t> </t>
        <t hangText="VAL_A_RRSIG_MISSING:">
        returned if RRSIG data could not be retrieved for a resource record.
        </t>
        <t> </t>
        <t hangText="VAL_A_DNSKEY_MISSING:">
        returned if the DNSKEY for an RRSIG covering a resource record was not available.
        </t>
        <t> </t>
        <t hangText="VAL_A_DS_MISSING:">
        returned if the DS record covering a DNSKEY record was not available.
        </t>
        <t> </t>
        <t hangText="VAL_A_NO_TRUST_ANCHOR:">
        returned if there was no trust anchor configured for a given authentication chain.
        </t>
        <t> </t>
        <t hangText="VAL_A_UNTRUSTED_ZONE:">
        returned if local policy defines a given zone to be untrusted.
        </t>
        <t> </t>
        <t hangText="VAL_A_IRRELEVANT_PROOF:">
        returned if the proof of nonexistence returned for a query is ambiguous. 
        </t>
        <t> </t>
        <t hangText="VAL_A_DNSSEC_VERSION_ERROR:">
        returned if the DNSSEC version is unrecognized.
        </t>
        <t> </t>
        <t hangText="VAL_A_TOO_MANY_LINKS:">
        returned if local policy identifies a given authentication chain to be too long.
        </t>
        <t> </t>
        <t hangText="VAL_A_UNKNOWN_DNSKEY_PROTO:">
        returned if the DNSKEY protocol number is unrecognized.
        </t>
        <t> </t>
        <t hangText="VAL_A_DNSKEY_NOMATCH:">
        returned if an RRSIG was created by a DNSKEY that does not exist in the apex keyset.
        </t>
        <t> </t>
        <t hangText="VAL_A_WRONG_LABEL_COUNT:">
        returned if the number of labels on the signature is greater than the the count given in the RRSIG RDATA.
        </t>
        <t> </t>
        <t hangText="VAL_A_SECURITY_LAME:">
        returned if an was RRSIG created by a key that does not exist in the parent DS record set.
        </t>
        <t> </t>
        <t hangText="VAL_A_NOT_A_ZONE_KEY:">
        returned if the key used to verify the RRSIG is not valid DNSKEY.
        </t>
        <t> </t>
        <t hangText="VAL_A_RRSIG_NOTYETACTIVE:">
        returned if the RRSIG's inception time is in the future.
        </t>
        <t> </t>
        <t hangText="VAL_A_RRSIG_EXPIRED:">
        returned if the RRSIG has expired.
        </t>
        <t> </t>
        <t hangText="VAL_A_ALGO_NOT_SUPPORTED:">
        returned if the algorithm in DNSKEY or RRSIG or DS is not supported.
        </t>
        <t> </t>
        <t hangText="VAL_A_UNKNOWN_ALGO:">
        returned if the DNSKEY or RRSIG or DS algorithm is unknown.
        </t>
        <t> </t>
        <t hangText="VAL_A_RRSIG_VERIFIED:">
        returned if the RRSIG verified successfully.
        </t>
        <t> </t>
        <t hangText="VAL_A_RRSIG_VERIFY_FAILED:">
        returned if the RRSIG did not verify.
        </t>
        <t> </t>
        <t hangText="VAL_A_NOT_VERIFIED:">
        returned if different RRSIGs covering the same resource record failed for different reasons. 
        </t>
        <t> </t>
        <t hangText="VAL_A_KEY_TOO_LARGE:">
        returned if local policy has identified the key size as being too large.
        </t>
        <t> </t>
        <t hangText="VAL_A_KEY_TOO_SMALL:">
        returned if local policy has identified the key size as being too small.
        </t>
        <t> </t>
        <t hangText="VAL_A_KEY_NOT_AUTHORIZED:">
        returned if local policy has identified the key to be unauthorized for validation. 
        </t>
        <t> </t>
        <t hangText="VAL_A_ALGO_REFUSED:">
        returned if the algorithm in the DNSKEY or RRSIG or DS is not allowed as per local policy.
        </t>
        <t> </t>
        <t hangText="VAL_A_CLOCK_SKEW:">
        returned if the signature over the resource record could only be verified after clock skew is taken into account 
        </t>
        <t> </t>
        <t hangText="VAL_A_DUPLICATE_KEYTAG:">
        returned if two different DNSKEYs in a zone have the same keytag. 
        </t>
        <t> </t>
        <t hangText="VAL_A_NO_PREFERRED_SEP:">
        returned if there is no DNSKEY in the parent DS set that local policy permits the validator to build its
authentication chain from. 
        </t>
        <t> </t>
        <t hangText="VAL_A_WRONG_RRSIG_OWNER:">
        returned if the RRSIG and the data that it purportedly covers have differing notions of owner name
        </t>
        <t> </t>
        <t hangText="VAL_A_RRSIG_ALGO_MISMATCH:">
        returned if the DNSKEY and RRSIG pair have a mismatch in their algorithm. 
        </t>
        <t> </t>
        <t hangText="VAL_A_KEYTAG_MISMATCH:">
        returned if the DNSKEY and RRSIG pair have a mismatch in their key tags 
        </t>
        <t> </t>
        <t hangText="VAL_A_VERIFIED:">
        returned if at least one RRSIG covering a resource record had a status of VAL_A_RRSIG_VERIFIED. 
        </t>
        <t> </t>
        <t hangText="VAL_A_LOCAL_ANSWER:">
        returned if the answer was obtained locally. 
        </t>
        <t> </t>
        <t hangText="VAL_A_TRUST_KEY:">
        returned if a given DNSKEY or a DS record has been locally defined to be a trust anchor. 
        </t>
        <t> </t>
        <t hangText="VAL_A_TRUST_ZONE:">
        returned if local policy defines a given zone to be trusted. 
        </t>
        <t> </t>
        <t hangText="VAL_A_BARE_RRSIG:">
        returned if the query was for an RRSIG in which case no validation is possible. 
        </t>
        </list>
        </t>

		<t> Resolver-related status values are reflected in val_astatus_t by one of the following values, offset by 
VAL_A_DNS_ERROR_BASE : </t> 	
        <t> <list style="hanging">
        <t> </t>
        <t hangText="SR_TSIG_ERROR:">
        returned if there was an error in TSIG processing.
        </t>
        <t> </t>
        <t hangText="SR_NO_ANSWER:">
        returned if no answer was received for a query. 
        </t>
        <t> </t>
        <t hangText="SR_INTERNAL_ERROR:">
        returned if an internal error was encountered in the resolver.
        </t>
        <t> </t>
        <t hangText="SR_WRONG_ANSWER:">
        returned if a message received was not a valid response to a query.
        </t>
        <t> </t>
        <t hangText="SR_HEADER_BADSIZE:">
        returned if the message size was not consistent with header values.
        </t>
        <t> </t>
        <t hangText="SR_DNS_GENERIC_ERROR:">
        returned if the response was received with the rcode set to one of the well-known error values
		such as NXDOMAIN, FORMERR, etc. 
        </t>
        <t> </t>
        <t hangText="SR_EDNS_VERSION_ERROR:">
        returned if the EDNS0 version was not recognized. 
        </t>
        <t> </t>
        <t hangText="SR_UNSUPP_EDNS0_LABEL:">
        returned if the EDNS0 label is not supported. 
        </t>
        <t> </t>
        <t hangText="SR_SUSPICIOUS_BIT:">
        returned if some bit in the response headers is unexpectedly set or unset. 
        </t>
        <t> </t>
        <t hangText="SR_NAME_EXPANSION_FAILURE:">
        returned if DNS name uncompression failed. 
        </t>
        <t> </t>
        <t hangText="SR_MISSING_GLUE:">
        returned if glue records are not available for a referral.
        </t>
        <t> </t>
        <t hangText="SR_CONFLICTING_ANSWERS:">
        returned if multiple answers are returned for a query which are inconsistent with each other. 
        </t>
        </list>
        </t>

		</section>

    </section> <!-- Low-level API -->

    <section title="Context Management and Validator Policy API" anchor="val-context">
    <!--            ####################################### -->

      <t>
      Applications can use local policy to influence the decision 
      about when the validator must break 
      out from the process of constructing the authentication chain with 
      either a success or failure condition.  
      Examples of local policy elements include trust anchors for 
      different zones, untrusted algorithms for cryptographic keys and hashes, and
      acceptable clock skew for signature inception and expiration times.
      All of these may be different for different 
      applications and operation scenarios. </t> 

	<t> Local policy for the validator is stored in the local configration system (typically the configuration file, 
	/etc/dnsval.conf).  
Policies are identified by labels or simple text strings, which must be unique within the configuration system. As an
example, "browser" could be used as the label for a policy that defines the base policy for all web-browsers in a
system.  The ':' character in the label string specifies a new scope within a given policy. Thus,
"mozilla:browser" could be used as the identifier to refer to the browser-specific validator policy for the
mozilla suite. A label value of ":" identifies the "default" base policy. </t>

<t> Policy definitions have the following structure.  </t> 
<t> &lt;label&gt; &lt;attribute&gt; &lt;additional-data&gt;; </t>
<t> The only defined value for &lt;attribute&gt; is "trust-anchor". (author's note: the range of possible policy attributes will no doubt have to be extended in future.) The value for &lt;additional-data&gt; depends on the type of attribute specified.  For the "trust-anchor" attribute this is a sequence of the zone name and a quoted string containing the RDATA portion for the trust anchor's DNSKEY. An example is given below. </t>
      <figure>
      <artwork>
browser trust-anchor example.com   "257 3 5 AQO8XS4y9r77X9SHBmrx \
                MoJf1Pf9AT9Mr/L5BBGtO9/e9f/zl4FFgM2l B6M2XEm6mp6 \
                mit4tzpB/sAEQw1McYz6bJdKkTiqtuWTCfDmgQhI6/Ha0 Ef \
                GPNSqnY 99FmbSeWNIRaa4fgSCVFhvbrYq1nXkNVyQPeEVHk \
                oDNCAlr qOA3lw==" ;
      </artwork>
      <postamble>
      </postamble>
      </figure>

      <section title="val_create_context, val_free_context">
      <figure>
      <artwork>
int val_create_context( const char    *label,
                     val_context_t **newcontext );

void val_free_context( val_context_t *context );
      </artwork>
      <postamble>
      <t>
      The val_create_context() creates a handle to the validator policy in newcontext. 
A NULL context is returned if an error is encountered. 
The label parameter identifies the particular policy to be used as the base policy for the context during validation. 
The label parameter in val_create_context() must be uniquely defined within the configuration system. A NULL
label creates a context with the "default" base policy (the policy identified by the ":" label in the 
configuration system). </t> 

<t> The val_create_context() function returns 0 on success, and an error code from <xref target="val-return-values"/> on failure.  </t>

<t>
The application must release the memory allocated 
by the val_create_context() function using the val_free_context() function once it is done with using the validator context.</t>

      </postamble>
      </figure>
      </section>

      <section title="val_switch_policy_scope">
      <figure>
      <artwork>
int val_switch_policy_scope( val_context_t *ctx,
                             const char    *scope );
      </artwork>
      <postamble>
      <t>
      This function allows applications to switch their current validator context to a particular policy scope.  
The validator context supplied in ctx must not be NULL and the scope must be valid for the context. Thus, trying to switch
the policy scope to "safari:browser" when the context was created with a base policy of "browser" would be legal, 
but it trying to switch the policy scope to "outlook:mail" would result in an error. 
A NULL scope switches the context's current policy scope to its base policy. </t> 

<t> The val_switch_policy_scope() function returns 0 on success, and an error code from <xref
target="val-return-values"/> on failure.  </t>
      </postamble>
      </figure>
      </section>

      <section title="val_get_scopes_within_context">
      <figure>
      <artwork>
int val_get_scopes_within_context( val_context *ctx,
                                   char        **scopes,
                                   int         *count );
      </artwork>
      <postamble>
      <t>
      This function allows applications to obtain the list of policy scopes available within a given context.
The function returns 0 on success and sets *count to the number of scopes available. 
If the number of scopes available is greater than 0, then the memory for the scopes parameter is 
internally allocated. Application must free each of the *count elements returned in *scopes. 
This function returns 0 on success and one of the error codes from <xref target="val-return-values"/> 
on failure. </t>
      </postamble>
      </figure>
      </section>

      <section title="val_get_scope_definition, val_set_scope_definition">
      <figure>
      <artwork>
int val_get_scope_definition( val_context *ctx,
                              char        *scope,
                              char        **pol_def ); 

int val_set_scope_definition( val_context *ctx,
                              const char  *scope, 
                              char        *policy_string );
      </artwork>
      <postamble>
      <t>
      The val_get_scope_definition() function allows applications to obtain the policy definition for a given scope
identifier. Memory for *pol_def, if the definition for scope exists, is internally allocated and must be released
by the application after use.
      </t>
      <t>
      The val_set_scope_definition() function allows an application to modify an existing policy scope or 
define a new policy scope within a context. A NULL scope updates the base policy within the context. </t>

<t>
The validator context supplied in the ctx parameter for these functions must not be NULL.
The above functions return 0 on success and an error code from <xref target="val-return-values"/> on failure.  </t>
      </postamble>
      </figure>
      </section>

    </section> <!-- Context Management -->

	<section title="Validation Status Codes and Return Values">
    <!--            ####################################### -->

	<t> The following sections specify the values that may be returned in the val_status_t parameter for the
high-level and low-level APIs, and the return values for the low-level and context-management APIs. The High-level API mirrors existing DNS-related functions, so the return values from these are similar to their predecessors. </t> 

	<section title="Return Values" anchor="val-return-values">

	<t> The following values may be returned by functions in the low-level and context-management APIs. </t>

        <t> <list style="hanging">
        <t> </t>
        <t hangText="VAL_NOT_IMPLEMENTED:">
       	returned if the implementation did not support a particular feature. 
        </t>
        <t> </t>
        <t hangText="VAL_OUT_OF_MEMORY:">
       	returned if memory could not be allocated for an operation. 
        </t>
        <t> </t>
        <t hangText="VAL_BAD_ARGUMENT:">
	returned if an unexpected value was passed as an argument to a function.
        </t>
        <t> </t>
        <t hangText="VAL_INTERNAL_ERROR:">
	returned if an internal error was encountered in the validator library. 
        </t>
        <t> </t>
        <t hangText="VAL_NO_PERMISSION:">
	returned if the application lacked sufficient privileges to perform an operation. 
        </t>
        <t> </t>
        <t hangText="VAL_RESOURCE_UNAVAILABLE:">
	returned if some resource necessary for an operation was unavailable. 
        </t>
        <t> </t>
        <t hangText="VAL_CONF_PARSE_ERROR:">
	returned if the validator configuration was improperly specified in the configuration 
	system. 
        </t>
        <t> </t>
        <t hangText="VAL_CONF_NOT_FOUND:">
	returned if the validator configuration could not be located in the 
	configuration system. 
        </t>
        <t> </t>
        <t hangText="VAL_NO_POLICY:">
	returned if the policy identifier being referenced could not be located 
	or was invalid for the current context. 
        </t>
	</list></t>

	</section>
	<section title="Validation Status Codes" anchor="val-status">

	<t> val_status_t defines the list of error codes returned by the validator
	to an application. Possible values for val_status_t are listed below. </t> 

        <t> <list style="hanging">
        <t> </t>
        <t hangText="VAL_LOCAL_ANSWER:">
        returned if the response was obtained locally (for example a file such as /etc/hosts).
        </t>
        <t> </t>
        <t hangText="VAL_BARE_RRSIG:">
        returned if the response was for a query of type RRSIG. RRSIGs contain the cryptographic
	signatures for other DNS data and cannot themselves be validated.
        </t>
        <t> </t>
        <t hangText="VAL_NONEXISTENT_NAME:">
        returned if the proof for denial of existence for a domain name
	was validated. 
        </t>
        <t> </t>
        <t hangText="VAL_NONEXISTENT_TYPE:">
        returned if the proof for denial of existence for the resource record type for the
	name queried was validated. 
        </t>
        <t> </t>
        <t hangText="VAL_ERROR:">
        returned if the an error was encountered while validating the authentication chain. 
        </t>
        <t> </t>
        <t hangText="VAL_PROVABLY_UNSECURE:">
        returned if the zone to which the response belongs was inferred to be un-signed. 
        </t>
        <t> </t>
        <t hangText="VAL_INDETERMINATE:">
        returned if the validator lacked data required to complete validation down the authentication chain. 
        </t>
        <t> </t>
        <t hangText="VAL_BOGUS:">
        returned if the response could not be validated due to signature verification failures. 
        </t>
        <t hangText="VAL_NOTRUST:">
        returned if all available components in the authentication chain were successfully verified
		but there was no trust anchor available. 
        </t>
        <t> </t>
        <t hangText="VAL_SUCCESS:">
        returned if the response was verified and validated.
        </t>
        </list>
        </t>

		<t> In cases where a DNS error is returned for the initial query, the resolver-related error values listed in <xref target="val-astatus"/> are also returned in val_status_t, offset by the value of VAL_DNS_ERROR_BASE. </t>
	</section>
	</section>

   <section title="IANA Considerations">
   <t> This document has no actions for IANA.</t>
   </section> <!-- IANA Considerations -->

   <section title="Security Considerations" anchor="security-considerations">
   <t>
   The validator API functions return a status of VAL_LOCAL_ANSWER if they are 
returned an answer to a given query from the local configuration system 
(for example, from the /etc/hosts file).  The
application cannot assume that these answers can be trusted, unless the
application is certain that local data (such the /etc/hosts file) is trustworthy.
If this information is modified during a DHCP lookup, for example, the client
system should ensure that the DHCP server is a trusted source, and that the
communication path between the DHCP server and the client system is secured. 
 If these conditions are not satisfied and if the application chooses to trust
a validation status of VAL_LOCAL_ANSWER, there exists a potential attack vector
whereby an attacker can poison the configuration system and an application using
this API may trust the result.
   </t>
   <t>
   The DNS search path may affect the result of validation, especially in
the current Internet environment where not all DNS name servers are
expected to be DNSSEC-aware.  If the name server pointed to by the configuration system 
is not DNSSEC-aware (i.e. it does not return DNSSEC records), validation will not 
be performed. The list of default name servers (such as in the file /etc/resolv.conf file) 
is typically modified by DHCP clients.  Hence,
if the client system uses DHCP, it must ensure that the DHCP server
is a trusted source, and that the communication path between the DHCP server
and the client system is secured.
   </t>
   <t>
   The validator configuration information needs to be protected similarly
so that it cannot be overwritten by unauthorized users or processes. Access to 
the val_set_scope_definition() function must similarly be controlled to 
prevent malicious changes to the validator policy.  Configuration for the 
validator also contains the trust anchors for classes of applications.  The
system administrator must ensure that the list of trust anchors are kept
up-to-date in the event of key-rollovers.  If the trust anchors are outdated,
the validator may not be able to perform validation or may 
create the false impression of having successfully validated a response when 
it should have been flagged as bogus.
   </t>
   </section> <!-- Security Considerations -->

   <section title="Acknowledgements">
   <t>We would like to acknowledge the following individuals who have provided
valuable feedback and suggestions for improving this document: Lindy Foster,
Wayne Morrison, Russ Mundy, Bill Sommerfeld, Robert Story, Wes Hardaker.  
We would like to acknowledge our other team members at SPARTA for their 
inputs and suggestions while developing the validator API. The list of assertion
status codes listed in <xref target="val-astatus"/> was 
generated through multiple brainstorming sessions by the "apps" sub-working group
at the IETF meetings. This draft borrows the results from that effort.</t>
   </section> <!-- Acknowledgements -->

   </middle>
   <back>
        <references title="Normative References">
            <reference anchor="refs.RFC3493">
              <front>
                <title>Basic Socket Interface Extensions for IPv6</title>
                <author initials="R." surname="Gilligan" fullname="Bob Gilligan" />
                <author initials="S." surname="Thomson" fullname="Susan Thomson" />
                <author initials="J." surname="Bound" fullname="Jim Bound" />
                <author initials="J." surname="McCann" fullname="Jack McCann" />
                <author initials="W." surname="Stevens" fullname="W. Richard Stevens" />
                <date month="February" year="2003" />
              </front>
              <seriesInfo name="RFC" value="3493" />
            </reference>
            <reference anchor="refs.RFC4033">
              <front>
                <title>DNS Security Introduction and Requirements</title>
                <author initials="R." surname="Arends" fullname="Roy Arends" />
                <author initials="R." surname="Austein" fullname="Rob Austein" />
                <author initials="M." surname="Larson" fullname="Matt Larson" />
                <author initials="D." surname="Massey" fullname="Dan Massey" />
                <author initials="S." surname="Rose" fullname="Scott Rose" />
                <date month="March" year="2005" />
              </front>
              <seriesInfo name="RFC" value="4033" />
            </reference>
            <reference anchor="refs.RFC4034">
              <front>
                <title>Resource Records for the DNS Security Extensions</title>
                <author initials="R." surname="Arends" fullname="Roy Arends" />
                <author initials="R." surname="Austein" fullname="Rob Austein" />
                <author initials="M." surname="Larson" fullname="Matt Larson" />
                <author initials="D." surname="Massey" fullname="Dan Massey" />
                <author initials="S." surname="Rose" fullname="Scott Rose" />
                <date month="March" year="2005" />
              </front>
              <seriesInfo name="RFC" value="4034" />
            </reference>
            <reference anchor="refs.RFC4035">
              <front>
                <title>Protocol Modifications for the DNS Security Extensions</title>
                <author initials="R." surname="Arends" fullname="Roy Arends" />
                <author initials="R." surname="Austein" fullname="Rob Austein" />
                <author initials="M." surname="Larson" fullname="Matt Larson" />
                <author initials="D." surname="Massey" fullname="Dan Massey" />
                <author initials="S." surname="Rose" fullname="Scott Rose" />
                <date month="March" year="2005" />
              </front>
              <seriesInfo name="RFC" value="4035" />
            </reference>
        </references>
        <references title="Informative References">
            <reference anchor="refs.dnssectools" target="http://www.dnssec-tools.org">
              <front>
                <title>DNSSEC-Tools</title>
                <uri>http://www.dnssec-tools.org</uri>
              </front>
            </reference>
        </references>
        <!-- Appendices
        <section ...>
        <section ...>
        -->
    </back>
</rfc>

<!-- last updated Feb. 24, 2006 -->

