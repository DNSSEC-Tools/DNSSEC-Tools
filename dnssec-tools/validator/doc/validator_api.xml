<?xml version="1.0"  encoding='ISO-8859-1' standalone='no' ?>
<?rfc compact="yes" ?>
<?rfc editing="no" ?>
<?rfc toc="yes"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<rfc ipr="full3978" docName="draft-hayatnagarkar-dnsext-validator-api-04">
  <front>
    <title> DNSSEC Validator API </title>

    <author initials="S." surname="Krishnaswamy"
            fullname="Suresh Krishnaswamy"> 
      <organization> SPARTA, Inc. </organization>
      <address>
        <postal>
          <street>7110 Samuel Morse Dr.</street>
          <city>Columbia</city>
          <region>MD</region>
          <code>21046</code>
          <country>US</country>
        </postal>
        <email>suresh AT sparta.com</email>
      </address>
    </author>
    <author initials="A." surname="Hayatnagarkar"
            fullname="Abhijit Hayatnagarkar"> 
      <organization> SPARTA, Inc. </organization>
      <address>
        <postal>
          <street>7110 Samuel Morse Dr.</street>
          <city>Columbia</city>
          <region>MD</region>
          <code>21046</code>
          <country>US</country>
        </postal>
        <email>abhijit AT sparta.com</email>
      </address>
    </author>

    <date month="June" year="2007" />
    <workgroup> DNS Extensions </workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract> 
<t>The DNS Security Extensions (DNSSEC) provide origin authentication and
integrity of DNS data.  However, the current resolver Application Programming 
Interface (API) does not allow a security-aware resolver to communicate 
detailed results of DNSSEC processing back to the application.  
This document describes an API between applications and a validating 
security-aware stub resolver that allows applications to control the 
validation process and obtain results of DNSSEC processing.</t>
    </abstract>
  </front>

  <middle>
  <section title="Introduction">
  <!--           ############## -->

<t>The DNS Security Extensions (<xref target="refs.RFC4033">RFC 4033</xref>,
<xref target="refs.RFC4034">RFC 4034</xref>, <xref target="refs.RFC4035">RFC 4035</xref>)
allow resolvers to test the origin authenticity and integrity of data returned by the 
DNS.  A validator, or more formally, a validating security-aware stub resolver, 
is a piece of software that performs these tests by checking the cryptographic 
signatures that cover DNS records and by verifying a sequence of such records 
from a <xref target="refs.RFC4033">trust anchor</xref> to these signed records.  
This document presents an API between an application and a validator, which provides
a convenient way for applications to control the DNSSEC validation
process and obtain detailed validation results on which to base program behavior. </t>

<t>The API can be broadly divided into three groups: the high-Level validator API, 
the low-Level validator API and the context management API. </t>

<t> The high-level validator API is designed for ease of use and mirrors 
existing DNS-related functions. This API is best suited for existing 
applications that use legacy DNS-related functions such as 
gethostbyname(), getaddrinfo() and res_query() and have no requirement 
for detailed validation status information. </t>

<t> The low-level validator API allows detailed inspection of validation 
status values for each element of the <xref target="refs.RFC4033">authentication 
chain</xref>. </t>

<t> Validator operation can be guided by local policy. The context 
management API provides functions for applications to control which policies 
are used during DNSSEC validation.</t>

<t> The range of functions provided in this API allows for the 
creation of applications that are either only interested in basic 
DNSSEC results such as "validated" or "not-validated",  or more sophisticated 
applications that can look for specific errors in the authentication 
chain as a sign of a network abnormality or attack. </t>

<t> <xref target="high_level_api"/>, <xref target="low_level_api"/>,
and <xref target="val-context"/> describe these interfaces in greater detail. </t>

  </section> <!-- Introduction -->


  <section title="Terminology">
  <!--            ############# -->

<t> Some of the terms used in this specification are defined below: 

  <list style="hanging">
    <t> </t>
    <t hangText="legacy functions:"> 
Functions such as gethostbyname() and getaddrinfo() that are 
not capable of returning validation status values for DNS responses and are 
typically used by DNSSEC-unaware applications. </t>
    <t> </t>
    <t hangText="validator policy:"> 
a set of configuration parameters for the validator, which can influence 
the eventual outcome of the validation process. </t>
   	<t> </t>
    <t hangText="policy attribute: ">
a configurable component of the validator policy;
for instance a trust anchor setting or the acceptible clock skew 
value for a zone. </t>
    <t> </t>
    <t hangText="validator context:">
an opaque structure encapsulating the validator policy. 
The validator context is the application's handle to the validator policy.  </t>
    <t> </t>
    <t hangText="active policy:">
the policy associated with a validator context. </t> 
    <t> </t>
    <t hangText="default policy:">
the policy definition that is used by the validator when the application does 
not specify its own preference while creating a validator context. </t> 
  </list> </t>

  </section> <!-- Terminology -->

  <section title="DNSSEC Awareness in applications">
  <!--            ################################## -->


    <t> Applications will typically be interested in a single value
 that represents the trustworthiness of data. In some instances an
application may also need to distinguish between cases where the 
answer was cryptographically validated and cases where the answer
was locally trusted. </t>

    <t> The DNSSEC process can potentially return a number of different errors. 
The following sub-sections list these error types and describes 
functions that applications may use to evaluate the trustworthiness of
responses. </t>

    <section title="List of Validation Status Codes" anchor="val-status">
    <!--            ############################### -->

    <t> Results of DNSSEC validation are always returned in a variable of 
    type val_status_t. Possible values are listed below. </t>
        <t> <list style="hanging">
<t hangText="VAL_SUCCESS:">
returned if the response was successfully verified and validated.  </t>
<t> </t>
<t hangText="VAL_NONEXISTENT_NAME:">
returned if the proof for denial of existence for a domain name
was validated successfully.  </t>
<t> </t>
<t hangText="VAL_NONEXISTENT_TYPE:">
returned if the proof for denial of existence for the resource record type for the
name queried was validated successfully.  </t>
<t> </t>
<t hangText="VAL_IGNORE_VALIDATION:">
returned if local policy was configured to ignore validation for the zone from which this
data was received. </t>
<t> </t>
<t hangText="VAL_TRUSTED_ZONE:">
returned if local policy considered the zone from which this was data received to be trusted.  </t>
<t> </t>
<t hangText="VAL_NONEXISTENT_NAME_NOCHAIN:">
returned if the proof for denial of existence for a domain name
was considered trustworthy, but the authentication chain(s) for the different 
components of the proof were not themselves validated. </t> 
<t> </t>
<t hangText="VAL_NONEXISTENT_TYPE_NOCHAIN:">
returned if the proof for denial of existence for the resource record type for the
name queried was considered trustworthy, but the authentication chain(s) for the different 
components of the proof were not themselves validated.  </t>
<t> </t>
<t hangText="VAL_PROVABLY_UNSECURE:">
returned if the record or some ancestor of the record in the authentication chain 
towards the trust anchor was known to be provably unsecure, and if local policy 
defines this state as trusted. </t>
<t> </t>
<t hangText="VAL_LOCAL_ANSWER:">
returned if the response was obtained locally (for example, a file such as /etc/hosts).  </t>
<t> </t>
<t hangText="VAL_BARE_RRSIG:">
returned if the response was for a query of type RRSIG. RRSIGs contain the cryptographic
signatures for other DNS data and cannot themselves be validated.  </t>
<t> </t>
<t hangText="VAL_NOTRUST:">
returned if all available components in the authentication chain were successfully verified
but there was no trust anchor available.  </t>
<t> </t>
<t hangText="VAL_BOGUS_PROVABLE:">
returned if the response could not be validated due to signature verification 
failures or the inability to verify proofs for exactly one component in the authentication 
chain below the trust anchor.  </t>
<t> </t>
<t hangText="VAL_BOGUS:">
returned if the response could not be validated due to signature verification 
failures or the inability to verify proofs for an indeterminate number of
components in the authentication chain.  </t>
<t> </t>
<t hangText="VAL_BAD_PROVABLY_UNSECURE:">
returned if the record or some ancestor of the record in the authentication chain 
towards the trust anchor was known to be provably unsecure, but local policy 
defines this state as untrusted. </t>
<t> </t>
<t hangText="VAL_ERROR:">
returned if an error was encountered while validating the authentication chain.  </t>
<t> </t>
<t hangText="VAL_UNTRUSTED_ZONE:">
returned if local policy considered the zone from which this was data received to be untrusted.  </t>
<t> </t>
<t hangText="VAL_VALIDATED_ANSWER:">
returned if the combined validation status for a set of validator status values represents a validated
state.</t>
<t> </t>
<t hangText="VAL_TRUSTED_ANSWER:">
returned if the combined validation status for a set of validator status values represents a trusted (but
non-validated) state.</t>
<t> </t>
<t hangText="VAL_UNTRUSTED_ANSWER:">
returned if the combined validation status for a set of validator status values represents an untrusted 
state.</t>
        </list> </t>
<t> In cases where a DNS error is returned for the initial query, the 
resolver-related error values listed in <xref target="res-codes"/> are 
also returned in val_status_t, offset by the value of VAL_DNS_ERROR_BASE. </t>

    </section> <!-- List of Validation Status Codes -->

    <section title="List of Resolver-related status codes" anchor="res-codes">

    <t> In cases where the query resolution cannot be completed due to resolver
    errors, the following values may be returned. 

        <list style="hanging">
<t> </t>
<t hangText="SR_INTERNAL_ERROR:">
returned if an internal error was encountered in the resolver.  </t>
<t> </t>
<t hangText="SR_TSIG_ERROR:">
returned if there was an error in TSIG processing.  </t>
<t> </t>
<t hangText="SR_NO_ANSWER:">
returned if no answer was received for a query.  </t>
<t> </t>
<t hangText="SR_WRONG_ANSWER:">
returned if a received message was not a valid response to a query.  </t>
<t> </t>
<t hangText="SR_HEADER_BADSIZE:">
returned if the message size was not consistent with header values.  </t>
<t> </t>
<t hangText="SR_NXDOMAIN:">
returned if the rcode field in the response was set to NXDOMAIN, but either the authority section contained data other
than a proof of non-existence or the answer and additional sections were not empty.  </t>
<t> </t>
<t hangText="SR_FORMERR:">
returned if the rcode field in the response was set to FORMERR.  </t>
<t> </t>
<t hangText="SR_SERVFAIL:">
returned if the rcode field in the response was set to SERVFAIL.  </t>
<t> </t>
<t hangText="SR_NOTIMPL:">
returned if the rcode field in the response was set to NOTIMPL.  </t>
<t> </t>
<t hangText="SR_REFUSED:">
returned if the rcode field in the response was set to REFUSED.  </t>
<t> </t>
<t hangText="SR_DNS_GENERIC_ERROR:">
returned if the response was received with the rcode field set to none 
of the above well-known error values.
</t>
<t> </t>
<t hangText="SR_EDNS_VERSION_ERROR:">
returned if the EDNS0 version was not recognized.  </t>
<t> </t>
<t hangText="SR_UNSUPP_EDNS0_LABEL:">
returned if the EDNS0 label was not supported.  </t>
<t> </t>
<t hangText="SR_NAME_EXPANSION_FAILURE:">
returned if DNS name uncompression failed.  </t>
<t> </t>
<t hangText="SR_REFERRAL_ERROR:">
returned if referrals for a query could not be successfully followed.  </t>
<t> </t>
<t hangText="SR_MISSING_GLUE:">
returned if glue records were not available for a referral.  </t>
<t> </t>
<t hangText="SR_CONFLICTING_ANSWERS:">
returned if multiple answers were returned for a query, but they were inconsistent with each other.  </t> 

        </list> </t> 
    </section>

    <section title="Evaluating Trustworthiness" anchor="val-istrusted">
      <figure>
      <artwork>
#include &lt;validator.h&gt;

int val_istrusted(val_status_t status);

int val_isvalidated(val_status_t status);

int val_does_not_exist(val_status_t status);

char *p_val_status(val_status_t err);
      </artwork>
      <postamble>

      <t> The val_istrusted(), val_isvalidated() and val_does_not_exist()
functions allow an application to evaluate, at a high level, the trustworthiness of a 
response without having to inspect the exact status value returned. </t>

      <t> The val_istrusted() function returns a single boolean value 
representing the trustworthyness of information returned by
the validator. The return value is greater than 0 if 
status is one of VAL_SUCCESS, VAL_NONEXISTENT_NAME, VAL_NONEXISTENT_TYPE,
VAL_NONEXISTENT_NAME_NOCHAIN, VAL_NONEXISTENT_TYPE_NOCHAIN,
VAL_PROVABLY_UNSECURE, VAL_IGNORE_VALIDATION, VAL_TRUSTED_ZONE,  
VAL_LOCAL_ANSWER, VAL_TRUSTED_ANSWER, or VAL_VALIDATED_ANSWER 
and is equal to 0 for other status values.  </t>

      <t> The val_isvalidated() function returns a single boolean value
that indicates if the answer cryptographically chains down from a configured 
trust anchor.  The return value is greater than 0 if 
status is one of VAL_SUCCESS, VAL_NONEXISTENT_NAME, VAL_NONEXISTENT_TYPE, or VAL_VALIDATED_ANSWER
and is equal to 0 for other status values.  </t>

      <t> The val_does_not_exist() function returns a single boolean value
that indicates if the given validation status represents one of the non-existence types. 
The return value is greater than 0 if status is one of VAL_NONEXISTENT_TYPE,
VAL_NONEXISTENT_NAME, VAL_NONEXISTENT_NAME_NOCHAIN, or VAL_NONEXISTENT_TYPE_NOCHAIN. </t>

    <t> An application may also inspect the exact validation status 
 in order to determine trustworthiness of data. 
 The p_val_status() function can be used to convert the validation status information 
into an ASCII string format. The returned values are string representations of the
definitions given in <xref target="val-status"/>. </t> 

      </postamble>
      </figure>
    </section>

  </section><!-- DNSSEC Awareness in Applications -->

  <section title="High-level Validator API" anchor="high_level_api">
  <!--            ######################### -->

<t> The high-level validator API provides DNSSEC-aware substitutes for commonly
used DNS functions such as gethostbyname(), getaddrinfo(), res_query() and res_search().
The high-level API provides an easy path for applications already using legacy functions
to transition towards becoming DNSSEC-aware.  </t>

<t> The ctx parameter in the following functions points
to the validator context. An application may either pass a context created using the 
val_create_context() function (<xref target="val-context"/>) or may use an internally 
created default context by supplying a NULL value. </t> 

    <section title="val_gethostbyname, val_gethostbyname_r, val_gethostbyaddr, val_gethostbyaddr_r">
    <figure>
      <artwork>
#include &lt;validator.h&gt;

struct hostent *val_gethostbyname( const val_context_t *ctx,
                                   const char          *name,
                                   val_status_t        *val_status );

int val_gethostbyname_r( const val_context_t *ctx,
                         const char          *name,
                         struct hostent      *ret,
                         char                *buf,
                         size_t              buflen,
                         struct hostent      **result,
                         int                 *h_errnop,
                         val_status_t        *val_status ); 

struct hostent *val_gethostbyaddr( const val_context_t *ctx,
                                   const char          *addr,
                                   int                 len,
                                   int                 type,
                                   val_status_t        *val_status );

int val_gethostbyaddr_r( const val_context_t *ctx,
                         const char          *addr,
                         int                 len,
                         int                 type,
                         struct hostent      *ret,
                         char                *buf,
                         int                 buflen,
                         struct hostent      **result,
                         int                 *h_errnop,
                         val_status_t        *val_status );
      </artwork>
      <postamble>
<t>The val_gethostbyname(), val_gethostbyname_r(), val_gethostbyaddr() 
and val_gethostbyaddr_r() functions are DNSSEC-aware versions of the 
gethostbyname(), gethostbyname_r(), gethostbyaddr() and gethostbyaddr_r() 
legacy functions that also return the validation status of DNS responses.
These functions must be only used when retrofitting DNSSEC in applications
that use the above legacy functions to perform address-to-name and name-to-address 
translations.  It is recommended that new applications that need to perform 
address-to-name and name-to-address translations use the functions from 
<xref target="hl_getaddrinfo"/>. </t>

<t> The val_gethostbyname() function returns a pointer to a structure of
type hostent for the host name provided in name.  If name is an IPv4 address 
(in standard dot notation) or an IPv6 address (in colon and possibly dot 
notation), no lookup is performed and val_gethostbyname() simply copies name 
into h_name and its struct in-addr equivalent into the h_addr_list[0] field 
of the returned hostnet structure. </t>

<t> The val_gethostbyaddr() function returns a pointer to a structure of 
type hostent for the given host address, addr, whose length is given by 
the len parameter and address type is given by the type parameter. 
Valid address types are AF_INET and AF_INET6.  </t> 

<t> As with gethostbyname() and gethostbyaddr(), the val_gethostbyname() and
val_gethostbyaddr() functions set the value of the global h_errno variable
and return NULL on errors and return a pointer to a static hostent structure on 
success. </t> 

<t> The return values from val_gethostbyname() and val_gethostbyaddr() point to 
static data, which may be overwritten by subsequent calls. 
The val_gethostbyname_r() and val_gethostbyaddr_r() functions are
reentrant and thread-safe versions of the val_gethostbyname() and 
val_gethostbyaddr() functions.  These functions return 0 on success, 
and a non-zero value on error. These functions do not modify the global h_errno variable, 
but return the error numbers in the h_errnop parameter. 
When these functions return, the value of result will be NULL on error or point to the ret paramter 
on success.  Auxiliary data, which supplies the memory allocated for the returned hostent structure, 
is stored in the buffer buf of length buflen. If the buffer is too small, these functions will
return the error ERANGE.  </t>

<t> The val_status parameter contains the status of DNSSEC
validation. Possible values for this type are VAL_TRUSTED_ANSWER, 
VAL_VALIDATED_ANSWER and VAL_UNTRUSTED_ANSWER.  
A validation status of VAL_TRUSTED_ANSWER or VAL_VALIDATED_ANSWER is 
returned only if the validation status values for the address, and canonical name(s) within the 
hostent structure, if present, are themselves of the type VAL_TRUSTED_ANSWER or VAL_VALIDATED_ANSWER
respectively.  The trustworthiness of val_status 
can be easily determined using the functions described in <xref target="val-istrusted"/>. 
The validation status value can be converted into
an ASCII string using the p_val_status() function as described in
<xref target="val-istrusted"/>. </t>

      </postamble>
    </figure>
    </section>

    <section title="val_getaddrinfo, val_getnameinfo, val_freeaddrinfo" anchor="hl_getaddrinfo">
    <figure>
      <artwork>
#include &lt;validator.h&gt;

int val_getaddrinfo( const val_context_t   *ctx, 
                     const char            *nodename,
                     const char            *servname,
                     const struct addrinfo *hints,
                     struct val_addrinfo   **res ,
                     val_status_t          *val_status); 

int val_getnameinfo( const val_context_t   *ctx, 
                     const struct sockaddr *sa,
                     socklen_t             salen,
                     char                  *host,
                     size_t                hostlen,
                     char                  *serv,
                     size_t                servlen,
                     int                   flags,
                     val_status_t          *val_status );

void val_freeaddrinfo( struct val_addrinfo *ainfo );

struct val_addrinfo {
           int                 ai_flags;
           int                 ai_family;
           int                 ai_socktype;
           int                 ai_protocol;
           size_t              ai_addrlen;
           struct sockaddr     *ai_addr;
           char                *ai_canonname;
           struct val_addrinfo *ai_next;
           val_status_t        ai_val_status;
}
      </artwork>
      <postamble>
<t> The val_getaddrinfo() function returns the address and service
information for the specified domain name and service.  It is a
DNSSEC-aware version of the getaddrinfo() legacy function
(<xref target="refs.RFC3493">RFC 3493</xref>). </t>

<t> The val_getaddrinfo() function returns its results in the res parameter. 
The value of res either points to a valid val_addrinfo structure on success or is NULL 
in case of on error. The val_addrinfo structure is a 
linked list and is an augmented form of the addrinfo structure. 
It contains an additional ai_val_status field that 
represents the DNSSEC validation status for the answer represented by that 
particular element in the linked list.
The combined DNSSEC validation status value for
all answers returned by val_getaddrinfo() is returned in the val_status paramter.
The memory for the value of res is 
dynamically allocated and the caller should release 
it after use with the val_freeaddrinfo() function. The syntax and 
semantics of other parameters in val_getaddrinfo() are identical to
those specified in <xref target="refs.RFC3493"/>.  </t>

<t> The val_getnameinfo() function performs an address-to-name 
translation in a protocol independent manner.  It is a DNSSEC-aware 
version of the getnameinfo() legacy function 
(<xref target="refs.RFC3493">RFC 3493</xref>). 
This function  returns the DNSSEC validation status in the val_status 
parameter.  The syntax and semantics of other parameters in 
val_getnameinfo() are identical to that specified for getnameinfo() in 
<xref target="refs.RFC3493"/>.  </t>

<t> The val_getaddrinfo() and val_getnameinfo() functions return 0 on success and
a non-zero value on error.  Possible values for val_status and ai_val_status are 
VAL_TRUSTED_ANSWER, VAL_VALIDATED_ANSWER and VAL_UNTRUSTED_ANSWER. 
A validation status of VAL_TRUSTED_ANSWER or VAL_VALIDATED_ANSWER is                  
returned in val_status only if all the ai_val_status values in the val_addrinfo list 
are themselves VAL_TRUSTED_ANSWER or VAL_VALIDATED_ANSWER respectively.
Similarly, a validation status of VAL_TRUSTED_ANSWER or VAL_VALIDATED_ANSWER is                  
returned in ai_val_status only if the validation status values for the address, and canonical name(s)
within the given val_addrinfo structure are themselves validated or trusted respectively.
The trustworthiness of valdation status values can be easily determined using
the functions described in <xref target="val-istrusted"/>. The validation status values can be converted
into ASCII strings using the p_val_status() function as described in
<xref target="val-istrusted"/>. </t>

      </postamble>
      </figure>
    </section>

    <section title="val_query, val_res_query, val_res_search">
      <figure>
      <artwork>
#include &lt;validator.h&gt;

int val_query( const val_context_t *ctx, 
               const char          *domain_name,
               const u_int16_t     class, 
               const u_int16_t     type,
               const u_int8_t      flags, 
               struct val_response **resp); 

int val_free_response(struct val_response *resp);

int val_res_query(const val_context_t *ctx, 
                  const char          *domain_name, 
                  int                 class, 
                  int                 type,
                  u_char              *answer, 
                  int                 anslen, 
                  val_status_t        *val_status);

int val_res_search(const val_context_t *ctx, 
                  const char          *domain_name, 
                  int                 class, 
                  int                 type,
                  u_char              *answer, 
                  int                 anslen, 
                  val_status_t        *val_status);

struct val_response {
        unsigned char       *vr_response;
        int                 vr_length;
        val_status_t        vr_val_status;
        struct val_response *vr_next;
};
      </artwork>
      <postamble>
<t> The val_query() and val_res_query() functions query the name server 
for the fully qualified domain name present in the domain_name field 
of the given class and type.  In addition to the answers to the
query, they return the status of DNSSEC validation. They are intended 
as DNSSEC-aware replacements for the res_query() function.  
val_res_search() is a DNSSEC-aware substibute for the res_search() 
legacy function.</t>

<t> The flags parameter controls the scope of validation and the output 
format. When the VAL_QUERY_MERGE_RRSETS flag is specified, all RRsets in the answer
are merged into a single response and returned in the first (and only)
element of the resp linked list. The vr_response field of this element 
will have a format similar to the answer returned by res_query().
The only other flag that is defined, VAL_QUERY_DONT_VALIDATE, causes 
the validator to disable validation for the given query. </t> 

<t> The val_query() function returns 0 on success and a non-zero error 
code on failure.  On success, the memory pointed to by resp contains 
a linked-list of responses returned by the validator.  
By default, each val_response structure in the linked-list within resp 
holds a single RRset response. The format of the vr_response field 
within the val_response structure is similar to the format 
of the answer returned by res_query() and is of length vr_length. 
The vr_val_status field contains the status of DNSSEC validation 
for that particular RRset. Possible values for the validation status are
defined in <xref target="val-status"/> and may be converted into an ASCII string using
the p_val_status() function as described in <xref target="val-istrusted"/>. 
Elements within the resp linked-list may be accessed by traversing the 
list using the vr_next field. 
The memory for the value of resp is internally allocated and must be
released by the application using the val_free_response() function
when no longer needed.</t> 

<t> The val_res_query() function is semantically closer to the res_query() 
function. It internally invokes the val_query() function
supplying it with the VAL_QUERY_MERGE_RRSETS flag.  On success, the response
will be copied to answer, not to exceed the length specified in anslen. </t> 

<t> vel_res_search() functions identical to val_res_query, but in addition,
it implements the search rules controlled by any DNS search paths defined in the 
configuration system. </t>

<t> The val_res_query() and val_res_search() functions return the size of the response packet on
success and -1 on failure. The caller must check
that the returned packet size is not greater than the length of the buffer provided in anslen.
If the returned size is greater, the caller should allocate a larger buffer 
and call these functions again. </t> 

<t> The combined validation status value is returned in the val_status field.
Possible values for the val_status field are VAL_TRUSTED_ANSWER, 
VAL_VALIDATED_ANSWER and VAL_UNTRUSTED_ANSWER.
A validation status of VAL_TRUSTED_ANSWER or VAL_VALIDATED_ANSWER is                  
returned only if all the individual RRsets are themselves trusted or validated 
successfully, respectively. 
The trustworthiness of val_status can be easily determined using
the functions described in <xref target="val-istrusted"/>. The validation status value can be converted
into an ASCII string using the p_val_status() function as described in
<xref target="val-istrusted"/>. </t>

      </postamble>
      </figure>
    </section>


  </section> <!-- High-level Validator API -->

  <section title="Low-level Validator API" anchor="low_level_api">
  <!-- #################################### -->

<t> The low-level validator API provides applications with greater control and visibility 
into the validation process. The functions and data structures defined in the low-level 
validator API are summarized below. </t>

    <section title="val_resolve_and_check, val_free_result_chain, p_ac_status">
      <figure>
      <artwork>
#include &lt;validator.h&gt;

int val_resolve_and_check( const val_context_t        *context, 
                           u_char                     *domain_name_n,
                           const u_int16_t            class,
                           const u_int16_t            type, 
                           const u_int8_t             flags,
                           struct val_result_chain    **results);

void val_free_result_chain( struct val_result_chain *results);

char *p_ac_status(val_astatus_t status);

int ns_name_pton(const char   *src,
                 u_char       *dst,
                 int          dstsize);

int ns_name_pton(const u_char *src,
                 char         *dst,
                 int          dstsize);

#define MAX_PROOFS 4

struct val_result_chain {
    val_status_t                    val_rc_status;
    struct val_authentication_chain *val_rc_answer;
    int                             val_rc_proof_count;
    struct val_authentication_chain *val_rc_proofs[MAX_PROOFS];
    struct val_result_chain         *val_rc_next;
};

struct val_authentication_chain {
    val_astatus_t                   val_ac_status;
    struct val_rrset                *val_ac_rrset;
    struct val_authentication_chain *val_ac_trust;
};

struct val_rrset {
    u_int8_t        *val_msg_header;
    u_int16_t       val_msg_headerlen;
    u_int8_t        *val_rrset_name_n; 
    u_int16_t       val_rrset_class_h;
    u_int16_t       val_rrset_type_h;
    u_int32_t       val_rrset_ttl_h; 
    u_int8_t        val_rrset_section;
    struct sockaddr *val_rrset_server;
    struct rr_rec   *val_rrset_data;
    struct rr_rec   *val_rrset_sig;
};

struct rr_rec {
    u_int16_t       rr_rdata_length_h; 
    u_int8_t        *rr_rdata;  
    val_astatus     rr_status;      
    struct rr_rec   *rr_next;
};

      </artwork>
      <postamble>
<t> The val_resolve_and_check() function queries a set of name servers
for the &lt;domain_name_n, class, type&gt; tuple and then verifies and validates
the responses received.  The verification step checks the validity of the
RRSIGs while the validation step performs verification down the authentication chain
from a configured trust anchor. The context parameter points 
to the validator context. An application may explicitly create a 
context using the val_create_context() function described in 
<xref target="val-context"/>, or allow the validator to create 
one internally by specifying the value of NULL for this parameter.  
Only the VAL_QUERY_DONT_VALIDATE flag is currently defined. This flag has
the effect of ignoring validation for this name -- no authentication chain 
is constructed for this response. </t>

<t> The domain name specified in domain_name_n must be in the DNS wire format. 
Names can be converted from a normal string representation to the DNS wire format and 
vice-versa using the ns_name_pton() and ns_name_ntop() functions repectively. src contains the
data to be converted and dst contains the converted value. dstsize must be large enough 
to hold the converted value. The ns_name_pton() and
ns_name_ntop() functions return the number of bytes written to dst on 
success or -1 on failure.</t>

<t> val_resolve_and_check() returns 0 on success and an error code from 
<xref target="val-return-values"/> on failure.  The val_resolve_and_check() 
function internally allocates memory for the value of the result
parameter, which must be released after a successful call to this 
function using the val_free_result_chain() function. </t> 

<t> Answers to the query are returned in results, which is a linked-list 
of val_result_chain structures.  Each element in the linked-list corresponds 
to a distinct RRset returned in the answer section along with any 
associated proofs of non-existence.  Multiple RRs within the RRset are 
all part of the same answer. Multiple answers are possible when the 
query type is ANY or RRSIG. The val_rc_next field can be used to iterate 
through the list of all results returned by the validator.  The consolidated 
validation status value for an RRset based on the 
individual status values for all components in the authentication chain
is stored in the val_rc_status field. Possible values for val_rc_status  
are listed in <xref target="val-status"/> 
and can be converted into an ASCII string using the p_val_status()
function as described in <xref target="val-istrusted"/>. </t> 

<t> Members of the authentication chain sequence are encapsulated in the 
val_authentication_chain linked list. 
The val_rc_answer field in the val_result_chain structure points to the 
first element in the  authentication chain sequence proceeding from the 
signed record towards the trust anchor. Any proofs of non-existence
are returned in the val_rc_proofs array. val_rc_proof_count provides the 
number of proof elements that are available.  </t> 

<t> Within the val_authentication_chain structure, the val_ac_status field 
returns the validation status for the specified RRset. Possible values for 
this field are defined in <xref target="val-astatus"/>. These values can 
be displayed in a ASCII format using the p_ac_status() function. 
The val_ac_trust field points to the next element in the authentication chain
roceeding from the signed record towards the trust anchor.
For a element with type DNSKEY, the next element corresponds to a DS record 
in the parent zone and for a DS record the next element corresponds to the 
DNSKEY in the current zone. The value of val_ac_trust is NULL when the current element in the
linked list points to a valid trust anchor or when an error condition is encountered. 
The value stored in the val_ac_status field can be used to differentiate between these two cases.  </t>

<t> The val_ac_rrset field in the val_authentication_chain structure contains 
the actual RRset data.  The information stored in the val_rrset structure includes 
the DNS response header in the  val_msg_header field with 
length given by val_msg_headerlen, and the DNS response "envelope"
comprising of the name, class, type and time-to-live tuple in the 
val_rrset_name_n, val_rrset_class_h, val_rrset_type_h and val_rrset_ttl_h 
fields respectively. The val_rrset_name_n is stored in the DNS wire format.
The name servers from where these RRsets were
received is stored in the val_rrset_server field.
The section where the RRset appeared in the DNS response is saved in the 
val_rrset_section field within the val_rrset structure, and may contain one
of the following values: </t> 

        <t> <list style="hanging">
<t hangText="VAL_FROM_ANSWER:">
the RRset was present in the answer section of the DNS response.  </t>
<t> </t>
<t hangText="VAL_FROM_AUTHORITY:">
the RRset was present in the authority section of the DNS response.  </t>
<t> </t>
<t hangText="VAL_FROM_ADDITIONAL:">
the RRset was present in the additional section of the DNS response.  </t>
        </list></t>

<t> The response RDATA is stored in val_rrset_data. Any associated RRSIGs 
are stored in val_rrset_sig. Both of these variables are of type rr_rec, 
which is a list of name-value pairs for each resource-record within the RRset. 
The rr_status member in rr_rec is only relevant for the signatures present in
val_rrset_sig or when val_rrset_data points to DNSKEY or DS RRs.  
This field only takes on a subset of all status values possible for val_astatus_t
as defined in <xref target="val-astatus"/>.  </t>

      </postamble>
      </figure>
    </section>

    <section title="Authentication Chain Status Codes" anchor="val-astatus">

        <t> Resolver-related status values in val_ac_status are returned as one of the 
 values listed in <xref target="res-codes"/>, offset by the value of VAL_AC_DNS_ERROR_BASE. </t>

        <t> The verification status value stored in the val_ac_status member 
of the val_authentication_chain structure can have one of the following values:
        <list style="hanging">
<t> </t>
<t hangText="VAL_AC_UNSET:">
returned if the status was not set due to some internal error condition in the validator.  </t>
<t> </t>
<t hangText="VAL_AC_IGNORE_VALIDATION:">
returned if validation for the given resource record was ignored. </t>
<t> </t>
<t hangText="VAL_AC_TRUSTED_ZONE:">
returned if local policy defined a given zone as trusted, with no further validation 
being deemed necessary.  </t>
<t> </t>
<t hangText="VAL_AC_UNTRUSTED_ZONE:">
returned if local policy defined a given zone as untrusted, with no further validation 
being deemed necessary.  </t>
<t> </t>
<t hangText="VAL_AC_PROVABLY_UNSECURE:">
returned if the authentication chain from a trust anchor to a given zone could not be constructed
due to the provable absence of a DS record for this zone in the parent.  </t>
<t> </t>
<t hangText="VAL_AC_BARE_RRSIG:">
returned if the response was for a query of type RRSIG. RRSIGs contain the cryptographic
signatures for other DNS data and cannot themselves be validated.  </t>
<t> </t>
<t hangText="VAL_AC_NO_TRUST_ANCHOR:">
returned if there was no matching trust anchor for a given authentication chain.  </t> 
<t> </t>
<t hangText="VAL_AC_LOCAL_ANSWER:">
returned if the answer was obtained locally (for example, a file such as /etc/hosts) and
validation was not performed on the results.  </t>
<t> </t>
<t hangText="VAL_AC_TRUST_KEY:">
returned if a given DNSKEY or a DS record was locally defined to be a trust anchor.  </t>
<t> </t>
<t hangText="VAL_AC_RRSIG_MISSING:">
returned if RRSIG data could not be retrieved for a resource record.  </t>
<t> </t>
<t hangText="VAL_AC_DNSKEY_MISSING:">
returned if the DNSKEY for a zone could not be retrieved.  </t>
<t> </t>
<t hangText="VAL_AC_DS_MISSING:">
returned if the DS record covering a DNSKEY record was not available.  </t>
<t> </t>
<t hangText="VAL_AC_DATA_MISSING:">
returned if there was no data returned for a query and the DNS did not indicate an error.  </t>
<t> </t>
<t hangText="VAL_AC_UNKNOWN_DNSKEY_PROTOCOL:">
returned if the DNSKEY protocol number was unrecognized.  </t>
<t> </t>
<t hangText="VAL_AC_NOT_VERIFIED:">
returned if all RRSIGs covering an RRset could not be verified.  </t>
<t> </t>
<t hangText="VAL_AC_VERIFIED:">
returned if at least one RRSIG covering a resource record had a status of VAL_AC_RRSIG_VERIFIED.  </t>
      </list> </t>

      <t>  For each signature rr_rec member within the authentication chain 
val_ac_rrset, the validation status stored in the variable rr_status can 
return one of the following values: 
        <list style="hanging">
<t> </t>
<t hangText="VAL_AC_RRSIG_VERIFIED:">
returned if the RRSIG verified successfully.  </t>
<t> </t>
<t hangText="VAL_AC_WCARD_VERIFIED:">
returned if a given RRSIG covering a resource record 
showed that the record was wildcard expanded.  </t>
<t> </t>
<t hangText="VAL_AC_RRSIG_VERIFIED_SKEW:">
returned if the RRSIG was verified only after clock skew 
policy was taken into consideration.  </t>
<t> </t>
<t hangText="VAL_AC_WCARD_VERIFIED_SKEW:">
returned if a given RRSIG covering a resource record 
showed that the record was wildcard expanded, and if the
RRSIG was verified only after clock skew policy was taken
into consideration.  </t>
<t> </t>
<t hangText="VAL_AC_DNSKEY_NOMATCH:">
returned if an RRSIG was created by a DNSKEY that did not exist 
in the apex keyset.  </t>
<t> </t>
<t hangText="VAL_AC_WRONG_LABEL_COUNT:">
returned if the number of labels on the signature was greater 
than the the count given in the RRSIG RDATA.  </t>
<t> </t>
<t hangText="VAL_AC_BAD_DELEGATION:">
returned if an RRSIG on the DNSKEY was created with a key that did not exist 
in the parent DS record set.  </t>
<t> </t>
<t hangText="VAL_AC_INVALID_RRSIG:">
returned if the RRSIG could not be parsed.  </t>
<t> </t>
<t hangText="VAL_AC_RRSIG_NOTYETACTIVE:">
returned if the RRSIG's inception time was in the future.  </t>
<t> </t>
<t hangText="VAL_AC_RRSIG_EXPIRED:">
returned if the RRSIG had expired.  </t>
<t> </t>
<t hangText="VAL_AC_ALGORITHM_NOT_SUPPORTED:">
returned if the RRSIG algorithm was not supported.  </t>
<t> </t>
<t hangText="VAL_AC_UNKNOWN_ALGORITHM:">
returned if the RRSIG algorithm was unknown.  </t>
<t> </t>
<t hangText="VAL_AC_RRSIG_VERIFY_FAILED:">
returned if a given RRSIG covering an RRset was bogus.  </t>
<t> </t>
<t hangText="VAL_AC_ALGORITHM_REFUSED:">
returned if the RRSIG algorithm was not allowed as per local policy.  </t>
<t> </t>
<t hangText="VAL_AC_RRSIG_ALGORITHM_MISMATCH:">
returned if the keytag referenced in the RRSIG matched a DNSKEY 
but the algorithms were different. </t>
      </list> </t>

      <t>  For each rr_rec member of type DNSKEY (or DS where relevant) 
within the authentication chain val_ac_rrset, the validation status 
stored in the variable rr_status can return one of the following values: 
        <list style="hanging">
<t> </t>
<t hangText="VAL_AC_SIGNING_KEY:">
returned if this DNSKEY was used to create an RRSIG for the resource record set.  </t>
<t> </t>
<t hangText="VAL_AC_VERIFIED_LINK:">
returned if this DNSKEY provided the link in the authentication chain from 
the trust anchor to the signed record.  </t>
<t> </t>
<t hangText="VAL_AC_UNKOWN_ALGORITHM_LINK:">
returned if this DNSKEY formed a link in the authentication chain from 
the trust anchor to the signed record, but the DNSKEY algorithm was unknown.  </t>
<t> </t>
<t hangText="VAL_AC_INVALID_KEY:">
returned if the key used to verify the RRSIG was not valid DNSKEY.  </t>
<t> </t>
<t hangText="VAL_AC_ALGORITHM_NOT_SUPPORTED:">
returned if the DNSKEY or DS algorithm was not supported.  </t>
<t> </t>
<t hangText="VAL_AC_UNKNOWN_ALGORITHM:">
returned if the DNSKEY or DS algorithm was unknown.  </t>
<t> </t>
<t hangText="VAL_AC_KEY_TOO_LARGE:">
returned if local policy defined the DNSKEY size as being too large.</t>
<t> </t>
<t hangText="VAL_AC_KEY_TOO_SMALL:">
returned if local policy defined the DNSKEY size as being too small.  </t>
<t> </t>
<t hangText="VAL_AC_KEY_NOT_AUTHORIZED:">
returned if local policy defined the DNSKEY to be unauthorized for validation.  </t>
<t> </t>
<t hangText="VAL_AC_ALGORITHM_REFUSED:">
returned if the DNSKEY or DS algorithm was not allowed as per local policy.  </t>
      </list> </t>
    </section>

  </section> <!-- Low-level API -->

  <section title="Context Management and Validator Policy API" anchor="val-context">
  <!--            ####################################### -->

<t> Applications can use local policy to influence the validation outcome. 
Examples of local policy elements include trust anchors for 
different zones and untrusted algorithms for cryptographic keys and hashes.
Local policy may be different for different applications and operating scenarios. The
following subsections describe how applications may be able to customize their
policies for DNSSEC validation.</t> 

    <section title="Configuring Validator Policy">
<t> Local policy for the validator is stored in the local 
configration system (typically the configuration file, /etc/dnsval.conf).  
Policies are identified by simple text strings called labels, which must be 
unique within the configuration system. As an example, "browser" could be used 
as the label that defines the validator policy for all web-browsers in a
system.  A label value of ":" identifies the "default" policy, or the 
policy that is used when a NULL context is specified as the ctx parameter.
The default policy is unique within the configuraion system.
Furthermore, the ':' character is only allowed in the default policy label.
The configuration system must flag an error if some other label contains the 
':' character. If the policy identified by the ':' label does not exist in the
configuration system, the first policy in the configuration system is used
as the default policy.</t>

<t> Policy definitions have the following structure.  </t> 
<t> &lt;label&gt; &lt;attribute&gt; &lt;additional-data&gt;; </t>
<t> Possible values for &lt;attribute&gt; are "trust-anchor",
"zone-security-expectation", "provably-unsecure-status",
"clock-skew".  The value for &lt;additional-data&gt; 
depends on the type of attribute specified.  </t>

<t><list style="symbols">
<t>For the "trust-anchor" attribute additional-data is a sequence of the 
zone name and a quoted string containing the RDATA portion for the 
trust anchor's DNSKEY. An example is given below. 
    <figure>
    <artwork>
    browser trust-anchor 
        example.com   "257 3 5 AQO8XS4y9r77X 9SHBmrx MoJf1Pf9\
            AT9Mr/L5BBGtO9/e9f/zl4FFgM2l B6M2 XEm6mp6 mit4tzp\
            B/sAEQw1McYz6bJdKkTiqtuWTCfDmgQhI6 /Ha0 Ef GPNSqn\
            Y 99FmbSeWNIRaa4fgSCVFhvbrYq1nXkNVy QPeEVHk oDNCA\
            lr qOA3lw==" 
        example.org   "257 3 5 AQO8XS4y9r77X 9SHBmrx MoJf1Pf9\
            AT9Mr/L5BBGtO9/e9f/zl4FFgM2l B6M2 XEm6mp6 mit4tzp\
            B/sAEQw1McYz6bJdKkTiqtuWTCfDmgQhI6 /Ha0 Ef GPNSqn\
            Y 99FmbSeWNIRaa4fgSCVFhvbrYq1nXkNVy QPeEVHk oDNCA\
            lr qOA3lw==" 
        ;
    </artwork>
    <postamble>
    </postamble>
    </figure>
</t>
</list> </t>

<t><list style="symbols">
<t>For the "zone-security-expectation" attribute additional-data 
is a sequence of  &lt;domain name,value&gt; tuples representing the 
security expectation for names in that domain, as defined below.
        <list style="hanging">
            <t></t>
            <t hangText="ignore:">
            Ignore validation for names under this domain.  </t>
            <t hangText="trusted:">
            Trust all answers received for names under this domain.  </t>
            <t hangText="validate:">
            Perform validation of answers received for names under this domain.  </t>
            <t hangText="untrusted:">
            Reject all answers received for names under this domain.  </t>
            <t></t>
        </list> 
This zone-security-expectation policy construct makes it possible to define 
various islands of trust for DNSSEC-enabled zones and to 
ignore or trust data from selected zones. The default zone
security expectation for a domain is "validate".
In the following example, for validator contexts created with a policy label of "browser",
the DNSSEC validation is only performed for names 
under the example.com domain; names under the somebogus.org domain are always
considered to be untrused and validation for all other domain names is ignored. 
    <figure>
    <artwork>
    browser zone-security-expectation           
        example.com  validate       
        somebogusname.org untrusted 
        . ignore
        ; 
    </artwork>
    <postamble>
    </postamble>
    </figure>
</t> 
</list> </t> 

<t><list style="symbols">
<t>
For the "provably-unsecure-status" attribute additional-data is a sequence 
of  &lt;domain name,value&gt; tuples representing the trustworthiness of the 
provably insecure condition, as defined below.
        <list style="hanging">
            <t></t>
            <t hangText="trusted:">
            Treat the provably insecure condition as trustworthy .  </t>
            <t hangText="untrusted:">
            Treat the provably insecure condition as untrustworthy .  </t>
            <t></t>
        </list> 
The default value for the provably unsecure status for a domain is "trusted".
In the following example, for validator contexts created with the default label, 
the provably insecure condition is treated as trustworthy for all domains except the net domain, 
where this condition is treated as untrustworthy.
    <figure>
    <artwork>
    : provably-unsecure-status
        . trusted
        net untrusted
        ;
    </artwork>
    <postamble>
    </postamble>
    </figure>
</t>
</list> </t> 

<t><list style="symbols">
<t>
For the "clock-skew" attribute additional-data is a sequence of the
domain name and the number of seconds of clock-skew acceptible for signatures
on names in that domain. A clock skew value of -1 has the effect of turning off
inception and expiration time checks on signatures from that domain. The default clock 
skew is 0.
In the following example, for validator contexts created with the "mta" label, signature 
inception and expiration checks are disabled for all names under the example.com domain.
    <figure>
    <artwork>
    mta clock-skew
        example.com -1 
        ;
    </artwork>
    <postamble>
    </postamble>
    </figure>
</t>
</list> </t> 

    </section>

    <section title="val_create_context, val_free_context">
      <figure>
      <artwork>
#include &lt;validator.h&gt;

int val_create_context( const char    *scope,
                     val_context_t **newcontext );

void val_free_context( val_context_t *context );
      </artwork>
      <postamble>
<t> The val_create_context() creates a new validator context.
The scope parameter identifies the policy to be used 
for validation.  Policy scopes have a 
hierarchical organization, with each member in the hierarchy identifying 
a policy label in the configuration system separated by the ':' character. 
The validator forms an effective policy by cumulatively applying the policies
for each label specified in the policy scope. For example, for the policy scope 
"mozilla:browser", the effective policy is computed by applying policies 
for the default, "browser" and "mozilla" policies, in that order. 
A NULL scope creates a context with the default policy. </t>

<t>The val_create_context() function returns 0 on success, 
and an error code from <xref target="val-return-values"/> on failure. 
The newly created context is returned in the newcontext field.
A NULL context is returned if an error is encountered.  
The memory allocated for context must be released by the application 
using the val_free_context() function when no longer needed. </t> 

    </postamble>
    </figure>
    </section>

    <section title="val_add_valpolicy, val_remove_valpolicy">
      <figure>
      <artwork>
#include &lt;validator.h&gt;

int val_add_valpolicy(val_context_t *context, 
                  const char *keyword,
                  char *zone, char *value, long ttl,
                  val_policy_entry_t **pol);

int val_remove_valpolicy(val_context_t *context, 
                  val_policy_entry_t *pol);
      </artwork>
      <postamble>
<t>The val_add_valpolicy() function allows an application to add a new policy 
definition to an existing validator context. The keword and value fields are 
as described in above. A timeout can be attached to the policy
definition, with -1 specifying an indefinite timeout interval. After the timeout 
interval, the effects of the newly added policy is ignored. A handle to the newly 
added policy is returned in *pol, which is a pointer to the val_policy_entry_t structure. 
This structure is opaque to the applications; applications must not modify the contents of
the val_policy_entry_t structure. </t>

<t> Applications may also revoke the effects of a newly added policy before the expiry 
of its timeout interval using the val_remove_valpolicy() function. The handle to the policy
that must be removed from the context is specified in pol. </t>

<t> The above functions return 0 on success and an error code from 
<xref target="val-return-values"/> on failure.  </t>
    </postamble>
    </figure>
    </section>

    </section> <!-- Context Management -->

    
    <section title="Function Return Values" anchor="val-return-values">
    <!--            ####################### -->

<t> The following values may be returned by functions in the low-level API, 
context-management API, and some functions in the high-level APIs. 
Most High-level API functions mirror existing legacy
DNS-related functions, so the return values from these functions are
identical to their predecessors.</t>

        <t> <list style="hanging">
<t hangText="VAL_NO_ERROR:">
returned if the call was successful.  </t>
<t> </t>
<t hangText="VAL_NOT_IMPLEMENTED:">
returned if the implementation did not support a particular feature.  </t>
<t> </t>
<t hangText="VAL_RESOURCE_UNAVAILABLE:">
returned if some resource necessary for an operation was unavailable.  </t>
<t> </t>
<t hangText="VAL_BAD_ARGUMENT:">
returned if an unexpected value was passed as an argument to a function.  </t>
<t> </t>
<t hangText="VAL_INTERNAL_ERROR:">
returned if an internal error was encountered in the validator library.  </t>
<t> </t>
<t hangText="VAL_NO_PERMISSION:">
returned if the application lacked sufficient privileges to perform an operation.  </t>
<t> </t>
<t hangText="VAL_CONF_PARSE_ERROR:">
returned if the validator configuration was improperly specified in the 
configuration system.  </t>
<t> </t>
<t hangText="VAL_CONF_NOT_FOUND:">
returned if the validator configuration could not be located in the 
configuration system.  </t>
<t> </t>
<t hangText="VAL_NO_POLICY:">
returned if the policy identifier being referenced was invalid. </t>
        </list></t>

<t> The p_val_err() function returns an ASCII representation for the above
error values. This function has the following prototype. </t>
        
      <figure>
      <artwork>
#include &lt;validator.h&gt;

const char *p_val_err(int err);
      
      </artwork>
      <postamble>
    </postamble>
    </figure>
   </section> <!-- Return Values -->

   <section title="IANA Considerations">
   <t> This document has no actions for IANA.</t>
   </section> <!-- IANA Considerations -->

   <section title="Security Considerations" anchor="security-considerations">
<t> The validator API functions return a status of VAL_LOCAL_ANSWER if the
the answer to a given query is returned from the local configuration system 
(for example, from the /etc/hosts file).  The
application cannot assume that these answers are trustworthy, unless the
application is certain that local data (such the /etc/hosts file) is also trustworthy.
If this information is modified during a DHCP lookup, for example, the client
system should ensure that the DHCP server is a trusted source, and that the
communication path between the DHCP server and the client system is secured. 
 If these conditions are not satisfied and if the application chooses to trust
a validation status of VAL_LOCAL_ANSWER, there exists a potential attack vector
whereby an attacker can poison the configuration system and an application using
this API may trust the result.  </t>

<t> Applications can choose to trust data from provably unsecure zones.
The same effect is observed if a VAL_FLAGS_DONT_VALIDATE flag is passed to
the val_resolve_and_check() function. Not performing validation and having a 
zone that has DNSSEC intentionally turned off is no worse than the current 
situation of DNSSEC-unaware applications not being able to detect the integrity
of DNS data. </t>

<t> The DNS search path may affect the result of validation, especially in
the current Internet environment where not all DNS name servers are
expected to be DNSSEC-aware.  If the name server pointed to by the configuration system 
is not DNSSEC-aware (i.e. it does not return DNSSEC records), validation will not 
be performed. The list of default name servers (such as in the file /etc/resolv.conf file) 
is typically modified by DHCP clients.  Hence,
if the client system uses DHCP, it must ensure that the DHCP server
is a trusted source, and that the communication path between the DHCP server
and the client system is secured.  </t>

<t> The validator configuration information needs to be protected 
so that it cannot be overwritten by unauthorized users or processes. 
The system administrator must ensure that the list of trust anchors are kept
up-to-date in the event of key-rollovers.  If the trust anchors are outdated,
the validator may not be able to perform validation or may 
create the false impression of having successfully validated a response when 
it should have been flagged as bogus.  </t>
   </section> <!-- Security Considerations -->

   <section title="Acknowledgements">
   <t>The following individuals have provided
valuable feedback and suggestions for improving this document: Lindy Foster,
Wayne Morrison, Russ Mundy, Bill Sommerfeld, Robert Story, Wes Hardaker.  
The list of authentication status codes in <xref target="val-astatus"/> was 
generated through multiple brainstorming sessions at the IETF meetings. 
This draft draws on the results from that effort.</t>
   </section> <!-- Acknowledgements -->

   </middle>
   <back>
        <references title="Normative References">
            <reference anchor="refs.RFC3493">
              <front>
                <title>Basic Socket Interface Extensions for IPv6</title>
                <author initials="R." surname="Gilligan" fullname="Bob Gilligan" />
                <author initials="S." surname="Thomson" fullname="Susan Thomson" />
                <author initials="J." surname="Bound" fullname="Jim Bound" />
                <author initials="J." surname="McCann" fullname="Jack McCann" />
                <author initials="W." surname="Stevens" fullname="W. Richard Stevens" />
                <date month="February" year="2003" />
              </front>
              <seriesInfo name="RFC" value="3493" />
            </reference>
            <reference anchor="refs.RFC4033">
              <front>
                <title>DNS Security Introduction and Requirements</title>
                <author initials="R." surname="Arends" fullname="Roy Arends" />
                <author initials="R." surname="Austein" fullname="Rob Austein" />
                <author initials="M." surname="Larson" fullname="Matt Larson" />
                <author initials="D." surname="Massey" fullname="Dan Massey" />
                <author initials="S." surname="Rose" fullname="Scott Rose" />
                <date month="March" year="2005" />
              </front>
              <seriesInfo name="RFC" value="4033" />
            </reference>
            <reference anchor="refs.RFC4034">
              <front>
                <title>Resource Records for the DNS Security Extensions</title>
                <author initials="R." surname="Arends" fullname="Roy Arends" />
                <author initials="R." surname="Austein" fullname="Rob Austein" />
                <author initials="M." surname="Larson" fullname="Matt Larson" />
                <author initials="D." surname="Massey" fullname="Dan Massey" />
                <author initials="S." surname="Rose" fullname="Scott Rose" />
                <date month="March" year="2005" />
              </front>
              <seriesInfo name="RFC" value="4034" />
            </reference>
            <reference anchor="refs.RFC4035">
              <front>
                <title>Protocol Modifications for the DNS Security Extensions</title>
                <author initials="R." surname="Arends" fullname="Roy Arends" />
                <author initials="R." surname="Austein" fullname="Rob Austein" />
                <author initials="M." surname="Larson" fullname="Matt Larson" />
                <author initials="D." surname="Massey" fullname="Dan Massey" />
                <author initials="S." surname="Rose" fullname="Scott Rose" />
                <date month="March" year="2005" />
              </front>
              <seriesInfo name="RFC" value="4035" />
            </reference>
        </references>
        <!-- Appendices
        <section ...>
        <section ...>
        -->
    </back>
</rfc>

<!-- last updated Oct. 18, 2006 -->

