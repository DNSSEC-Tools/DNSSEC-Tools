.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "val_query 3"
.TH val_query 3 "2007-04-26" "perl v5.8.8" "Programmer's Manual"
.SH "NAME"
\&\fIval_query()\fR, \fIval_res_query()\fR, \fIval_res_search()\fR \- DNSSEC\-validated resolution of DNS queries
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  #include <validator.h>
.Ve
.PP
.Vb 6
\&  int val_query(const val_context_t *ctx,
\&            const char *dname,
\&            const u_int16_t class,
\&            const u_int16_t type,
\&            const u_int8_t flags,
\&            struct val_response **resp);
.Ve
.PP
.Vb 1
\&  int val_free_response(struct val_response *resp);
.Ve
.PP
.Vb 7
\&  int val_res_query(const val_context_t *ctx,
\&                    const char *dname,
\&                    int class,
\&                    int type,
\&                    u_char *answer,
\&                    int anslen,
\&                    val_status_t *val_status);
.Ve
.PP
.Vb 7
\&  int val_res_search(val_context_t * ctx, 
\&            const char *dname,
\&            int class_h, 
\&            int type, 
\&            u_char * answer,
\&            int anslen, 
\&            val_status_t * val_status);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fI\fIval_query()\fI\fR and  \fI\fIval_res_query()\fI\fR functions perform \s-1DNSSEC\s0 validation
of \s-1DNS\s0 queries.  They are DNSSEC-aware substitutes for \fI\fIres_query\fI\|(3)\fR. 
\&\fI\fIval_res_search()\fI\fR is a DNSSEC-aware substibute for the \fI\fIres_search\fI\|(3)\fR function.
.PP
The \fIctx\fR parameter is the validator context and can be set to \s-1NULL\s0 for
default settings.  More information about this field can be found in
\&\fI\fIlibval\fI\|(3)\fR.
.PP
The \fIdname\fR parameter specifies the domain name, \fIclass\fR specifies the
\&\s-1DNS\s0 class and \fItype\fR specifies the \s-1DNS\s0 type.
.PP
The \fI\fIval_query()\fI\fR function returns results in the \fIresp\fR linked-list which
encapsulates the results into the following structure:
.PP
.Vb 6
\&  struct val_response {
\&        unsigned char *vr_response;
\&        int vr_length;
\&        val_status_t vr_val_status;
\&                struct val_response *vr_next;
\&  };
.Ve
.PP
The \fIvr_response\fR and \fIvr_length\fR fields are functionally similar to the
\&\fIanswer\fR and \fIanslen\fR parameters in \fI\fIres_query\fI\|(3)\fR.  Memory for the 
\&\fIresp\fR linked-list is internally allocated and must be released after
a successful invocation of the function using the \fI\fIval_free_response()\fI\fR
function. Each element in the \fIresp\fR linked list
will contain an answer corresponding to a single RRSet in the \s-1DNS\s0 reply.
.PP
The validation status is returned in the \fIvr_val_status\fR field of 
the \fIval_response\fR structure for that RRSet. \fI\fIp_val_status()\fI\fR returns a 
brief string description of the error code.
\&\fI\fIval_istrusted()\fI\fR determines if the status code indicates that the response
can be trusted and \fI\fIval_isvalidated()\fI\fR determines if the status code indicates that the
response was validated.  (See \fI\fIlibval\fI\|(3)\fR for further information).
.PP
The \fIflags\fR parameter controls the scope of validation and name resolution,
and the output format.  Three values, which may be ORd together, are currently 
defined for this field. The \fB\s-1VAL_QUERY_MERGE_RRSETS\s0\fR flag is provided for 
applications that wish to merge all rrsets into a single
response returned in the first element of the \fIresp\fR array.  The response
field of this element will have a format similar to the answer returned by
\&\fI\fIres_query\fI\|(3)\fR.  The \fB\s-1VAL_QUERY_DONT_VALIDATE\s0\fR flag causes the validator to 
disable validation for this query, and the \fB\s-1VAL_QUERY_NO_DLV\s0\fR flag causes 
the validator to disable \s-1DLV\s0 processing for this query. The last flag is 
only available if the \fI\fIlibval\fI\|(3)\fR library has been compiled with \s-1DLV\s0 support.
.PP
\&\fI\fIval_res_query()\fI\fR is provided as a closer substitute for \fI\fIres_query\fI\|(3)\fR. It
calls \fI\fIval_query()\fI\fR internally with the \fB\s-1VAL_QUERY_MERGE_RRSETS\s0\fR flag and
returns the answers in the field answer with length of \fIanslen\fR. 
.PP
\&\fI\fIval_res_search()\fI\fR performs an operation similar to \fI\fIval_res_query()\fI\fR. 
In addition, it uses the search paths specified within the \fB/etc/resolv.conf\fR
file to create the fully qualified domain name.
.PP
The validation status values for \fI\fIval_res_query()\fI\fR and \fI\fIval_res_search()\fI\fR
functions are returned in their respective \fIval_status\fR fields.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
The \fI\fIval_query()\fI\fR function returns 0 on success.  This function internally
invokes \fI\fIresolve_n_check()\fI\fR and errors from this function may be returned.
.PP
\&\fI\fIval_res_query()\fI\fR and \fI\fIval_res_search()\fI\fR return the number of bytes received on
success and \-1 on failure.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 5
\& #include <stdio.h>
\& #include <stdlib.h>
\& #include <strings.h>
\& #include <arpa/nameser.h>
\& #include <validator.h>
.Ve
.PP
.Vb 2
\& #define BUFLEN 8096
\& #define RESPCOUNT 3
.Ve
.PP
.Vb 7
\& int main(int argc, char *argv[])
\& {
\&          int retval;
\&              int i;
\&          int class = ns_c_in;
\&          int type = ns_t_a;
\&          struct val_response *resp, *iter;
.Ve
.PP
.Vb 4
\&          if (argc < 2) {
\&                  printf("Usage: %s <domain-name>\en", argv[0]);
\&                  exit(1);
\&          }
.Ve
.PP
.Vb 1
\&          retval = val_query(NULL, argv[1], class, type, 0, &resp);
.Ve
.PP
.Vb 6
\&          if (retval == 0) {
\&                  for (iter=resp; iter; iter=iter->vr_next) {
\&                          printf("Validation Status = %d [%s]\en", iter->vr_val_status,
\&                                 p_val_status(iter->vr_val_status));
\&                  }
\&          }
.Ve
.PP
.Vb 1
\&          free_val_response(resp);
.Ve
.PP
.Vb 2
\&          return 0;
\& }
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2004\-2007 \s-1SPARTA\s0, Inc.  All rights reserved.
See the \s-1COPYING\s0 file included with the DNSSEC-Tools package for details.
.SH "AUTHORS"
.IX Header "AUTHORS"
Abhijit Hayatnagarkar, Suresh Krishnaswamy, Robert Story.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fI\fIres_query\fI\|(3)\fR
.PP
\&\fI\fIget_context\fI\|(3)\fR, \fI\fIval_getaddrinfo\fI\|(3)\fR, \fI\fIval_gethostbyname\fI\|(3)\fR
.PP
\&\fI\fIlibval\fI\|(3)\fR
.PP
http://dnssec\-tools.sourceforge.net
