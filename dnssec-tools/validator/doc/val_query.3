.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "val_query 3"
.TH val_query 3 "2006-11-07" "perl v5.8.6" "Programmer's Manual"
.SH "NAME"
val_query \- DNSSEC\-validated resolution of DNS queries
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  #include <validator.h>
.Ve
.PP
.Vb 6
\&  int val_query(const val_context_t *ctx,
\&                const char *dname,
\&                const u_int16_t class,
\&                const u_int16_t type,
\&                const u_int8_t flags,
\&                struct val_response **resp);
.Ve
.PP
.Vb 1
\&  int val_free_response(struct val_response *resp);
.Ve
.PP
.Vb 2
\&  int val_res_query(const val_context_t *ctx, const char *dname, int class, int type,
\&        u_char *answer, int anslen, val_status_t *val_status);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fB\f(BIval_query()\fB\fR and \fB\f(BIval_res_query()\fB\fR functions are DNSSEC-aware substitutes for \fB\f(BIres_query\fB\|(3)\fR.
They perform \s-1DNSSEC\s0 validation of \s-1DNS\s0 queries.
.PP
The \fIctx\fR parameter is the validator context and can be set to \s-1NULL\s0 for
default settings.  More information about this field can be found in
\&\fB\f(BIlibval\fB\|(3)\fR.
.PP
The \fIdname\fR parameter specifies the domain name, \fIclass\fR specifies the
\&\s-1DNS\s0 class and \fItype\fR specifies the \s-1DNS\s0 type.
.PP
The \fB\f(BIval_query()\fB\fR function returns results in the \fIresp\fR linked-list which
encapsultes the results into the following structure:
.PP
.Vb 6
\&  struct val_response {
\&        unsigned char *vr_response;
\&        int vr_length;
\&        val_status_t vr_val_status;
\&                struct val_response *vr_next;
\&  };
.Ve
.PP
\&\fIvr_response\fR and \fIvr_length\fR fields are functionally similar to the
\&\fIanswer\fR and \fIanslen\fR parameters in \fB\f(BIres_query\fB\|(3)\fR.  Memory for the 
\&\fIresp\fR linked-list is internally allocated and must be released after
a successful invocation of the function using the \fIval_free_response()\fR function. 
Each element in the \fIresp\fR linked-list
will contain an answer corresponding to a single RRSet in the \s-1DNS\s0 reply.
.PP
If \s-1DNSSEC\s0 validation succeeds for a given RRSet, a value of
\&\fB\s-1VAL_SUCCESS\s0\fR is returned in the \fIvr_val_status\fR field of the
\&\fIval_response\fR structure for that RRSet. Other values are returned in case
of errors.  See \fBval_errors.h\fR for a listing of possible error codes.  The
\&\fB\f(BIp_val_status()\fB\fR function can be used to return a brief string description
of the error code.  The \fB\f(BIval_istrusted()\fB\fR function can be used to determine
if the error code represents a value which indicates that the response can
be trusted (see \fB\f(BIlibval\fB\|(3)\fR for further information).
.PP
The \fIflags\fR parameter controls the scope of validation and name
resolution, and the output format.  At present only one flag is
defined: \fB\s-1VAL_QUERY_MERGE_RRSETS\s0\fR.  This flag has been provided for
legacy applications that already use \fB\f(BIres_query\fB\|(3)\fR and want to
transition to \fB\f(BIval_query()\fB\fR with minimal change.  When this flag is
specified, all RRsets in the answer are merged into a single response
and returned in the first element of the \fIresp\fR array.  The response
field of this element will have a format similar to the answer
returned by \fB\f(BIres_query\fB\|(3)\fR.  The validation status will be
\&\fB\s-1VAL_SUCCESS\s0\fR only if all the individual RRsets have been
successfully validated.  Otherwise, the validation status will be one
of the other error codes.  Note that if a value other than
\&\fB\s-1VAL_SUCCESS\s0\fR is returned and if multiple RRsets are present in
the answer, it is not possible to know which RRset resulted in the
error status, if this flag is used.
.PP
The \fB\f(BIval_res_query()\fB\fR function is provided as a closer substitute
for \fIres_query\fR\|(3). It calls \fIval_query()\fR internally with the 
\&\s-1VAL_QUERY_MERGE_RRSETS\s0 flag and returns the answers in the field 
answer with length of anslen. The validation status is returned in the
field val_status. 
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
The \fB\f(BIval_query()\fB\fR function returns 0 on success.  
This function internally invokes \fB\f(BIresolve_n_check()\fB\fR, 
and errors from this function may be returned.
.PP
The \fB\f(BIval_res_query()\fB\fR function returns the number of bytes received on 
success and \-1 on failure. 
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 5
\& #include <stdio.h>
\& #include <stdlib.h>
\& #include <strings.h>
\& #include <arpa/nameser.h>
\& #include <validator.h>
.Ve
.PP
.Vb 2
\& #define BUFLEN 8096
\& #define RESPCOUNT 3
.Ve
.PP
.Vb 7
\& int main(int argc, char *argv[])
\& {
\&          int retval;
\&              int i;
\&          int class = ns_c_in;
\&          int type = ns_t_a;
\&          struct val_response *resp, *iter;
.Ve
.PP
.Vb 4
\&          if (argc < 2) {
\&                  printf("Usage: %s <domain-name>\en", argv[0]);
\&                  exit(1);
\&          }
.Ve
.PP
.Vb 1
\&          retval = val_query(NULL, argv[1], class, type, 0, &resp);
.Ve
.PP
.Vb 6
\&          if (retval == 0) {
\&                  for (iter=resp; iter; iter=iter->vr_next) {
\&                          printf("Validation Status = %d [%s]\en", iter->vr_val_status,
\&                                 p_val_status(iter->vr_val_status));
\&                  }
\&          }
.Ve
.PP
.Vb 1
\&          free_val_response(resp);
.Ve
.PP
.Vb 2
\&          return 0;
\& }
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2004\-2006 \s-1SPARTA\s0, Inc.  All rights reserved.
See the \s-1COPYING\s0 file included with the DNSSEC-Tools package for details.
.SH "AUTHORS"
.IX Header "AUTHORS"
Abhijit Hayatnagarkar, Suresh Krishnaswamy.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fB\f(BIres_query\fB\|(3)\fR
.PP
\&\fB\f(BIget_context\fB\|(3)\fR, \fB\f(BIval_getaddrinfo\fB\|(3)\fR, \fB\f(BIval_gethostbyname\fB\|(3)\fR
.PP
\&\fB\f(BIlibval\fB\|(3)\fR
.PP
http://dnssec\-tools.sourceforge.net
