=pod
                                                                                
=head1 NAME

val_resolve_and_check, 
val_free_result_chain - query and validate answers from a DNS name server

val_istrusted - check if status value corresponds to that of a trust-worthy answer.

val_create_context, val_free_context, val_switch_policy_scope - manage validator context

resolver_config_set, 
root_hints_set, 
dnsval_conf_set,
resolver_config_get, 
root_hints_get, 
dnsval_conf_get  - set/get current location for the validator configuration files.

p_as_error, p_val_error - display validator status information

=head1 SYNOPSIS

#include <validator.h>

int val_resolve_and_check( val_context_t          *context,
                     u_char                 *domain_name_n,
                     const u_int16_t        type,
                     const u_int16_t        class,
                     const u_int8_t         flags,
                     struct val_result_chain      **results);

void val_free_result_chain(struct val_result *results);

int val_istrusted(val_status_t val_status);

int val_create_context(const char *label, val_context_t **newcontext);

int val_switch_policy_scope(val_context_t *ctx, const char *label);

void val_free_context(val_context_t *context);

char *resolver_config_get(void);

int resolver_config_set(const char *name);

char *root_hints_get(void);

int root_hints_set(const char *name);

char *dnsval_conf_get(void);

int dnsval_conf_set(const char *name);

char *p_as_error(val_astatus_t valerrno);

char *p_val_error(val_status_t valerrno);


=head1 DESCRIPTION

The B<val_resolve_and_check()> function can be used to query a set of name
servers for the <I<domain_name_n>, I<type>, I<class>> tuple and 
to verify and validate the response. Verification is the step of 
checking the RRSIGs and validation includes performing 
verification up the chain of trust all the way to a trust 
anchor. The I<domain_name_n> parameter is the queried name in 
DNS wire format. The conversion from host format to DNS wire format 
can be done using the  B<ns_name_pton()> function exported by 
the B<libsres(3)> library.

Answers returned by B<val_resolve_and_check()> are made available 
in the *I<results> array.  Each answer is a 
distinct RRset; multiple RRs within the RRset are
treated as the same answer. Multiple answers are possible when
I<type> is C<ns_t_any> or when a proof of non-existence is 
returned in which case RRsets of type C<ns_t_nsec> and 
C<ns_t_soa> are also returned. 

Individual elements in *I<results> point to the authentication chain
contained within the val_authentication_chain linked list. The authentication chain elements contain
the actual RRsets returned by the name server in response to the
query. 

Most applications would only require the status value within 
*I<results> since this provides a 
single error code for representing the authenticity of returned 
data. Other more intrusive applications such as a DNSSEC 
troubleshooting utility may look at the individual authentication chain element 
to identify what particular component in the chain-of-trust led 
to validation failure if any. B<val_istrusted()> is a helper function
that can be used to easily identify if a given validator status value
corresponds to one of the authenticated and/or trusted data codes.
Validator status values returned in the val_result_chain and val_authentication_chain
linked lists can be displayed in a user understandable format using the functions
B<p_val_error()> and B<p_as_error()> respectively.

The libval library internally allocates memory for *I<results> 
and this must be freed by the invoking application 
using the B<free_result_chain()> interface.

The first parameter to B<val_resolve_n_check()> is the validator context. 
Applications can create a new validator context using the
B<val_create_context()> function. This function parses the resolver and validator 
configuration files and creates the handle I<newcontext> to this parsed 
information. Information stored as part of validator context includes 
the validation policy and resolver policy. 
Validator and resolver policy are read by default from
the B</etc/dnsval.conf> and B</etc/resolv.conf> files. "Root hints"
that allows the library to bootstrap its lookup process when functioning 
as a full resolver is read from B</etc/root.hints>. The locations of each
of these files may be changed using the interfaces B<dnsval_conf_set>, 
B<resolver_config_set> and B<root_hints_set> respectively. 
The corresponding "get" interfaces, namely, B<dnsval_conf_get>, 
B<resolver_config_get> and B<root_hints_get> can be used to return the 
current location from where these configuration files are read. 

Validator policy is applied hierarchically based on the name used to 
identify a particular policy fragment. 
As an example, C<browser> and C<mozilla.browser> form a 
hierarchical ordering of policy, where the configuration 
under the identifier of C<mozilla.browser> may be used to override 
generic browser policy with mozilla-specific options. Applications may
switch their default policy to a policy that lies below (C<mozilla:browser> 
lies below C<browser>) the originally defined label using the 
B<val_switch_policy_scope()> function. In both of the B<val_resolve_n_check()> 
and B<val_switch_policy_scope()>, the I<label> parameter is a simple string that
must match another string which appears as the policy definition
identifier in the validator configuration file. It is a simple text string
with the C<:> character used as the delimiter between two levels in the
hierarchy. The C<:> label by itself refers to the default policy in the 
configuration file. 


=head1 DATA STRUCTURES

=over 4

=item I<struct val_result_chain> { 

    val_status_t val_rc_status;
    struct val_authentication_chain *val_rc_trust;
    struct val_result_chain *val_rc_next;
};


=over 4


=item I<val_rc_trust> 

The authentication chain for a given RRset. 

=item I<val_rc_next> 

Points to the next RRset in the set of answers returned for a query.

=item I<status> 

The validation status for a given RRset. This can be one of the following:

	VAL_LOCAL_ANSWER
		Answer was available from a local file.

	VAL_BARE_RRSIG
		No DNSSEC validation possible, query was for an RRSIG.

	VAL_NONEXISTENT_NAME        
		No name present, trusted, and proof present.

	VAL_NONEXISTENT_TYPE
		No type exists for name, trusted, and proof present.

	VAL_ERROR
		Did not have sufficient or relevant data to complete validation, 
		or encountered some DNS error.

	VAL_DNS_ERROR_BASE < x < VAL_DNS_ERROR_LAST
		where is one of the resolver error codes described in libsres(3).

	VAL_INDETERMINATE
		Lacking information to give a more conclusive answer.

	VAL_BOGUS
		Validation failure condition.

	VAL_NOTRUST
		All available components in the authentication chain verified
		properly, but there was no trust anchor available.	

	VAL_SUCCESS
		Answer received and validated successfully.


Error values in val_status_t returned by the validator can be displayed 
in a more user friendly format using the B<p_val_error()> function.

=back

=back

=over 4

=item I<struct val_authentication_chain> {

    val_astatus_t val_ac_status;
    struct val_rrset *val_ac_rrset;
    struct val_authentication_chain *val_ac_trust;
    struct val_authentication_chain *val_ac_rrset_next;
    struct val_authentication_chain *val_ac_next;
};

=over 4

=item I<val_ac_status> 

This contains the validation state of the authentication chain element. Upon completion 
of the B<val_resolve_n_check()> call this field will contain the error
or success code for DNSSEC validation over the current authentication chain element. This
field may contain the following values:

	VAL_A_DNSKEY_NOMATCH
		RRSIG was created by a DNSKEY that does not exist in the apex keyset.

	VAL_A_WRONG_LABEL_COUNT
		The number of labels on the signature is greater than the the count given in
		the RRSIG RDATA.

	VAL_A_SECURITY_LAME
		RRSIG created by a key that does not exist in the parent DS record set.

	VAL_A_NOT_A_ZONE_KEY
		The key used to verify the RRSIG is not a zone key, but some other key such as
		the public key used for TSIG.

	VAL_A_RRSIG_NOTYETACTIVE
		The RRSIG's inception time is in the future.

	VAL_A_RRSIG_EXPIRED
		The RRSIG has expired.		

	VAL_A_ALGO_NOT_SUPPORTED
		Algorithm in DNSKEY or RRSIG or DS is not supported.

	VAL_A_UNKNOWN_ALGO
		Unknown DNSKEY or RRSIG or DS algorithm
	
	VAL_A_RRSIG_VERIFIED
		The RRSIG verified successfully.

	VAL_A_RRSIG_VERIFY_FAILED
		The RRSIG did not verify.
	
	VAL_A_NOT_VERIFIED
		Different RRSIGs failed for different reasons

	VAL_A_KEY_TOO_LARGE
		The zone is using a key size that is too large as per local policy.

	VAL_A_KEY_TOO_SMALL
		The zone is using a key size that is too small as per local policy

	VAL_A_KEY_NOT_AUTHORIZED
		The zone is using a key that is not authorized as per local policy.
	
	VAL_A_ALGO_REFUSED
		Algorithm in DNSKEY or RRSIG or DS is not allowed as per local policy

	VAL_A_CLOCK_SKEW
		Verified but with clock skew taken into accoun

	VAL_A_DUPLICATE_KEYTAG
		Two DNSKEYs have the same keytag

	VAL_A_NO_PREFERRED_SEP
		There is no DNSKEY in the parent DS set that our local policy allows us to
		traverse

	VAL_A_WRONG_RRSIG_OWNER
		The RRSIG and the data that it purportedly covers have differing notions of
		owner name

	VAL_A_RRSIG_ALGO_MISMATCH
		 The DNSKEY and RRSIG pair have a mismatch in their algorithm.

	VAL_A_KEYTAG_MISMATCH
		 The DNSKEY and RRSIG pair have a mismatch in the key tags.
		
	VAL_A_VERIFIED
		The signature verified OK.

	VAL_A_LOCAL_ANSWER
		Answer was obtained locally. 

	VAL_A_TRUST_KEY
		The key present in this authentication chain element is trusted.

	VAL_A_TRUST_ZONE
		The zone in this authentication chain element is trusted.

	VAL_A_BARE_RRSIG
		Query was for an RRSIG.

In cases where data is insufficient to generate a validation result, 
I<val_ac_status> may also contain the following status values. The final 
validation result in val_status_t in such circumstances is VAL_ERROR.

	VAL_A_DATA_MISSING
		No data was returned in the response. Based on what data was queried
		for this also covers cases where the DNSKEY or DS are missing.
	
	VAL_A_RRSIG_MISSING
		Could not find an RRSIG that matched the query type.

	VAL_A_DNSKEY_MISSING
		Could not find a DNSKEY for verifying the RRSIG over a resource record.

	VAL_A_DS_MISSING
		Could not find a DS for verifying a given DNSKEY. 

	VAL_A_NO_TRUST_ANCHOR
		No trust anchor at current level and no possiblity
		for finding any up this tree.

	VAL_A_UNTRUSTED_ZONE
		The zone has been configured as un-trusted.
	
	VAL_A_IRRELEVANT_PROOF
		An NSEC received does not contribute towards proving
		non-existence.

	VAL_A_DNSSEC_VERSION_ERROR
		DNSSEC version error. Not implemented.		

	VAL_A_TOO_MANY_LINKS
		Too many links were traversed in going up the chain-of-trust. 
		Not implemented.

	VAL_A_UNKNOWN_DNSKEY_PROTO
		The protocol field in the DNSKEY is not set to 3 (DNSSEC).	

	VAL_A_FLOOD_ATTACK_DETECTED
		Detected multiple (conflicting) answers for the same query. 
		Possible spoofing attack. Not implemented.

	VAL_A_DNS_ERROR_BASE < x < VAL_A_DNS_ERROR_LAST
		where x is one of the error values returned by the resolver as 
		described in libsres(3) including the following:

		SR_CONFLICTING_ANSWERS	
			Multiple answers received for a query which conflict.

		SR_REFERRAL_ERROR
			Some error encountered while following referrals.

		SR_MISSING_GLUE
			Glue was missing

=item I<val_ac_rrset> 

This field contains a pointer to an RRset of type B<struct val_rrset>
obtained from the DNS response.

=item I<val_ac_rrset_next> 

Certain queries may return more than one RRset as part of the answer.
This field points to the next RRset in the DNS response.

=item I<val_ac_trust> 

This field points to an authentication chain element that either contains a DNSKEY RRset that
can be used to verify RRSIGs over the current record, or contains a DS
RRset that can be used to build the chain-of-trust towards a trust
anchor. 

=item I<val_ac_next> 

This field points to the next element in the val_authentication_chain linked-list.

=back

=back

=over 4

=item I<struct val_rrset> {
    u_int8_t  *val_msg_header; 
    u_int16_t val_msg_headerlen;
    u_int8_t  *val_queryset_data;
    u_int16_t val_queryset_datalen;
    u_int8_t  *val_rrset_name_n; 
    u_int16_t val_rrset_class_h;
    u_int16_t val_rrset_type_h;
    u_int32_t val_rrset_ttl_h;
    u_int8_t  val_rrset_section;
    struct rr_rec *val_rrset_data;
    struct rr_rec *val_rrset_sig;
};

=over 4

=item I<val_msg_header> 

The header of the DNS response in which the RRset was received

=item I<val_msg_headerlen> 

The length of the header information in I<val_msg_header>.

=item I<val_queryset_data> 

The query section of the DNS response in which the RRset was received.

=item I<val_queryset_datalen> 

The length of the query section in I<val_queryset_data>.

=item I<val_rrset_name_n> 

The owner name of the RRset represented in on-the-wire format.

=item I<val_rrset_class_h> 

The class of the RRset.

=item I<val_val_rrset_type_h> 

The type of the RRset.

=item I<val_rrset_ttl_h> 

The TTL of the RRset.

=item I<val_rrset_section> 

The section in which the RRset was received -- VAL_FROM_ANS, VAL_FROM_AUT or VAL_FROM_ADD.

=item I<val_rrset_data> 

The response RDATA.

=item I<val_rrset_sig> 

Any associated RRSIGs for the RDATA returned in I<val_rrset_data>. 

=back
=back

=over 4

=item I<struct rr_rec> {
	u_int16_t       rr_rdata_length_h;  
    u_int8_t        *rr_rdata;      
    val_astatus_t    rr_status;
    struct rr_rec   *rr_next;
};

=over 4

=item I<rr_rdata_length_h> 

The length of data stored in I<rr_rdata>.

=item I<rr_rdata> 

The RDATA bytes.

=item I<rr_status> 

The verification status of the RRSIG. This value is set 0 for the RDATA portion.

=item I<rr_next> 

Points to the next resource record in the RRset.

=back
=back

=head1 RETURN VALUES

=over 4

=item B<val_resolve_n_check()> can return one of the following values:

=over 4

=item VAL_NO_ERROR

No error was encountered.

=item VAL_GENERIC_ERROR   

Generic error encountered.

=item VAL_NOT_IMPLEMENTED 

Functionality not yet implemented. 

=item VAL_OUT_OF_MEMORY 

Could not allocate memory.

=item VAL_BAD_ARGUMENT

Bad arguments passed as parameters.

=item VAL_INTERNAL_ERROR

Encountered some internal error.

=item VAL_NO_PERMISSION 

No permission to perform operation. Currently not implemented.

=item VAL_RESOURCE_UNAVAILABLE

Some resource (crypto possibly) was unavailable. Currently not implemented.

=back

=back

=over 4

=item B<val_create_context()> can return one of the following values:

=over 4

=item VAL_NO_ERROR

No error was encountered.

=item VAL_OUT_OF_MEMORY 

Could not allocate memory.

=item VAL_CONF_PARSE_ERROR

Error in parsing some configuration file.

=item VAL_CONF_NOT_FOUND 

A configuration file was not available.

=back

=back

=over 4

=item B<val_switch_policy_scope()> can return one of the following values:

=over 4

=item VAL_NO_ERROR

No error was encountered.

=item VAL_OUT_OF_MEMORY 

Could not allocate memory.

=item VAL_NO_POLICY 

A policy with the specified label (identifier) was not found.

=back

=back

=head1 FILES

The validator library reads configuration information from two separate files,
/etc/resolv.conf and /etc/dnsval.conf.

Only the "nameserver" option is supported in the resolv.conf file. This option
is used to specify the IP address of the name server to which queries must be
sent by default. For example,

nameserver 10.0.0.1

See B<dnsval.conf(3)> for a description of the validator configuration file.

=head1 CURRENT STATUS

There is currently no support for IPv6. 
The caching functionality is very basic and no timeout logic currently exists. 
There are a number of feature enhancements that still remain to be done.

=head1 COPYRIGHT
                                                                                
Copyright 2004-2006 SPARTA, Inc.  All rights reserved.
See the COPYING file included with the dnssec-tools package for details.

=head1 SEE ALSO

B<dnsval.conf(3)>

B<libsres(3)>

B<val_x_query(3)>

http://dnssec-tools.sourceforge.net

=cut	
