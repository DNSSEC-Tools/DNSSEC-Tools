# Copyright 2004-2005 SPARTA, Inc.  All rights reserved.
# See the COPYING file included with the dnssec-tools package for details.


			     DNSSEC-Tools
			Is your domain secure?


DNSSEC-aware Resolver library
-----------------------------

A library that is capable of sending queries to, and receiving answers
from a DNSSEC-aware name server.


Overview 
--------

This library provides the resolver component of the "validating resolver"
(see libval_implementation_notes for details on the validator component). 
It provides the interfaces necessary for the validator to fetch answers from
a DNSSEC-aware name server. 

The resolver library does not itself perform any recursion. This design 
choice was made reduce the complexity within the resolver and keep it
as DNSSEC-agnostic as possible (DNSSEC-relevant information is present in
the additional section of the referrals). The library still needs to be 
'DNSSEC-aware' in that queries that it sends must have the DO bit 
(and consequently EDNS0) and CD bits set to permit all DNSSEC-relevant 
resource records to be returned in different sections of the DNS response. 

The resolver library is built to support both synchronous as well as 
asynchronous queries to the DNS. Asynchronous queries are a useful 
optimization feature in some instances, where it is possible to 
parallize other time-consuming operations while the query is in transit.

The following interfaces are exported by the libsres library (more 
details may be found in the libsres manual page):

int query_send( const char      *name,
            const u_int16_t     type,
            const u_int16_t     class,
            struct name_server  *nslist,
            int                 *trans_id);

int response_recv(int           *trans_id,
            struct name_server  **respondent,
            u_int8_t            **response,
            u_int32_t           *response_length);

int get ( const char            *name_n,
            const u_int16_t     type_h,
            const u_int16_t     class_h,
            struct name_server  *nslist,
            struct name_server  **respondent,
            u_int8_t            **response,
            u_int32_t           *response_length);

int clone_ns(struct name_server **cloned_ns, struct name_server *ns);

int clone_ns_list(struct name_server **ns_list,
                        struct name_server *orig_ns_list);

void free_name_server (struct name_server **ns);

void free_name_servers (struct name_server **ns);

query_send() and response_recv() provide the asynchronous query/response 
interface to the libsres library. A synchronous interface to the 
query/response mechanism can be implemented using the above interfaces 
as shown below:

if (SR_UNSET == (ret_val = query_send(name, type, class, 
        				nslist, &trans_id))) {
	do {
		ret_val = response_recv(&trans_id, server, 
						response, response_length);
	} while (ret_val == SR_NO_ANSWER_YET);
}

The above code segment forms the essence of the get() interface.

The clone_ns (clone_ns_list) interface can be used to make a copy of an
existing name server structure (name server list). The free_name_server(s)
methods can be used to free up memory allocated within the name_server
structure.

Other symbols exported by the libsres library include the following: 
        nametoclass, nametotype,
        ns_name_ntop, ns_name_pton, ns_name_unpack ns_parse_ttl,
        p_class, p_sectionp_type
The above are helper functions that have been directly imported from 
the BIND library.

The libsres libarary perfoms some basic header checking on the 
data that it receives from the name server before sending it on to
the application that initiated the query. Rcodes normally returned 
by the name server are passed back as return values to the get() and 
response_recv() methods. Only two non-error rcodes exist -- 
the no error RCODE itself and the NXDOMAIN response. The NXDOMAIN 
response is considered as "no error" when there are only SOA or NSEC 
records in the authority section (proof of non-existence).

The query transmission framework
--------------------------------

The brief algorithm is as given below. This logic is invoked each time a 
call is made to the res_io_accept method().

1. while there are more name servers to query
	1.1. Send the query to the first name server and wait for ns.ns_retrans
             seconds
	1.2. If there is no response, send the query to the next name server and
	     increment the delay for the first name server by its current
             ns_retrans 
	1.3. If the number of retries for a name server has exceeded ns.ns_retry
             stop attempting to re-send this query to this name servers. 
	1.4. Keep adding name servers in a staggered fashion while re-trying
             queries to existing name servers.
2. wait for a response or for all requests to time out

If res_io_method() is called within a loop (such as the case in get()), the 
pattern of (re)transmissions is roughly ( for _res.retries = 4, 
_res.delay = 5, three servers, one address each):

         0  5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 (seconds)
Svr 1 :  1  2     3           4                Give up
Svr 2 :     1  2     3           4                Give up
Svr 3 :        1  2     3           4                Give up

All pending queries are destroyed once an answer is obtained. From
the application's standpoint the answer may still not be complete, in which
case it may wish to retry a different set of name servers or query 
separately for missing data. 


Resolver Current Status
-----------------------

This library provides very basic functionality for name resolution. 
The data structures and interfaces exported to applications are still 
in a state of flux.  Support for thread-safety is very basic. 

There is still some reliance on BIND code (although these are mostly 
helper routines) and some other libbind artifacts.

Acknowledgements
----------------

Most of the code in the libsres library was derived from an earlier 
implementation of the secure resolver library written by 
Ed Lewis at Tislabs. 
